---
title: "EMT Multi-Omics"
subtitle: "Deconvolution of proteomics data using scRNA-Seq"
author: "Ahmed Youssef"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: pdf_document
urlcolor: blue
toc: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, results = 'hide')

#required packages
library(data.table) #reading in large files quickly
library(kableExtra) #for tables
library(dplyr) #data wrangling
library(magrittr) #data wrangling
library(reshape2) #data wrangling
library(tidyr) #data wrangling
library(tibble) #data wrangling
library(ggplot2) #plots
library(patchwork) #plot figures plots on same plot
library(ComplexHeatmap) #heatmaps
library(pheatmap) #heatmaps
library(Seurat) #scRNA clustering
library(VennDiagram) #venn diagram
library(uwot) #UMAP
library(pracma) #distance between matrices
library(Matrix) #matrix operations
library(quadprog) #solving constrained OLS problem
library(glmnet) #ridge regression
library(pbapply) # parallel operations
library(ggpubr) #correlation plots annotation
```

# Introduction

Biological research has become increasingly defined by the generation of large-scale datasets in need of specialized computational analysis to unravel the complexities underlying living systems. The fundamental unit of all living organisms is the cell, and recent technological advances have granted us unprecedented opportunities to study life at this principal level. Proteins, through their networks of interactions, carry out most of the vital biological processes governing cellular functions, yet remain largely unexplored at the  resolution of single cells, representing crucial gaps in our knowledge of cell biology. The current pandemic has exposed our need for a better understanding of the contextual nature of cellular functions in order to develop effective targeted therapies. While there remain challenging technical hurdles to overcome for experimentally measuring proteins on a systems-wide scale at the level of individual cells, single-cell RNA sequencing (scRNA-Seq) has emerged in recent years as a powerful technology for defining cell states on a large scale, enabling breakthroughs in many areas of cell biology research, and raising the question of whether this type of data can be used for making inferences at the protein level. **In this report, we explore the deconvolution of bulk proteomics data to the single-cell level using scRNA-Seq data.**

# Experiment summary

Epithelial-to-mesenchymal transition (EMT) is a biological process in which epithelial cells gradually lose their adhesion and transition into mesenchymal cells. As one of the hallmarks of cancer progression, it is one of the long-standing interests of the biomedical research community. Towards profiling this process, protein and RNA samples were extracted from cells at 8 different timepoints during EMT and multiple layers of omics data were generated. These omics layers include proteomics, transcriptomics, phosphoproteomics, secretome, exosome among others. A pre-print with more details on the experiment and generated data can be found on bioRxiv [here (Paul et al, 2021)](https://www.biorxiv.org/node/2018285.external-links.html). This report is interested in the scRNA-Seq, microarray, and proteomics datasets generated in this study.

# Rationale

A regression-based approach to this problem is suggested here which is primarily concerned with the lack of strong correlation between a gene’s RNA and protein levels, which is the main challenge with analyses aiming to integrate these two data modalities. Multiple biological and technical factors, such as alternative splicing and post-translational modifications, drive the weak correlation between the RNA and protein levels of the same set of genes, thus preventing us from using the gene expression values derived from scRNA-Seq to make inferences on the corresponding protein levels. Our approach aims to bridge this gap by utilizing the ability of scRNA-Seq to delineate functionally-distinct cell populations from heterogeneous mixtures, allowing us to distinguish the identity and proportions of the different cells populations making up the bulk sample for which we have the proteomics data measurements, as well as how these proportions change under different experimental contexts such as health and disease. We cannot reliably use these proportions to directly estimate the contribution of each population to each protein’s abundance at the bulk-level, however, due to variations in the relative abundance of each protein across the different cell populations. Leveraging the shifts in the bulk sample composition, as quantified by scRNA-Seq, we can instead use a regression model to combine the changes in cell population proportions with the corresponding fluctuations in bulk-level protein abundance as suggestive of relationships between specific cell populations and bulk protein levels. This information can then be used to estimate the protein levels within each cell population. Essentially, this approach aims to leverage scRNA data to break down bulk proteome measurements into cell population-level proteomes. 

# Data summary - Proteomics

The bulk proteomics data was generated in the Emili Lab using standard mass-spectrometry. Summary of the dataset follows:

-   6,967 proteins
-   10 different timepoints
-   Three replicates

The average intensity across replicates was computed for each protein in each timepoint. Timepoints 3 and 9 were removed since they are not present in the scRNA data.

```{r readProteome, fig.height = 3}
#read in '2D' proteomics data and average replicates in each timepoint
proteome <- fread("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/proteinGroups_Prot.txt") %>% 
  as.data.frame() %>% 
  .[, c("Gene names", grep("Reporter intensity corrected .* [A-C]", colnames(.), value = TRUE))] %>% 
  magrittr::set_names(c("Gene", gsub("Reporter intensity corrected ", "T", colnames(.)[-1]))) %>% 
  melt() %>% 
  #average replicates
  mutate(variable = gsub(" .*","", variable)) %>% 
  group_by(Gene, variable) %>% 
  summarize(intensity = mean(value)) %>% 
  #convert to wide format
  dcast(Gene ~ variable) %>% 
  magrittr::set_rownames(.$Gene) %>% 
  #remove timepoints that are not present in scRNA data
  select(-c(1, 5, 11)) %>%
  as.matrix()

#normalize data such that each timepoint sums to 1
#proteome <- apply(proteome, 2, function(x) return(x/sum(x)))
```

# Data summary - scRNA-Seq

The bulk proteomics data was generated in the Emili Lab using standard mass-spectrometry. Summary of the dataset follows:

-   9,785 genes
-   1,913 cells (\~200 cells per timepoint)
-   8 different timepoints

Prior to this summation, genes with zero variance as well as those with non-zero counts in less than 5% of all cells were removed. This removed 17 genes (0.2% of all genes). The data was also normalized such that each cell sums to 1.

```{r readSCRNA}
#read in data
scrna <- data.frame(fread("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/scRNAseq_filt_dat.txt", stringsAsFactors = FALSE)) %>% 
  magrittr::set_rownames(.$Gene.names) %>% 
  select(-1)

#compute variance of genes
geneVar <- apply(scrna, 1, var) %>% 
  .[. > 0]

#remove genes with zero variance
scrna <- scrna[names(geneVar),]

#get percentage of cells each gene is expressed in
cellsPerGene <- apply(scrna, 1, function(x) sum(x > 0) / length(x)) %>% 
  .[. >= 0.05]

#remove genes expressed in less than 5% of all cells
scrna <- scrna[names(cellsPerGene),]

#filter out lowly-expressed genes (threshold is at least 3 counts in 3 cells - removed 1,240 genes)
scrna <- scrna[rowSums(scrna > 3) > 3,]

#group scRNA data by cell and normalize to sum to 1
scrna <- scrna %>% 
  as.data.frame() %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  group_by(variable) %>% 
  mutate(value = value / sum(value)) %>%
  dcast(gene ~ variable) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.data.frame()

#get number of cells in each timepoint
cellsPerTimepoint <- table(gsub(".*_","", colnames(scrna)))
```

# Data summary - Bulk mRNA

The bulk mRNA data comes from a microarray experiment. Summary of the dataset follows:

-   23,743 genes
-   10 different timepoints
-   Three replicates

The average intensity across replicates was computed for each protein in each timepoint. Timepoints 3 and 9 were removed since they are not present in the scRNA data.

```{r bulkRNA, results='hide'}
#read in data
mrna <- read.delim("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/emt_mRNA.txt", stringsAsFactors = F) %>% 
  melt() %>% 
  ##average replicates
  mutate(variable = gsub("RIC.","T", variable), Gene.names = gsub("_mRNA", "", .$Gene.names)) %>% 
  group_by(Gene.names, variable) %>% 
  summarize(counts = mean(value)) %>% 
  #remove log-transformation
  mutate(counts = (2^counts)-1) %>% 
  ##convert to wide format
  dcast(Gene.names ~ variable) %>% 
  magrittr::set_rownames(.$Gene.names) %>% 
  #remove inconsistent timepoints
  select(-c(1, 5, 11)) %>%
  as.matrix()

#normalize data such that each timepoint sums to 1
#mrna <- apply(mrna, 2, function(x) return(x/sum(x)))
```

\newpage
# Protein overlap

The Venn diagram below shows the overlap of the identified proteins in the datasets.

```{r proteinOverlap, fig.height = 4, fig.width = 7}
#list of genes detected in each dataset
allGenes <- list("scRNA-Seq" = rownames(scrna), "Proteomics" = rownames(proteome), "Bulk mRNA" = rownames(mrna))

#list of overlapping genes
overlapGenes <- Reduce(intersect, allGenes)

#retain overlapping genes only in the datasets
#scrna <- scrna[overlapGenes,]
#proteome <- proteome[overlapGenes,]
#mrna <- mrna[overlapGenes,]

#venn diagram
ggvenn::ggvenn(data = allGenes, 
               columns = c("scRNA-Seq", "Proteomics", "Bulk mRNA"))
```


# Approach

Prior to making inferences from the proteomics data, we first investigate the ability to recover the scRNA data from the bulk data at the RNA-level where we have the true single-cell profiles to compare against. The underlying principle of our model is that the bulk data is the  summation of the single-cell data, which can be represented using the simple formula $Bulk = Number\_of\_cells * Single\_cell\_expression$, for which we will use the notation $Y = AX$ throughout this report. The figure below shows a graphical representation of this model.


![Schematic of single-cell deconvolution model](/Users/Ahmed/Documents/Emili_Lab/Aim%203/EMT%20Multi-omics/Plots/bulk%20decnovolution%20outline.png) 
The five main steps underlying our approach are outlined below:

1) ***Clustering***:  The cell states in our dataset are identified in an unsupervised manner based on similarity of gene expression profiles. All cells from all timepoints are pooled together for this analysis. For data pre-processing, we remove the genes with low expression counts, retaining genes with a minimum of 3 counts in at least 3 cells. This removed 1,240 genes (13% of all genes). On average, each cell expressed ~3,600 genes after processing. [Seurat](https://www.nature.com/articles/nbt.4096) is then used to cluster the cells with their default workflow based on the 2,000 most variable genes. We tested our approach on different pre-defined numbers of clusters in our analysis to examine the effect of varying the number of cell populations.

2) ***Construct cell type proportions matrix A***: The timepoint \* cluster mixing matrix $A$ is constructed by counting the numbers of cell from each cluster in each timepoint.

3) ***Construct cell cluster matrix X***: The cluster \* gene matrix $X$ is constructed by averaging the gene expression of each cluster.

4) ***Create pseudo-bulk matrix Y***: Construct timepoint \* gene pseudobulk matrix $Y$ using the formula $Y = AX$.

5) ***Predicting single-cell profiles using ridge regression***: Re-create the single-cell data from the pseudo-bulk data $Y$ and the timepoint-specific cell cluster counts $A$ based on the formula $Y = AX$ by using the formula $X' = (A^TA)^{-1}(A^TY)$, which is essentially the pseudo-inverse of $A$ multiplied by the pseudo-bulk $Y$. To achieve this, we solve the non-negative constrained equation $\hat{X} = min_{x >= 0}(-2Y^T A X + X^T A^T A X)$ after adding a ridge penalty $\lambda$ to the diagonal of the matrix $A^TA$. The R function [*solve.QP*](https://www.rdocumentation.org/packages/quadprog/versions/1.5-8/topics/solve.QP) from the [*quadprog*](https://cran.r-project.org/web/packages/quadprog/quadprog.pdf) package is used to solve this equation one gene at a time to estimate the expression profile at the cell-type level. To decide on the optimal value for the parameter $\lambda$, we test a range of 21 values between $1^{-10}$ to $1^{10}$ for each gene and each number of clusters. For each value of $\lambda$, we compute the relative error in estimating each gene's single-cell profile as a measure of the accuracy of the predicted single-cell profile. The $\lambda$ that leads to the minimal error is selected as the optimal value for the corresponding gene. 

To summarize, the following three matrices represent the key variables in our model:

-   Matrix $A$ of dimensions $timepoints * clusters$. (cell type counts in each timepoint)
-   Matrix $X$ of dimensions $clusters * genes$. (cluster-averaged single-cell RNA data)
-   Matrix $Y$ of dimensions $timepoints * genes$. (bulk data)

We then attempt to re-create the single-cell matrix $X'$ data by computing $Y = AX'$.

# Method Development and Optimization

The key input parameter for the deconvolution algorithm is the regularization parameter $\lambda$ for solving the ridge regression problem. After selecting the optimal $\lambda$ for each gene we report the errors as relative RMAD (relative mean absolute deviation) using the formula $|X - X'| / X$, where $|X|$ is the absolute value of the difference. This error is computed for each gene and the final reported score is the average RMAD value, in other words: *on average, how different is a gene's predicted values compared to the true ones?* The resultant relative RMAD values are shown below.

```{r keyFunctions}
#function to create pseudobulk from scRNA-Seq data
createPseudoBulk <- function(scrna){
  #create list of timepoints
  timepoints <- unique(gsub(pattern = ".*_", replacement = "", colnames(scrna)))
  
  #create single-cell pseudo bulk data
  pseudoBulk <- list()
  for(t in timepoints){
    #get single-cell rna-seq in this timepoint
    curSC <- scrna[, grep(pattern = t, colnames(scrna))]
    
    #create pseudo-bulk by summing values
    curPseudo <- rowSums(curSC)
    curPseudo[is.na(curPseudo)] <- 0
    
    #log-transform and quantile normalize
    #curPseudo <- log2(curPseudo+1)
    #curPseudo <- preprocessCore::normalize.quantiles(as.matrix(curPseudo))
    
    #add current timepoint pseudo-bulk to list 
    pseudoBulk[[t]] <- curPseudo
    rm(curPseudo, curSC)
  }
  pseudoBulk <- data.frame(pseudoBulk)
  rownames(pseudoBulk) <- rownames(scrna)
  return(as.matrix(pseudoBulk))
}

#create seurat object for downstream clustering
createSeurat <- function(counts){
  # Initialize the Seurat object with the raw (non-normalized data).
  seurat <- CreateSeuratObject(counts = counts, project = "EMT")
  
  #normalize data
  seurat <- NormalizeData(seurat)
  
  #scale data
  all.genes <- rownames(seurat)
  seurat <- ScaleData(seurat, features = all.genes)
  
  #find most variable genes
  seurat <- FindVariableFeatures(seurat, selection.method = "vst", nfeatures = 2000)
  
  #PCA on most variable genes
  seurat <- RunPCA(seurat, features = VariableFeatures(object = seurat))
  
  #construct KNN using 10 PCs
  seurat <- FindNeighbors(seurat, dims = 1:10)
  
  return(seurat)
}

#function to compute cell-type proportions 'A' given seurat-clustered data
computeCellProportions <- function(seuratObject){
  #construct matrix with number of cells from each type in each timepoint
  A <- as.data.frame(seuratObject@assays$RNA@counts) %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cluster = Idents(seuratObject)[variable], timepoint = gsub(".*_","", variable)) %>% 
    group_by(cluster, timepoint) %>% 
    summarize(count = length(unique(variable))) %>% 
    tidyr::spread(key = cluster, value = count, fill = 0) %>% 
    tibble::column_to_rownames("timepoint")
  
  #convert to matrix format
  A <- as.matrix(A)
  
  return(A)
}

#function to recover X from Y' by using X = pseudo-inverse of A * Y'
computeSCprofiles <- function(bulk, timeProportions){
  
  #predict scRNA matrix based on bulk and time proportions matrix
  #X_hat <- solve(t(A) %*% A) %*% (t(A) %*% Y_hat)
  sc <- pracma::pinv(timeProportions) %*% bulk
  
  return(sc)
}

#combine ridge regression with a non-negative constraint
constrainedRidgeRegression <- function(bulk, timeProportions, lambda){
  #define required matrices/vectors for the quadratic solver
  Dmat <- t(timeProportions) %*% timeProportions
  Amat <- diag(ncol(timeProportions))
  
  #add small scaling of the identity matrix to Dmat to regularize prediction
  Dmat <- Dmat + lambda*diag(nrow(Dmat))
  
  #to avoid overflow cause by large values, scale Dmat and dvec
  scalingFactor <- norm(Dmat, "2")
  
  #iterate over genes
  sc <- apply(bulk, 2, function(gene){
    #define required matrices/vectors for the quadratic solver
    dvec <- t(timeProportions) %*% gene
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat / scalingFactor, dvec / scalingFactor, Amat)
    return(qp$solution)
  })
  
  return(sc)
}

#constrained ridge regression with gene-level lambdas
perGeneConstrainedRidgeRegression <- function(bulk, timeProportions, optimalLambdas){
  #subset bulk to include genes for which optimal lambdas are present
  bulk <- bulk[,colnames(bulk) %in% optimalLambdas$Gene]
  
  #define required matrices/vectors for the quadratic solver
  Dmat <- t(timeProportions) %*% timeProportions
  Amat <- diag(ncol(timeProportions))
  
  #iterate over genes
  sc <- lapply(colnames(bulk), function(gene){
    #find optimal lambda for this gene
    lambda <- as.numeric(unlist(optimalLambdas[optimalLambdas$Gene == gene,"Lambda"]))
    
    #get expression values for this gene
    geneAbundances <- bulk[,gene]
    
    #define required matrices/vectors for the quadratic solver
    dvec <- t(timeProportions) %*% geneAbundances
    
    #add small scaling of the identity matrix to Dmat to regularize prediction
    Dmat <- Dmat + lambda*diag(nrow(Dmat))
    
    #to avoid overflow cause by large values, scale Dmat and dvec
    scalingFactor <- norm(Dmat, "2")
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat / scalingFactor, dvec / scalingFactor, Amat)
    return(qp$solution)
  }) %>% 
    do.call("cbind",.)
  colnames(sc) <- colnames(bulk)
  
  return(sc)
}
```

```{r tuneLambdaToIndividualGenes, eval = FALSE}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#set of lambdas to test for ridge regression (should be in decreasing order)
lambdaSet <- sort(10^(-10:10), decreasing = TRUE)

#create seurat object
seurat <- createSeurat(scrna)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters (~25m)
geneLambdas <- pblapply(names(clusters), function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #construct pseudo-bulk matrix
  pseudobulk <- t(createPseudoBulk(scrna = scrna))
  
  #reconstruct pseudo-bulk matrix
  Y <- A %*% X
  
  #bulk mRNA matrix
  bulk_RNA <- t(mrna)
  
  #bulk proteomics matrix
  bulk_proteomics <- t(proteome)
  
  #list of overlapping genes
  overlapGenes <- Reduce(intersect, allGenes)
  
  #retain overlapping genes only in the datasets
  X <- X[,overlapGenes]
  pseudobulk <- pseudobulk[,overlapGenes]
  Y <- Y[,overlapGenes]
  bulk_proteomics <- bulk_proteomics[,overlapGenes]
  bulk_RNA <- bulk_RNA[,overlapGenes]
  
  #re-scale proteomics data to be comparable to RNA
  bulk_proteomics <- bulk_proteomics / (sum(bulk_proteomics) / sum(Y))
  
  #create list of bulk datasets
  bulkDatasets <- list("Pseudobulk" = pseudobulk, "Reconstructed pseudobulk" = Y,
                       "Bulk mRNA" = bulk_RNA, "Proteomics" = bulk_proteomics)
  
  #compute coefficient of variation of genes across clusters
  geneCV <- apply(X, 2, function(x) return(sd(x) / mean(x)))
  
  #group genes into 3 groups according to variance across clusters
  geneCV <- split(sort(geneCV), sort(1:length(geneCV) %% 3))
  names(geneCV) <- c("Low variation", "Medium variation", "High variation")
  
  #create table with each gene's variation classification
  geneVarClass <- do.call("rbind", lapply(names(geneCV), function(x) return(data.frame(Gene = names(geneCV[[x]]), Cross_cluster_variation = x))))
  
  #construct matrix with all combinations of lambda and gene name and bulk dataset
  parameters <- expand.grid(names(bulkDatasets), lambdaSet, clust) %>% 
    set_colnames(c("Dataset", "Lambda", "Number_of_clusters")) %>% 
    merge(geneVarClass,., by = NULL)
  
  #define required matrices/vectors for the quadratic solver
  Dmat <- t(A) %*% A
  Amat <- diag(ncol(A))
  
  #predict single-cell profiles using constrained ridge regression for each value of lambda
  X_hat <- apply(parameters, 1, function(curParameters){
    #extract current parameters
    lambda <- as.numeric(curParameters[["Lambda"]])
    curGene <- bulkDatasets[[as.character(curParameters[["Dataset"]])]][, curParameters[["Gene"]]]
    
    ##predict single-cell profiles
    
    #add small scaling of the identity matrix to Dmat to regularize prediction
    Dmat <- Dmat + lambda*diag(nrow(Dmat))
    
    #to avoid overflow cause by large values, scale Dmat and dvec
    scalingFactor <- norm(Dmat, "2")
    
    #define required matrices/vectors for the quadratic solver
    dvec <- t(A) %*% curGene
    
    #solve quadratic equation
    prediction <- quadprog::solve.QP(Dmat / scalingFactor, dvec / scalingFactor, Amat)$solution
    
    #set names of prediction to clusters
    names(prediction) <- paste0("cluster_", 0:(length(prediction) - 1))
    
    #compute relative error between prediction and real values
    curError <- abs(X[, curParameters[["Gene"]]] - prediction) / X[, curParameters[["Gene"]]]
    curParameters$Relative_error <- mean(curError[!is.infinite(curError)])
    
    #add the predicted value to the table
    curParameters <- cbind(curParameters, data.frame(t(prediction)))
    
    return(as.data.frame(curParameters))
  }) %>% 
    do.call("rbind", .)
  
  return(X_hat)
}, cl = 6)

#merge all results into one table
# get all variable names
allNms <- unique(unlist(lapply(geneLambdas, names)))
geneLambdas <- do.call(rbind, c(lapply(geneLambdas, function(x) data.frame(c(x, sapply(setdiff(allNms, names(x)), function(y) NA)))), make.row.names=FALSE))

geneLambdas$Lambda <- as.numeric(geneLambdas$Lambda)
geneLambdas$Number_of_clusters <- as.integer(geneLambdas$Number_of_clusters)
saveRDS(geneLambdas, "/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/geneLambdas.rds")
```

```{r individualGeneLambdasErrors, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#read in all scores for all values of lambda and all genes
geneLambdas <- readRDS("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/geneLambdas.rds")

#subset to optimal lambdas
optimalLambdas <- geneLambdas %>% 
  group_by(Gene, Number_of_clusters) %>% 
  filter(Relative_error == min(Relative_error)) %>% 
  filter(!is.infinite(Relative_error))

#average errors for each number of clusters
errors <- optimalLambdas %>%
  #filter(Dataset == "Reconstructed pseudobulk") %>% 
  group_by(Number_of_clusters) %>% 
  summarise(Relative_error = mean(Relative_error))

#visualize errors with line plots
ggplot(errors, aes(x = Number_of_clusters, y = Relative_error)) +
  geom_line() + geom_point() +
  scale_x_continuous(breaks = 5:15) +
  labs(title = "Relative error of estimating single-cell profiles for different numbers of clusters")
```

## Distribution of errors across genes

This section explores whether the single-cell predictions might be more accurate for a subset of the genes, such as differential markers, by comparing the distributions of prediction errors for individual genes as they relate to cell-type expression specificity.

To explore the relationship between properties of the genes and their corresponding predicted values, for each gene we compute the following measures:

-   ***Expression specificity:*** This metric looks at the relative specificity of a given gene's expression to the clusters. The coefficient of variation of the gene's cluster-specific expression values is computed as the standard deviation of the per-cluster expression values divided by the mean.

-   ***Average expression:*** This metric is concerned with the relative abundance of each gene's transcript, and is simply computed as the mean expression of the gene across clusters.

Each of the above measures are then compared to the error in predicting the gene's expression value using regression.

```{r distributionOfErrorsAcrossGenesIndividualLambdas, fig.width = 16, fig.height = 16}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
seurat <- createSeurat(scrna)

#for each no. of clusters, get each gene's error, specificity, and average expression (~30s)
predictions <- pblapply(names(clusters), function(clust){
  #get error values for current no. of clusters
  curErrors <- optimalLambdas[optimalLambdas$Number_of_clusters == as.numeric(clust),]
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #keep genes for which the error is not infinity
  X <- X[,colnames(X) %in% curErrors$Gene]
  
  #find error for each gene
  error <- unlist(lapply(colnames(X), function(gene){
    return(unlist(curErrors[curErrors$Gene == gene, "Relative_error"]))
  }))
  
  #compute each gene's coeff. of variation across cell types
  cv <- apply(X, 2, function(gene){
    return(sd(gene) / mean(gene))
  })
  
  #compute each gene's average expression value
  average_expression <- colMeans(X)
  
  #construct table with all values of interest to return
  toReturn <- data.frame(Gene = colnames(X),
                         Number_of_clusters = paste(as.numeric(clust), "clusters"),
                         Error = error,
                         Coef_variation = cv,
                         Av_expression = average_expression)
  return(toReturn)
  
}, cl = 6)
names(predictions) <- paste(names(clusters), "clusters")

#convert list into data frame
predictions <- do.call("rbind", predictions)

#remove 'infinite' entries (dividing by zero)
predictions <- predictions[!is.infinite(predictions$Error),] %>% 
  .[complete.cases(.),]

#correlation plots of errors for each number of clusters
CV_plot <- ggplot(predictions, aes(x = Coef_variation, y = Error)) +
  geom_point() +
  geom_smooth(method = lm) +
  facet_wrap(~ Number_of_clusters, scales = "free") +
  ggpubr::stat_cor(method = "pearson") +
  labs(title = "Relationship between a gene's cluster specificity and prediction errors",
       subtitle = "Each box represents a pre-defined number of clusters")

expression_plot <- ggplot(predictions, aes(x = Av_expression, y = Error)) +
  geom_point() +
  geom_smooth(method = lm) +
  facet_wrap(~ Number_of_clusters, scales = "free") +
  ggpubr::stat_cor(method = "pearson") +
  labs(title = "Relationship between a gene's average expression and prediction errors",
       subtitle = "Each box represents a pre-defined number of clusters")

CV_plot / expression_plot
``` 

\newpage
## Evaluation of single-cell predictions


The below sections examine the accuracy of the single-cell predictions made using ridge regression in the previous section. Note: the bulk matrix that is deconvoluted in this section is the reconstructed pseudo-bulk matrix ($Y=AX$).

#### Are our predicted cluster centroids close to the real ones?

The cluster centroid is each cluster’s average gene expression profile. Visualizing the two sets of centroids (real & predicted) side-by-side on a *UMAP* will help us answer this question. For each number of clusters between 5 and 15, we cluster the data using *Seurat* and construct the matrix $X$ which contains the average gene expression by cluster. We then use the ridge regression approach defined in the previous section to construct the matrix $X'$. Finally, we perform a *UMAP* projection using the R package [uwot](https://github.com/jlmelville/uwot) on the original gene expression matrix but with the addition of the real and predicted cluster centroids, i.e. the rows of $X$ and $X'$. The *UMAP*s below show the projections for each number of clusters.

```{r UMAPpredictedVsRealCentroidsIndividualLambdas, eval = FALSE}
#for each no. of clusters, construct UMAP
umapList <- pblapply(names(clusters), function(clust){
  #get error values for current no. of clusters
  curErrors <- optimalLambdas[optimalLambdas$Number_of_clusters == as.numeric(clust),]
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #get predicted values for current gene
  X_hat <- curErrors %>% 
    as.data.frame() %>% 
    set_rownames(.$Gene) %>% 
    select(grep("^cluster_", colnames(.))) %>% 
    t() %>% 
    .[complete.cases(.),]
  
  #sort matrices to all follow the same order of genes
  overlapGenes <- Reduce(intersect, list(rownames(scrna), colnames(X), colnames(X_hat)))
  scrna <- scrna[overlapGenes, ]
  X <- X[, overlapGenes]
  X_hat <- X_hat[, overlapGenes]
  
  #concatenate centroids to single-cell expression matrix
  mergedSC <- rbind(t(scrna), X, X_hat)
  
  #UMAP
  set.seed(123)
  umap <- as.data.frame(uwot::umap(mergedSC))
  
  #add label indicating whether point is a centroid
  umap$centroid <- c(rep("cell", ncol(scrna)), rep("real centroid", nrow(X)), rep("predicted centroid", nrow(X_hat)))
  
  #add label indicating the no. of cluster for this UMAP
  umap$number_of_clusters <- paste(clust, "clusters")
  
  #add label indicating cell cluster
  umap$cluster <- c(rep(NA, ncol(scrna)), rep(1:nrow(X), 2))
  
  return(umap)
}, cl = 6)

#merge all results into one table
mergedUmap <- do.call("rbind", umapList)

#save locally
saveRDS(mergedUmap, "/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/updated_UMAP_list_sc_predictions.rds")
```

```{r UMAPcomparisonOfPredcitionsIndividualLambdas, fig.width = 16, fig.height = 16}
#read in pre-computed UMAP projections
mergedUmap <- readRDS("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/updated_UMAP_list_sc_predictions.rds") %>% 
  mutate(number_of_clusters = factor(number_of_clusters, levels = paste(5:15, "clusters")))

#plot
ggplot(mergedUmap, aes(x = V1, y = V2, col = centroid)) +
  geom_point() +
  geom_label(label = mergedUmap$cluster) + 
  facet_wrap( ~ number_of_clusters) + 
  scale_color_manual(values = c("grey", "red", "blue"), name = "Key") +
  theme_classic2() +
  ggtitle("UMAP visualization of the predicted cell cluster centroids relative to the predicted ones")
```

#### How similar is the average cell to it's real centroid compared to the predicted one?  

To determine if our predictions are reasonable approximations of the real data, we also compare the predictions to the real data by computing the Euclidean distance between individual cells’ measurements and their real cluster average as opposed to the distance between our predictions and the same cluster average.

More specifically, for a given number of clusters, we cluster the data using *Seurat*, followed by iterating over each of the ~1,900 cells in the original single-cell expression matrix and computing the Euclidean distance between it's profile and that of its cluster's centroid. Next, for each cluster we compute the average distance of it's cells to the centroid, as well as the distance between our predicted centroid and the corresponding cluster centroid. By comparing these two distances side-by-side, we can determine whether our predicted centroids fall within the correct intra-cluster range.

```{r distancesBetweenCellsAndCentroidsIndividualLambdas, fig.width = 16, fig.height = 16}
#for each no. of clusters, predict X' and find average distance between cells and their centroids (~1m)
centroidDistances <- pblapply(names(clusters), function(clust){
  #get error values for current no. of clusters
  curErrors <- optimalLambdas[optimalLambdas$Number_of_clusters == as.numeric(clust),]
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #get predicted values for current gene
  X_hat <- curErrors %>% 
    as.data.frame() %>% 
    set_rownames(.$Gene) %>% 
    select(grep("^cluster_", colnames(.))) %>% 
    t() %>% 
    .[complete.cases(.),]
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #sort matrices to all follow the same order of genes
  overlapGenes <- Reduce(intersect, list(rownames(scrna), colnames(X), colnames(X_hat)))
  scrna <- scrna[overlapGenes, ]
  X <- X[, overlapGenes]
  X_hat <- X_hat[, overlapGenes]
  
  #break up single-cell expression matrix by cluster and compare to centroids
  clusterDistances <- lapply(sort(unique(Idents(seurat))), function(curCluster){
    #get counts for cells belonging to this cluster
    curCounts <- t(scrna[, Idents(seurat) == curCluster])
    
    #get centroid belonging to this cluster
    curCentroid <- X[curCluster,]
    
    #compute distances between each cell and the corresponding centroid
    curDistances <- apply(curCounts, 1, function(cell){
      return(sqrt(sum((cell - curCentroid)^2)))
    })
    
    #get average distance
    averageDistance <- mean(curDistances, na.rm = TRUE)
    
    #find distance between predicted centroid and real centroid
    centroidDistance <- sqrt(sum((curCentroid - X_hat[curCluster,])^2))
    
    #return table with distances
    toReturn <- data.frame(Type = c("Average cell", "Predicted centroid"),
                           Distance = c(averageDistance, centroidDistance),
                           Number_of_cells = nrow(curCounts),
                           Cluster = curCluster)
  })
  
  #find coefficient of variation for each cluster's proportion across timepoints
  proportions <- A / rowSums(A)
  cvProportions <- apply(proportions, 2, function(curCluster) return(sd(curCluster) / mean(curCluster)))
  clusterDistances <- lapply(seq_along(cvProportions), function(curTable){
    clusterDistances[[curTable]]$Cell_type_proportion_variation <- cvProportions[curTable]
    return(clusterDistances[[curTable]])
  })
  
  #merge results from all clusters into one table
  clusterDistances <- do.call("rbind", clusterDistances)
  
  #add column indicating the number of clusters
  clusterDistances$Number_of_clusters <- paste(clust, "clusters")
  
  return(clusterDistances)
}, cl = 6)

#merge results into one table
centroidDistances <- do.call("rbind", centroidDistances)

#reorder data based on number of clusters
centroidDistances <- centroidDistances %>% mutate(Number_of_clusters = factor(Number_of_clusters, levels = paste(5:15, "clusters")))

#plot bar plot
ggplot(centroidDistances, aes(x = Cluster, y = Distance, fill = Type)) + 
  geom_bar(stat = "identity", position = "dodge", width = .5) +
  facet_wrap( ~ Number_of_clusters, scales = "free") +
  labs(title = "Average Euclidean distance between each cluster's cells and it's centroid compared to the predicted centroid")+
  theme_bw() +
  coord_flip()
```

#### Which clusters are easier to predict?  

The accuracy of recapturing the cell cluster profiles varied by cluster. In this section, we are interested in examining the mathematical properties of the cell clusters derived from the scRNA-Seq data that influence the quality of our predictions. We first compute the correlation between how ’tightly-knit’ a cluster is, i.e. average within-cluster distance to the centroid, and the error in predicting the profiles. We also correlate the prediction error with the number of cells in each cluster and the variation of each cell type's proportion across timepoints. The error in this section is taken as the Euclidean distance between the cluster's predicted centroid and the actual centroid.

```{r correlationOfClusterTightnessToErrorIndividualLambdas, fig.width = 20, fig.height = 8}
#compute correlations from results of the section comparing centroids
centroidErrors <- centroidDistances[centroidDistances$Type == "Predicted centroid", "Distance"]
clusterTightness <- centroidDistances[centroidDistances$Type == "Average cell", "Distance"]
clusterSizes <- centroidDistances[centroidDistances$Type == "Average cell", "Number_of_cells"]
clusterVariations <- centroidDistances[centroidDistances$Type == "Average cell", "Cell_type_proportion_variation"]

forPlot <- data.frame("Distance_between_real_and_predicted_centroid" = centroidErrors,
                      "Average_within_cluster_distance" = clusterTightness,
                      "Number_of_cells" = clusterSizes,
                      "Cell_type_proportion_variation" = clusterVariations)

#plots
p1 <- ggplot(forPlot, aes(x = Average_within_cluster_distance, y = Distance_between_real_and_predicted_centroid)) +
  geom_point() +
  geom_smooth(method = lm) +
  ggpubr::stat_cor(method = "pearson") +
  labs(title = "Relationship between a cluster's tightness and prediction errors", subtitle = "Each point represents a cluster")

p2 <- ggplot(forPlot, aes(x = Number_of_cells, y = Distance_between_real_and_predicted_centroid)) +
  geom_point() +
  geom_smooth(method = lm) +
  ggpubr::stat_cor(method = "pearson") +
  labs(title = "Relationship between a cluster's size and prediction errors", subtitle = "Each point represents a cluster")

p3 <- ggplot(forPlot, aes(x = Cell_type_proportion_variation, y = Distance_between_real_and_predicted_centroid)) +
  geom_point() +
  geom_smooth(method = lm) +
  ggpubr::stat_cor(method = "pearson") +
  labs(title = "Relationship between a cluster's proportion variation across timepoints and prediction errors", subtitle = "Each point represents a cluster")

p1|p2|p3
```
#### Visualizing predictions and real values side-by-side 

The below heatmaps visualize the real scRNA-defined cluster profiles with the predicted ones from deconvoluting the different RNA datasets described below.

1) ***Pseudo-bulk***: A pseudo-bulk RNA dataset is created for each timepoint by summing the gene counts of all cells within the timepoint.
2) ***Reconstructed Pseudo-bulk***: The reconstructed pseudo-bulk is created by matrix multiplication of the average cell cluster expression of each gene and the number of cells in each cluster in each timepoint, i.e. $Y = AX$.
3) ***Bulk mRNA***: Bulk mRNA data from a microarray experiment.

**The $\lambda$ values used for the regression were those deemed to be optimal based on the reconstructed pseudobulk dataset.** We furthermore focus on a set of 80 hallmark genes associated with EMT from the [MSigDB database](https://www.gsea-msigdb.org/gsea/msigdb/cards/HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION.html). 

###### All overlapping genes (scaled across clusters)

```{r heatmapComparison, results = 'hide', fig.width=16}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
#seurat <- createSeurat(scrna)

#determine number of clusters
clust <- "11"

#cluster seurat object
seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)

#create matrix A with proportions of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cell = Idents(seurat)[variable]) %>% 
  group_by(gene, cell) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cell) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#create pseudo-bulk matrix
Y <- t(createPseudoBulk(scrna))

#reconstruct bulk matrix
Y_hat <- A %*% X

#create bulk matrix
bulk <- t(mrna)

#subset table to optimal values for current clustering
optimalLambdas <- geneLambdas %>% 
  #filter(Dataset == "Reconstructed pseudobulk") %>% 
  group_by(Gene) %>% 
  filter(Number_of_clusters == clust) %>% 
  filter(Relative_error == min(Relative_error)) %>% 
  filter(!is.infinite(Relative_error))

#predict single-cell matrix X'
X_hat_Y <- perGeneConstrainedRidgeRegression(bulk = Y, timeProportions = A, optimalLambdas = optimalLambdas)
X_hat_Yhat <- perGeneConstrainedRidgeRegression(bulk = Y_hat, timeProportions = A, optimalLambdas = optimalLambdas)
X_hat_bulk <- perGeneConstrainedRidgeRegression(bulk = bulk, timeProportions = A, optimalLambdas = optimalLambdas)

#keep only the genes present in both datasets
X_hat_Y <- X_hat_Y[,intersect(overlapGenes, optimalLambdas$Gene)]
X_hat_Yhat <- X_hat_Yhat[,intersect(overlapGenes, optimalLambdas$Gene)]
X_hat_bulk <- X_hat_bulk[,intersect(overlapGenes, optimalLambdas$Gene)]
X <- X[,intersect(overlapGenes, optimalLambdas$Gene)]

#scale across clusters
X_hat_Y <- apply(X_hat_Y, 2, scale)
X_hat_Yhat <- apply(X_hat_Yhat, 2, scale)
X_hat_bulk <- apply(X_hat_bulk, 2, scale)
X <- apply(X, 2, scale)

#put into one table
allX <- do.call("rbind", list(X, X_hat_Y, X_hat_Yhat, X_hat_bulk))

#names of matrices
matrixNames <- c("scRNA profiles X (11 clusters)", "X predicted from pseudobulk", "X predicted from re-created pseudobulk", "X predicted from actual bulk")

#create heatmaps
ComplexHeatmap::Heatmap(t(allX),
                        name = "Counts", cluster_columns = FALSE, cluster_rows = TRUE,
                        column_split = rep(matrixNames, each = as.integer(clust)), use_raster = T, 
                        show_row_names = F, show_column_names = F, 
                        row_title = "Genes")
```
\newpage
###### EMT hallmark genes (scaled across clusters)

```{r hallmarkHeatmapsPredictions, fig.width = 16, fig.height = 12}
#read in EMT hallmark genes
hallmark <- read.delim("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/hallmark_emt_geneset.txt", header = F)[,1]

#keep only the genes present in both datasets and the hallmark set
X_hat_Y <- X_hat_Y[,intersect(colnames(X_hat_Y), hallmark)]
X_hat_Yhat <- X_hat_Yhat[,intersect(colnames(X_hat_Yhat), hallmark)]
X_hat_bulk <- X_hat_bulk[,intersect(colnames(X_hat_bulk), hallmark)]
X <- X[,intersect(colnames(X), hallmark)]

#put into one table
allX <- do.call("rbind", list(X, X_hat_Y, X_hat_Yhat, X_hat_bulk))

#create heatmaps
ComplexHeatmap::Heatmap(t(allX),
                        name = "Counts", cluster_columns = FALSE, cluster_rows = TRUE,
                        column_split = rep(matrixNames, each = as.integer(clust)), use_raster = T, 
                        show_row_names = T, show_column_names = F, 
                        row_title = "Genes")

```

# Deconvolution of proteomics data

In this section of the report, we focus on deconvoluting the bulk proteomics data with 11 Seurat-defined clusters. We furthermore focus on a set of 80 hallmark genes associated with EMT from the [MSigDB database](https://www.gsea-msigdb.org/gsea/msigdb/cards/HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION.html). 

#### Seurat clustering results

```{r seurat11clusters, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#create seurat object
#seurat <- createSeurat(scrna)

#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#determine number of seurat clusters
clust <- "11"

#cluster seurat object
seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)

#UMAP dimensionality reduction
seurat <- RunUMAP(seurat, dims = 1:10)

#plot UMAP
DimPlot(seurat, reduction = "umap", label = T) + ggtitle("Seurat-identified cell clusters")

#create matrix A with counts of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#convert cell type counts to proportions
timeProportions <- data.frame(apply(A, 1, function(x) return(x/sum(x))))

#convert to long format for ggplot
timeProportions <- melt(timeProportions)
colnames(timeProportions) <- c('Timepoint', 'Proportion')
timeProportions$Proportion <- round(timeProportions$Proportion, 2)

#add column for cluster name
timeProportions$Cell_Type <- as.factor(rep(0:(length(unique(Idents(seurat)))-1), ncol(mrna)))

#plot
ggplot(timeProportions, aes(x = Timepoint, y = Proportion, fill = Cell_Type,
                            label = ifelse(Proportion > 0.015, paste0(Proportion*100,'%'), "") )) +
  geom_bar(stat = 'identity') + 
  geom_text(size = 2, position = position_stack(vjust = 0.5)) +
  ggtitle("Cell type composition in each timepoint")
```
#### Predicted cell cluster profiles

```{r deconvoluteProteomicsIndividualGeneLambdas, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold', fig.height = 12}
#constrained ridge regression with gene-level lambdas
perGeneConstrainedRidgeRegression <- function(bulk, timeProportions, optimalLambdas){
  #subset bulk to include genes for which optimal lambdas are present
  bulk <- bulk[,colnames(bulk) %in% optimalLambdas$Gene]
  
  #define required matrices/vectors for the quadratic solver
  Dmat <- t(timeProportions) %*% timeProportions
  Amat <- diag(ncol(timeProportions))
  
  #iterate over genes
  sc <- lapply(colnames(bulk), function(gene){
    #find optimal lambda for this gene
    lambda <- as.numeric(unlist(optimalLambdas[optimalLambdas$Gene == gene,"Lambda"]))
    
    #get expression values for this gene
    geneAbundances <- bulk[,gene]
    
    #define required matrices/vectors for the quadratic solver
    dvec <- t(timeProportions) %*% geneAbundances
    
    #add small scaling of the identity matrix to Dmat to regularize prediction
    Dmat <- Dmat + lambda*diag(nrow(Dmat))
    
    #to avoid overflow cause by large values, scale Dmat and dvec
    scalingFactor <- norm(Dmat, "2")
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat / scalingFactor, dvec / scalingFactor, Amat)
    return(qp$solution)
  }) %>% 
    do.call("cbind",.)
  colnames(sc) <- colnames(bulk)
  
  return(sc)
}

#read in all scores for all values of lambda and all genes
geneLambdas <- readRDS("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/geneLambdas.rds")

#subset table to optimal values for current clustering
optimalLambdas <- geneLambdas %>% 
  group_by(Gene) %>% 
  filter(Number_of_clusters == clust) %>% 
  filter(Relative_error == min(Relative_error)) %>% 
  filter(!is.infinite(Relative_error))

#cluster seurat object
seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)

#create matrix A with proportions of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cluster = Idents(seurat)[variable]) %>% 
  group_by(gene, cluster) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cluster) %>% 
  magrittr::set_rownames(.$gene) %>% 
  dplyr::select(-1) %>% 
  as.matrix() %>% 
  t()

#bulk proteomics matrix
bulk_proteomics <- t(proteome)

#reconstruct pseudo-bulk matrix
Y <- A %*% X

#list of genes detected in each dataset
allGenes <- list("scRNA-Seq" = rownames(scrna), "Proteomics" = rownames(proteome), "Bulk mRNA" = rownames(mrna))

#list of overlapping genes
overlapGenes <- Reduce(intersect, allGenes)

#retain overlapping genes only in the datasets
X <- X[,overlapGenes]
Y <- Y[,overlapGenes]
bulk_proteomics <- bulk_proteomics[,overlapGenes]

#re-scale proteomics data to be comparable to RNA
bulk_proteomics <- bulk_proteomics / (sum(bulk_proteomics) / sum(Y))

#predict single-cell profiles using constrained ridge regression
prediction <- perGeneConstrainedRidgeRegression(bulk = bulk_proteomics, timeProportions = A, optimalLambdas = optimalLambdas)

#remove zero variance genes
prediction <- prediction[,unlist(apply(prediction, 2, var)) > 0]

#add cluster labels
rownames(prediction) <- paste0("cluster_", 0:(length(unique(Idents(seurat)))-1))

#rename clusters based on classification
rownames(prediction) <- c(paste0(rownames(prediction)[1:3],"_M"), paste0(rownames(prediction)[4:7],"_E"),
                          "cluster_7_M", "cluster_8_E", "cluster_9_M", "cluster_10_E")

#reorder prediction to go E -> M
prediction <- prediction[c(grep("E", rownames(prediction), value = TRUE), grep("M", rownames(prediction), value = TRUE)) , ]

#hallmark genes to keep
#read in EMT hallmark genes
hallmark <- read.delim("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/hallmark_emt_geneset.txt", header = F)[,1]
hallmarkOverlap <- intersect(overlapGenes, hallmark)
prediction_hallmark <- prediction[,intersect(colnames(prediction), hallmarkOverlap)]

#save locally
#write.csv(t(prediction), "/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/sc_predictions_11_clusters.csv")
#write.csv(t(prediction_hallmark), "/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/sc_hallmark_predictions_11_clusters.csv")


#subset of known epithelial/mesenchymal markers
E <- c("SDC1", "RHOB", "GPC1", "SDC4")
M <- c("VIM", "FN1", "PLOD1", "FLNA")

#visualize
pheatmap(t(prediction), scale = "row", show_rownames = F, cluster_cols = F, main = "Single-cell proteomics prediction - Seurat 11 clusters - all genes")
pheatmap(t(prediction_hallmark), scale = "row", show_rownames = T, cluster_cols = F, main = "Single-cell proteomics prediction - Seurat 11 clusters - EMT hallmark genes", cluster_rows = T)
```

