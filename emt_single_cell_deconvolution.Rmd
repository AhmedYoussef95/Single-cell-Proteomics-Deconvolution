---
title: "EMT Multi-Omics"
subtitle: "Deconvolution of proteomics data using scRNA-Seq"
author: "Ahmed Youssef"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: pdf_document
urlcolor: blue
toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

#required packages
library(data.table) #reading in large files quickly
library(kableExtra) #for tables
library(dplyr) #data wrangling
library(magrittr) #data wrangling
library(reshape2) #data wrangling
library(tidyr) #data wrangling
library(tibble) #data wrangling
library(ggplot2) #plots
library(patchwork) #plot figures plots on same plot
library(ComplexHeatmap) #heatmaps
library(celda) #scRNA clustering
library(Seurat) #scRNA clustering
library(ggvenn) #venn diagram
library(uwot) #UMAP
library(pracma) #distance between matrices
library(Matrix) #matrix operations
library(quadprog) #solving constrained OLS problem
library(glmnet) #ridge regression
library(pbapply) # parallel operations
library(ggpubr) #correlation plots annotation
```

# Introduction

The fundamental unit of all living organisms is the cell, and recent technological advances have granted us unprecedented opportunities to study life at this principal level. Proteins, through their networks of interactions, carry out most of the vital biological processes governing cellular functions, yet remain largely unexplored in the single-cell space, representing crucial gaps in our knowledge of cell biology. While single-cell proteomics methods are still in their infancy, single-cell RNA sequencing (scRNA-Seq) has emerged in recent years as a powerful technology for defining cell states on a large scale, enabling breakthroughs in many areas of cell biology research, and begging the question of whether it can be used for making inferences at the protein level. **In this report, I explore the deconvolution of bulk proteomics data to the single-cell level using scRNA-Seq data.**

# Experiment summary

Epithelial-to-mesenchymal transition (EMT) is a biological process in which epithelial cells gradually lose their adhesion and transition into mesenchymal cells. As one of the hallmarks of cancer progression, it is one of the long-standing interests of the biomedical research community. Towards profiling this process, protein and RNA samples were extracted from cells at 8 different timepoints during EMT and multiple layers of omics data were generated. These omics layers include proteomics, transcriptomics, phosphoproteomics, secretome, exosome among others. A pre-print with more details on the experiment and generated data can be found on bioRxiv [here (Paul et al, 2021)](https://www.biorxiv.org/node/2018285.external-links.html). This report is interested in the scRNA-Seq, microarray, and proteomics datasets generated in this study.

# Approach

Bulk proteomics data gives a view of the aggregated protein abundance from all cell types within a sequenced sample. Using single-cell data, derived from the same samples, we can investigate the sample heterogeneity by estimating proportions of cell types within the bulk sample. We cannot reliably use these proportions to directly estimate the contribution of each population to each gene/protein's expression at the bulk-level however, since there is low correlation between RNA and protein levels of the same genes due to multiple biological factors, such as alternative splicing and post-translational modifications. Leveraging the timepoints present in this dataset, which conveniently show shifts in cell type abundances across time, we can instead look for changes in cell-type proportions and corresponding changes in bulk-level protein abundance as suggestive of relationships between specific cell types and specific proteins. This information can then potentially be used to estimate the contribution of individual cell types to the bulk proteomics measurements.

# Data summary - Proteomics

The bulk proteomics data was generated in the Emili Lab using standard mass-spectrometry. Summary of the dataset follows:

-   6,967 proteins
-   10 different timepoints
-   Three replicates

The average intensity across replicates was computed for each protein in each timepoint. Timepoints 3 and 9 were removed since they are not present in the scRNA data. 

```{r readProteome, fig.height = 3}
#read in '2D' proteomics data and average replicates in each timepoint
proteome <- fread("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/proteinGroups_Prot.txt") %>% 
  as.data.frame() %>% 
  .[, c("Gene names", grep("Reporter intensity corrected .* [A-C]", colnames(.), value = TRUE))] %>% 
  magrittr::set_names(c("Gene", gsub("Reporter intensity corrected ", "T", colnames(.)[-1]))) %>% 
  melt() %>% 
  #average replicates
  mutate(variable = gsub(" .*","", variable)) %>% 
  group_by(Gene, variable) %>% 
  summarize(intensity = mean(value)) %>% 
  #convert to wide format
  dcast(Gene ~ variable) %>% 
  magrittr::set_rownames(.$Gene) %>% 
  #remove timepoints that are not present in scRNA data
  select(-c(1, 5, 11)) %>%
  as.matrix()

#normalize data such that each timepoint sums to 1
#proteome <- apply(proteome, 2, function(x) return(x/sum(x)))

#scale original matrix row-wise
scaledProts <- t(apply(proteome, 1, scale)) %>% .[complete.cases(.),]

#visualize heatmap
ComplexHeatmap::Heatmap(scaledProts,
                        name = "Intensity (scaled row-wise)", cluster_columns = FALSE, 
                        column_split = colnames(proteome), 
                        show_row_names = F, show_column_names = F, 
                        use_raster = T, row_title = "Proteins")
```

# Data summary - scRNA-Seq

The bulk proteomics data was generated in the Emili Lab using standard mass-spectrometry. Summary of the dataset follows:

-   9,785 genes
-   1,913 cells (\~200 cells per timepoint)
-   8 different timepoints

Prior to this summation, genes with zero variance as well as those with non-zero counts in less than 5% of all cells were removed. This removed 17 genes (0.2% of all genes). The data was also normalized such that each cell sums to 1.

```{r readSCRNA}
#read in data
scrna <- data.frame(fread("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/scRNAseq_filt_dat.txt", stringsAsFactors = FALSE)) %>% 
  magrittr::set_rownames(.$Gene.names) %>% 
  select(-1)

#compute variance of genes
geneVar <- apply(scrna, 1, var) %>% 
  .[. > 0]

#remove genes with zero variance
scrna <- scrna[names(geneVar),]

#get percentage of cells each gene is expressed in
cellsPerGene <- apply(scrna, 1, function(x) sum(x > 0) / length(x)) %>% 
  .[. >= 0.05]

#remove genes expressed in less than 5% of all cells
scrna <- scrna[names(cellsPerGene),]

#filter out lowly-expressed genes (threshold is at least 3 counts in 3 cells - removed 1,240 genes)
scrna <- scrna[rowSums(scrna > 3) > 3,]

#get number of cells in each timepoint
cellsPerTimepoint <- table(gsub(".*_","", colnames(scrna)))

#display table with no. of cells per timepoint
kable(t(cellsPerTimepoint), caption = "Number of cells in each timepoint") %>%
  kable_styling(latex_options = c("striped", "hold_position")) %>% 
  row_spec(row = 0, bold = T, color = "white", background = "gray")

#group scRNA data by cell and normalize to sum to 1
scrna <- scrna %>% 
  as.data.frame() %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  group_by(variable) %>% 
  mutate(value = value / sum(value)) %>%
  dcast(gene ~ variable) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.data.frame()
```

# Data summary - Bulk mRNA

The bulk mRNA data comes from a microarray experiment. Summary of the dataset follows:

-   23,743 genes
-   10 different timepoints
-   Three replicates

The average intensity across replicates was computed for each protein in each timepoint. Timepoints 3 and 9 were removed since they are not present in the scRNA data.

```{r bulkRNA, results='hide'}
#read in data
mrna <- read.delim("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/emt_mRNA.txt", stringsAsFactors = F) %>% 
  melt() %>% 
  ##average replicates
  mutate(variable = gsub("RIC.","T", variable), Gene.names = gsub("_mRNA", "", .$Gene.names)) %>% 
  group_by(Gene.names, variable) %>% 
  summarize(counts = mean(value)) %>% 
  #remove log-transformation
  mutate(counts = (2^counts)-1) %>% 
  ##convert to wide format
  dcast(Gene.names ~ variable) %>% 
  magrittr::set_rownames(.$Gene.names) %>% 
  #remove inconsistent timepoints
  select(-c(1, 5, 11)) %>%
  as.matrix()

#normalize data such that each timepoint sums to 1
#mrna <- apply(mrna, 2, function(x) return(x/sum(x)))
```

# Protein overlap

The venn diagram below shows the overlap of the identified proteins in the datasets.

```{r proteinOverlap, fig.width = 5, fig.height = 4}
#list of genes detected in each dataset
allGenes <- list("scRNA-Seq" = rownames(scrna), "Proteomics" = rownames(proteome), "Bulk mRNA" = rownames(mrna))

#list of overlapping genes
overlapGenes <- Reduce(intersect, allGenes)

#retain overlapping genes only in the datasets
#scrna <- scrna[overlapGenes,]
#proteome <- proteome[overlapGenes,]
#mrna <- mrna[overlapGenes,]

#venn diagram
ggvenn::ggvenn(data = allGenes, 
               columns = c("scRNA-Seq", "Proteomics", "Bulk mRNA"))
```

# Pseudo-bulk RNA vs bulk RNA

A pseudo-bulk RNA dataset is created for each timepoint by summing the gene counts of all cells within the timepoint. This pseudo-bulk data is then compared to the actual microarray bulk mRNA data present for each timepoint. The cross-timepoint measurements for each genes were also correlated. The distributions of these correlations are showed below.

```{r createPseudoBulk}
#create list of timepoints
timepoints <- colnames(mrna)

#create single-cell pseudo bulk data
pseudoBulk <- list()
for(t in timepoints){
  #get single-cell rna-seq in this timepoint
  curSC <- scrna[, grep(pattern = t, colnames(scrna))]
  
  #create pseudo-bulk by summing values
  curPseudo <- rowSums(curSC)
  curPseudo[is.na(curPseudo)] <- 0
  
  #log-transform and quantile normalize
  #curPseudo <- log2(curPseudo+1)
  #curPseudo <- preprocessCore::normalize.quantiles(as.matrix(curPseudo))
  
  #add current timepoint pseudo-bulk to list 
  pseudoBulk[[t]] <- curPseudo
  rm(curPseudo, curSC)
}
pseudoBulk <- data.frame(pseudoBulk)
rownames(pseudoBulk) <- rownames(scrna)
```

```{r pseudoBulkVsBulk, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold', results='hide'}
cors <- c()
#for each timepoint
for(t in timepoints){
  #get rna-seq in this timepoint
  curSC <- pseudoBulk[intersect(rownames(pseudoBulk), rownames(mrna)), grep(pattern = t, colnames(pseudoBulk))]
  curBulk <- mrna[intersect(rownames(pseudoBulk), rownames(mrna)), grep(pattern = t, colnames(mrna))]
  
  #add current timepoint correlation to list of correlations
  cors <- c(cors, cor(curSC, curBulk))
}

#create bar plot of correlations
cors <- data.frame(Timepoint=timepoints, Pearson_R2=cors)
ggplot(cors, aes(x=Timepoint, y=Pearson_R2)) +
  geom_bar(stat = "identity") +
  scale_y_continuous(limits = c(0,1)) +
  labs(title = "Correlation between pseudo-bulk RNA-Seq data and bulk microarray data",
       subtitle="Pseudo-bulk created by summing expression across all cells")

#correlate across timepoints for each gene
cors <- unlist(lapply(intersect(rownames(pseudoBulk), rownames(mrna)), function(g)
  return(cor(unlist(pseudoBulk[g,]), unlist(mrna[g,])))))

hist(cors, breaks = 100, main = "Correlation of pseudo-bulk and bulk RNA across genes", ylab = "Genes", xlab = "Pearson R2")
```

# Method Development and Optimization

To investigate the ability to recover the scRNA data from the pseudo-bulk data, we start by clustering the scRNA data to identify the cell clusters followed by creating the following matrices:

-   Matrix $A$ of dimensions $timepoints X clusters$. (cell type proportions)
-   Matrix $X$ of dimensions $clusters X genes$. (cluster-averaged single-cell RNA data)
-   Matrix $Y$ of dimensions $timepoints X genes$. (pseudo-bulk RNA data)

We then attempt to re-create the single-cell matrix $X$ data by computing $Y = AX'$.

![](/Users/Ahmed/Documents/Emili_Lab/Aim%203/EMT%20Multi-omics/Plots/bulk%20decnovolution%20outline.png)

## Identify cell clusters

The cell states in our dataset are identified in an unsupervised manner based on similarity of gene expression profiles. All cells from all timepoints are pooled together for this analysis.

For data pre-processing, we remove the genes with low expression counts, retaining genes with a minimum of 3 counts in at least 3 cells. This removed 1,240 genes (13% of all genes). On average, each cell expressed \~3,600 genes after processing. [Seurat](https://www.nature.com/articles/nbt.4096) is then used to cluster the cells based on the 2,000 most variable genes.

The initial model defines 7 cell clusters at a Seurat resolution of 0.4. We intentionally begin with a number of clusters less than the number of timepoints to avoid creating an undetermined problem. The below UMAP plot visualizes the identified cell clusters.

```{r seuratExampleClustering, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold', results='hide'}
#Cluster with Seurat
# Initialize the Seurat object with the raw (non-normalized data).
seurat <- CreateSeuratObject(counts = scrna, project = "EMT")

#normalize data
seurat <- NormalizeData(seurat)

#find most variable genes
seurat <- FindVariableFeatures(seurat, selection.method = "vst", nfeatures = 2000)

#scale data
all.genes <- rownames(seurat)
seurat <- ScaleData(seurat, features = all.genes)

#PCA
seurat <- RunPCA(seurat, features = VariableFeatures(object = seurat))

#construct KNN using 10 PCs
seurat <- FindNeighbors(seurat, dims = 1:10)

#cluster cells
seurat <- FindClusters(seurat, resolution = 0.4, random.seed = 123)

#UMAP dimensionality reduction
seurat <- RunUMAP(seurat, dims = 1:10)

#plot UMAP
DimPlot(seurat, reduction = "umap", label = T) + ggtitle("Identified cell clusters")
```

## Changes in cell state composition over time

Since this dataset is investigating cells undergoing EMT, the cell population abundances are changing over time. The below figures visualize these proportion changes.

Note: this approach assumes the single-cell data accurately captures the sample heterogeneity. In practice, biased cell sampling upstream could lead to an inaccurate view of sample heterogeneity here.

```{r cellTypeProportions, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
## get proportion of each cell type at each timepoint ##

#create list of timepoints
timepoints <- colnames(mrna)

#create vector which contains the timepoint each cell comes from
cellTimepoints <- as.factor(gsub(pattern = '.*_', replacement = "", colnames(scrna)))

#initialize empty list
timeProportions <- list()

#iterate over timepoints 
for(t in timepoints){
  #get cells from this timepoint
  curTimepoint <- Idents(seurat)[which(cellTimepoints == t)]
  
  #list which will contain abundance for each population
  pops <- c()
  
  #iterate over clusters
  for(i in unique(Idents(seurat))){
    #no. of cells in this timepoint and also this cluster
    curMembers <- length(which(curTimepoint == i))
    
    #proportion
    pops <- c(pops, curMembers / length(curTimepoint))
  }
  
  #add to final list
  timeProportions[t] <- list(pops)
}

## stacked bar chart
#convert to dataframe for ggplot
forPlot <- data.frame(timeProportions)

#convert to long format for ggplot
forPlot <- melt(forPlot)
colnames(forPlot) <- c('Timepoint', 'Proportion')
forPlot$Proportion <- round(forPlot$Proportion, 2)

#add column for cluster name
forPlot$Cell_Type <- as.factor(rep(0:(length(unique(Idents(seurat)))-1), length(timepoints)))

#plot
ggplot(forPlot, aes(x = Timepoint, y = Proportion, fill = Cell_Type,
                    label = ifelse(Proportion > 0.015, paste0(Proportion*100,'%'), "") )) +
  geom_bar(stat = 'identity') + 
  geom_text(size = 2, position = position_stack(vjust = 0.5)) +
  ggtitle("Cell type composition in each timepoint")

#line chart
ggplot(forPlot, aes(x = as.numeric(Timepoint), y = Proportion, col = Cell_Type)) +
  geom_line() +
  scale_x_continuous(labels = timepoints, breaks = 1:8) +
  ggtitle("Cell type proportions across timepoints") +
  labs(x = 'Timepoint')
```

## Re-construct pseudo-bulk data from single-cell data

We now attempt to re-create the pseudo-bulk data ($Y$) from the single-cell data using the simple formula $Yâ€™ = AX$. The matrix $X$ was constructed by averaging the gene expression of each cluster. The matrix $A$ contains the number of cells from each cell cluster in each timepoint.

The below heatmaps show the pseudo-bulk data and the re-constructed data side-by-side, with the 8,528 genes in the same order. The heatmaps are scaled by row for visualization purposes. This reconstructed bulk data is then compared to the pseudo-bulk data in each timepoint. Correlations were also computed across the cross-timepoint measurements for each gene. The distributions of these correlations are shown below.

```{r keyFunctions}
#function to create pseudobulk from scRNA-Seq data
createPseudoBulk <- function(scrna){
  #create list of timepoints
  timepoints <- unique(gsub(pattern = ".*_", replacement = "", colnames(seurat)))
  
  #create single-cell pseudo bulk data
  pseudoBulk <- list()
  for(t in timepoints){
    #get single-cell rna-seq in this timepoint
    curSC <- scrna[, grep(pattern = t, colnames(scrna))]
    
    #create pseudo-bulk by summing values
    curPseudo <- rowSums(curSC)
    curPseudo[is.na(curPseudo)] <- 0
    
    #log-transform and quantile normalize
    #curPseudo <- log2(curPseudo+1)
    #curPseudo <- preprocessCore::normalize.quantiles(as.matrix(curPseudo))
    
    #add current timepoint pseudo-bulk to list 
    pseudoBulk[[t]] <- curPseudo
    rm(curPseudo, curSC)
  }
  pseudoBulk <- data.frame(pseudoBulk)
  rownames(pseudoBulk) <- rownames(scrna)
  return(as.matrix(pseudoBulk))
}

#create seurat object for downstream clustering
createSeurat <- function(counts){
  # Initialize the Seurat object with the raw (non-normalized data).
  seurat <- CreateSeuratObject(counts = counts, project = "EMT")
  
  #normalize data
  seurat <- NormalizeData(seurat)
  
  #scale data
  all.genes <- rownames(seurat)
  seurat <- ScaleData(seurat, features = all.genes)
  
  #find most variable genes
  seurat <- FindVariableFeatures(seurat, selection.method = "vst", nfeatures = 2000)
  
  #PCA on most variable genes
  seurat <- RunPCA(seurat, features = VariableFeatures(object = seurat))
  
  #construct KNN using 10 PCs
  seurat <- FindNeighbors(seurat, dims = 1:10)
  
  return(seurat)
}

#function to compute cell-type proportions 'A' given seurat-clustered data
computeCellProportions <- function(seurat){
  #construct matrix with number of cells from each type in each timepoint
  A <- as.data.frame(seurat@assays$RNA@counts) %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cluster = Idents(seurat)[variable], timepoint = gsub(".*_","", variable)) %>% 
    group_by(cluster, timepoint) %>% 
    summarize(count = length(unique(variable))) %>% 
    tidyr::spread(key = cluster, value = count, fill = 0) %>% 
    tibble::column_to_rownames("timepoint")
  
  #convert to matrix format
  A <- as.matrix(A)
  
  return(A)
}

#function to recover X from Y' by using X = pseudo-inverse of A * Y'
computeSCprofiles <- function(bulk, timeProportions){
  
  #predict scRNA matrix based on bulk and time proportions matrix
  #X_hat <- solve(t(A) %*% A) %*% (t(A) %*% Y_hat)
  sc <- pracma::pinv(timeProportions) %*% bulk
  
  return(sc)
}
```

```{r reconstructBulkRNA, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#construct matrix with cell-type proportions in each timepoint
#A <- t(data.frame(timeProportions))

#construct matrix with number of cells from each type in each timepoint
A <- do.call("rbind",(lapply(timepoints, function(t){
  #get cells from this timepoint
  curTimepoint <- as.character(Idents(seurat)[which(cellTimepoints == t)])
  
  #list which will contain number of cells for each population
  pops <- c()
  
  #iterate over clusters
  for(cluster in unique(Idents(seurat))){
    #no. of cells in this timepoint and also this cluster
    pops <- c(pops,length(which(curTimepoint == cluster)))
  }
  
  return(pops)
})))
rownames(A) <- timepoints

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cell = Idents(seurat)[variable]) %>% 
  group_by(gene, cell) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cell) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#reconstruct bulk matrix
Y_hat <- A %*% X

#construct pseudo-bulk RNA matrix
Y <- t(pseudoBulk)

#keep only the genes present in both datasets
overlapGenes <- intersect(colnames(Y), colnames(Y_hat))
Y <- Y[,overlapGenes]
Y_hat <- Y_hat[,overlapGenes]
X <- X[,overlapGenes]

#scale original matrices gene-wise
scaledY <- t(apply(Y, 2, scale))
scaledY_hat <- t(apply(Y_hat, 2, scale))
colnames(scaledY) <- colnames(scaledY_hat) <- timepoints

#visualize heatmap
ComplexHeatmap::Heatmap(scaledY, name = "Z-score",
                        cluster_columns = FALSE, cluster_rows = FALSE,
                        show_row_names = F, show_column_names = T, 
                        use_raster = T, row_title = "Genes",
                        column_title = "Original pseudo-bulk data")

ComplexHeatmap::Heatmap(scaledY_hat, name = "Z-score",
                        cluster_columns = FALSE, cluster_rows = FALSE,
                        show_row_names = F, show_column_names = T, 
                        use_raster = T, row_title = "Genes",
                        column_title = "Reconstructed bulk data")
```

```{r compareYtoYhat, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold', results='hide'}
cors <- c()
#for each timepoint
for(t in timepoints){
  #get rna-seq in this timepoint
  curSC <- Y_hat[t, intersect(colnames(Y_hat), colnames(Y))]
  curBulk <- Y[t, intersect(colnames(Y_hat), colnames(Y))]
  
  #add current timepoint correlation to list of correlations
  cors <- c(cors, cor(curSC, curBulk))
}

#create bar plot of correlations
cors <- data.frame(Timepoint=timepoints, Pearson_R2=cors)
ggplot(cors, aes(x=Timepoint, y=Pearson_R2)) +
  geom_bar(stat = "identity") +
  scale_y_continuous(limits = c(0,1)) +
  labs(title = "Correlation between reconstructed bulk RNA data and pseudo-bulk data",
       subtitle="Pseudo-bulk created by summing expression across all cells")

#correlation of genes
cors <- unlist(lapply(overlapGenes, function(g)
  return(cor(Y[,g], Y_hat[,g]))))

hist(cors, breaks = 100, main = "Correlation of reconstructed bulk RNA and pseudo-bulk RNA across genes", ylab = "Genes", xlab = "Pearson R2")
```

```{r bulkSimilarityToPseudo, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
#seurat <- createSeurat(scrna)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
bulkRMSE <- pblapply(clusters, function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #reconstruct bulk matrix
  Y_hat <- A %*% X
  
  #create pseudo-bulk matrix
  Y <- t(createPseudoBulk(scrna))
  
  #make Y and Y' follow the same order
  Y <- Y[,order(colnames(Y))]
  Y_hat <- Y_hat[,order(colnames(Y_hat))]
  
  #find relative error between Y and Y'
  relativeError <- apply(abs(Y - Y_hat) / Y, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

plot(x = 5:15, y = unlist(bulkRMSE), type = 'b',
     main = "Relative error between Y and Y' for different no. of clusters",
     ylab = "Relative error", xlab = "Number of clusters")
```

## Re-construct single-cell data from pseudo-bulk data

In this section, we attempt to re-create the single-cell data from the pseudo-bulk data and the timepoint-specific cell cluster counts. Based on the formula $Y = AX$ outlined in previous sections, given the pseudobulk matrix Y and the timepoint-specific cell counts 'mixing' matrix A, we aim to compute X using the formula $X' = (A^TA)^{-1}(A^TY)$, which is essentially the pseudo-inverse of A multiplied by the pseudo-bulk Y. Recall that the pseudo-bulk is computed by summing up the counts of individual cells in each timepoint.

We vary the number of cell clusters by varying the *resolution* parameter in Seurat's clustering algorithm. We try this method for a number of clusters ranging between 5-15. For each given number of clusters, we solve the formula above to predict $X'$. We then compare this to the actual observed $X$ from the scRNA-Seq data, which is the per-cluster average of gene counts. The errors are reported as relative RMAD (relative mean absolute deviation) using the formula $|X - X'| / X$, where $|X|$ is the absolute value of the difference. This error is computed for each gene and the final reported score is the average RMAD value, in other words: *on average, how different is a gene's predicted values compared to the true ones?*

This process above is repeated once using $Y'$ as the bulk data, where $Y' = AX$ is computed first prior to computing $X'$ as above, and once using the actual bulk data in this dataset. The resultant cluster-RMAD relationships are shown in the below plot.

```{r predictSingleCellProfilesFromPseudoBulk, message=FALSE, results='hide', eval=F}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
seurat <- createSeurat(scrna)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors <- pblapply(clusters, function(clust){
  #create pseudo-bulk matrix
  Y <- t(createPseudoBulk(scrna))
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cluster = Idents(seurat)[variable]) %>% 
    group_by(gene, cluster) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cluster) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors2 <- pblapply(clusters, function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #reconstruct bulk matrix
  Y_hat <- A %*% X
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y_hat, timeProportions = A)
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors3 <- pblapply(clusters, function(clust){
  #create bulk matrix
  Y <- t(mrna)
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #keep only the genes present in both datasets
  overlapGenes <- intersect(colnames(X), colnames(X_hat))
  X_hat <- X_hat[,overlapGenes]
  X <- X[,overlapGenes]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

#show all RMSEs on one plot
allErrors <- do.call("rbind", list(unlist(errors), unlist(errors2), unlist(errors3) ))
rownames(allErrors) <- c("Pseudo-bulk Y", "Pseudo-bulk Y'", "Actual bulk")
saveRDS(allErrors, "/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/relative_RMAD_OLS.rds")
```

```{r  plotSCpredictionsRMSE, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
allErrors <- readRDS("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/relative_RMAD_OLS.rds")
matplot(t(allErrors), type = c("b"), pch = 1, col = 1:3,
        main = "Predicting single-cell profiles from bulk using OLS", xlab = "Number of clusters", ylab = "Relative error", x = 5:15)
legend("topleft", legend = rownames(allErrors), col=1:3, pch=1) # optional legend
```

```{r visualizeXhatHeatmaps, results = 'hide', fig.width=16}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
#seurat <- createSeurat(scrna)

clust <- clusters["8"]
#cluster seurat object
seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)

#get number of clusters
nClust <- length(unique(Idents(seurat)))

#create matrix A with proportions of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cell = Idents(seurat)[variable]) %>% 
  group_by(gene, cell) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cell) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#create pseudo-bulk matrix
Y <- t(createPseudoBulk(scrna))

#reconstruct bulk matrix
Y_hat <- A %*% X

#create bulk matrix
bulk <- t(mrna)

#predict single-cell matrix X'
X_hat_Y <- computeSCprofiles(bulk = Y, timeProportions = A)
X_hat_Yhat <- computeSCprofiles(bulk = Y_hat, timeProportions = A)
X_hat_bulk <- computeSCprofiles(bulk = bulk, timeProportions = A)

#keep only the genes present in both datasets
overlapGenes <- intersect(colnames(X), colnames(X_hat_bulk))
X_hat_Y <- X_hat_Y[,overlapGenes]
X_hat_Yhat <- X_hat_Yhat[,overlapGenes]
X_hat_bulk <- X_hat_bulk[,overlapGenes]
X <- X[,overlapGenes]

#put into one table
allX <- do.call("rbind", list(X, X_hat_Y, X_hat_Yhat, X_hat_bulk))

#names of matrices
matrixNames <- c("X (8 clusters)", "X predicted from pseudobulk Y", "X predicted from re-created pseudobulk Y'", "X predicted from actual bulk")

#create heatmaps
ComplexHeatmap::Heatmap(t(allX),
                        name = "Counts", cluster_columns = FALSE, cluster_rows = T,
                        column_split = rep(matrixNames, each = nClust), use_raster = T, 
                        show_row_names = F, show_column_names = F, 
                        row_title = "Genes")
```

## Variation of gene expression within cell type across timepoints

```{r geneVarWithinCluster, fig.width = 12, fig.height = 8, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
#seurat <- createSeurat(scrna)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
geneCV <- pblapply(clusters, function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #find pairings where a cluster is not present in a timepoint
  pairings <- which(A==0, arr.ind = T) %>% 
    as.data.frame() %>% 
    mutate(row = rownames(A)[.$row], col = colnames(A)[.$col], key = paste(row, col, sep = "-")) %>% 
    .$key
  
  #compute coefficient of variation of genes in each cluster
  geneCV <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cluster = Idents(seurat)[variable], timepoint = gsub(".*_","", variable), key = paste(timepoint, cluster, sep = "-")) %>%
    filter(! key %in% pairings) %>% 
    group_by(cluster, gene, timepoint) %>% 
    summarise(counts = mean(value)) %>% 
    group_by(cluster, gene) %>% 
    summarise(cv = sd(counts) / mean(counts))
  
  return(mean(geneCV$cv, na.rm = TRUE))
}, cl = 6)


plot(x = 5:15, y = unlist(geneCV), type = 'b',
     main = "For a given cluster, how does its average expression of a gene change across timepoints?",
     ylab = "Average Coef. of Variation", xlab = "Number of clusters")
```

## Constraining the solution to be non-negative

The [Tsoucas et al](https://www.nature.com/articles/s41467-019-10802-z) publication proposed a strategy for RNA deconvolution based on the OLS formulation we used in this report, with the addition of constraining the solution to be non-negative since there are no possible negative gene counts, and increasing the weight of cell types with low average expression levels. Since we typically have more cell types than time points, our problem is underdetermined and as such there are multiple possible solutions. In this section, we follow their strategy for constraining the solution to be non-negative.

We solve $\hat{X} = min_{x >= 0}||AX-Y||^2$ which algebraically is the same as solving $\hat{X} = min_{x >= 0}(-2Y^T A X + X^T A^T A X)$. The R function [*solve.QP*](https://www.rdocumentation.org/packages/quadprog/versions/1.5-8/topics/solve.QP) from the [*quadprog*](https://cran.r-project.org/web/packages/quadprog/quadprog.pdf) package is used to solve this equation one gene at a time to estimate the expression profile at the cell-type level. This algorithm, however, expects a positive definite matrix. The matrix $A^TA$ is positive definite when $A$ has more rows than columns, i.e. when the problem is a least-squares problem. When we have more clusters than timepoints then $A$ has more columns than rows, and so the matrix is not invertible, and by extension not positive definite. As a workaround, we use the function [*nearPD*](https://www.rdocumentation.org/packages/Matrix/versions/1.3-4/topics/nearPD) to find the nearest positive matrix instead.

```{r solveQP, results='hide', eval = FALSE}
#function to solve QP problem given A and Y using nearest positive-definite matrix
computeSCprofiles <- function(bulk, timeProportions){
  
  #iterate over genes
  sc <- apply(bulk, 2, function(gene){
    #define required matrices/vectors for the quadratic solver
    Dmat <- t(timeProportions) %*% timeProportions
    dvec <- t(timeProportions) %*% gene
    Amat <- diag(ncol(timeProportions))
    
    #find nearest positive-definite matrix for D to be able to solve OLS problem
    Dmat <- as.matrix(Matrix::nearPD(Dmat)$mat)
    
    #add small scaling of the identitiy matrix to Dmat to make it positive definite
    #diag(Dmat) <- diag(Dmat)+1e-8
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat, dvec, Amat)
    return(qp$solution)
  })
  
  return(sc)
}

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors <- pblapply(clusters, function(clust){
  #create pseudo-bulk matrix
  Y <- t(createPseudoBulk(scrna))
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors2 <- pblapply(clusters, function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #reconstruct bulk matrix
  Y_hat <- A %*% X
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y_hat, timeProportions = A)
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

errors3 <- pblapply(clusters, function(clust){
  #create bulk matrix
  Y <- t(mrna)
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #keep only the genes present in both datasets
  overlapGenes <- intersect(colnames(X), colnames(X_hat))
  X_hat <- X_hat[,overlapGenes]
  X <- X[,overlapGenes]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

#combine results into one matrix
allErrors <- do.call("rbind", list(errors, errors2, errors3))
rownames(allErrors) <- c("Pseudo-bulk Y", "Pseudo-bulk Y'", "Actual bulk")
saveRDS(allErrors, "/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/relative_RMAD_constrained_OLS_nearPD.rds")
```

```{r plotQPresults, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
allErrors <- readRDS("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/relative_RMAD_constrained_OLS_nearPD.rds")
matplot(t(allErrors), type = c("b"), pch = 1, col = 1:3, xlab = "Number of clusters", ylab = "Relative RMSE",
        main = "Solving constrained OLS using nearest positive-definite matrix", x = 5:15)
legend("topleft", legend = rownames(allErrors), col=1:3, pch=1)
```

```{r visualizeXhatHeatmapsConstrainedOLSusingNearPD, results = 'hide', fig.width=16}
#function to solve QP problem given A and Y
computeSCprofiles <- function(bulk, timeProportions){
  
  #iterate over genes
  sc <- apply(bulk, 2, function(gene){
    #define required matrices/vectors for the quadratic solver
    Dmat <- t(timeProportions) %*% timeProportions
    dvec <- t(timeProportions) %*% gene
    Amat <- diag(ncol(timeProportions))
    
    #find nearest positive-definite matrix for D to be able to solve OLS problem
    Dmat <- as.matrix(Matrix::nearPD(Dmat)$mat)
    
    #add small scaling of the identitiy matrix to Dmat to make it positive definite
    #diag(Dmat) <- diag(Dmat)+1e-8
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat, dvec, Amat)
    return(qp$solution)
  })
  
  return(sc)
}

#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
#seurat <- createSeurat(scrna)

clust <- clusters["9"]
#cluster seurat object
seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)

#get number of clusters
nClust <- length(unique(Idents(seurat)))

#create matrix A with proportions of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cell = Idents(seurat)[variable]) %>% 
  group_by(gene, cell) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cell) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#create pseudo-bulk matrix
Y <- t(createPseudoBulk(scrna))

#reconstruct bulk matrix
Y_hat <- A %*% X

#create bulk matrix
bulk <- t(mrna)

#predict single-cell matrix X'
X_hat_Y <- computeSCprofiles(bulk = Y, timeProportions = A)
X_hat_Yhat <- computeSCprofiles(bulk = Y_hat, timeProportions = A)
X_hat_bulk <- computeSCprofiles(bulk = bulk, timeProportions = A)

#keep only the genes present in both datasets
overlapGenes <- intersect(colnames(X), colnames(X_hat_bulk))
X_hat_Y <- X_hat_Y[,overlapGenes]
X_hat_Yhat <- X_hat_Yhat[,overlapGenes]
X_hat_bulk <- X_hat_bulk[,overlapGenes]
X <- X[,overlapGenes]

#put into one table
allX <- do.call("rbind", list(X, X_hat_Y, X_hat_Yhat, X_hat_bulk))

#names of matrices
matrixNames <- c("X (9 clusters)", "X predicted from pseudobulk Y", "X predicted from re-created pseudobulk Y'", "X predicted from actual bulk")

#create heatmaps
ComplexHeatmap::Heatmap(t(allX),
                        name = "Counts", cluster_columns = FALSE, cluster_rows = FALSE,
                        column_split = rep(matrixNames, each = nClust), use_raster = T, 
                        show_row_names = F, show_column_names = F, 
                        row_title = "Genes")

```

As an alternative to the *nearPD* function, we add a small scaling of the identity matrix ($10^{-9}$) to $A^T A$, which will make it positive definite and as such allow *solve.QP* to work. The result is shown below.

```{r solveQPSmallScalingOfIdentityMatrix, results='hide', eval = FALSE}
#function to predict single-cell profiles by adding small scaling of identity matrix
computeSCprofiles <- function(bulk, timeProportions){
  
  #iterate over genes
  sc <- apply(bulk, 2, function(gene){
    #define required matrices/vectors for the quadratic solver
    Dmat <- t(timeProportions) %*% timeProportions
    dvec <- t(timeProportions) %*% gene
    Amat <- diag(ncol(timeProportions))
    
    #find nearest positive-definite matrix for D to be able to solve OLS problem
    #Dmat <- as.matrix(Matrix::nearPD(Dmat)$mat)
    
    #add small scaling of the identitiy matrix to Dmat to make it positive definite
    diag(Dmat) <- diag(Dmat) + 1e-8
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat, dvec, Amat)
    return(qp$solution)
  })
  
  return(sc)
}

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors <- pblapply(clusters, function(clust){
  #create pseudo-bulk matrix
  Y <- t(createPseudoBulk(scrna))
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors2 <- pblapply(clusters, function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #reconstruct bulk matrix
  Y_hat <- A %*% X
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y_hat, timeProportions = A)
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

errors3 <- pblapply(clusters, function(clust){
  #create bulk matrix
  Y <- t(mrna)
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #keep only the genes present in both datasets
  overlapGenes <- intersect(colnames(X), colnames(X_hat))
  X_hat <- X_hat[,overlapGenes]
  X <- X[,overlapGenes]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

#combine results into one matrix
allErrors <- do.call("rbind", list(errors, errors2, errors3))
rownames(allErrors) <- c("Pseudo-bulk Y", "Pseudo-bulk Y'", "Actual bulk")
saveRDS(allErrors, "/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/relative_RMAD_constrained_OLS.rds")
```

```{r plotQPresultsWithScalingIdentityMatrix, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
allErrors <- readRDS("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/relative_RMAD_constrained_OLS.rds")
matplot(t(allErrors), type = c("b"), pch = 1, col = 1:3, xlab = "Number of clusters", ylab = "Relative error",
        main = "Solving constrained OLS by adding small scaling of identity matrix", x = 5:15)
legend("topleft", legend = rownames(allErrors), col=1:3, pch=1)
```

```{r visualizeXhatHeatmapsQP2, results = 'hide', fig.width=16}
#non-negative OLS by adding small scaling of identity matrix
computeSCprofiles <- function(bulk, timeProportions){
  
  #iterate over genes
  sc <- apply(bulk, 2, function(gene){
    #define required matrices/vectors for the quadratic solver
    Dmat <- t(timeProportions) %*% timeProportions
    dvec <- t(timeProportions) %*% gene
    Amat <- diag(ncol(timeProportions))
    
    #find nearest positive-definite matrix for D to be able to solve OLS problem
    #Dmat <- as.matrix(Matrix::nearPD(Dmat)$mat)
    
    #add small scaling of the identitiy matrix to Dmat to make it positive definite
    diag(Dmat) <- diag(Dmat)+1e-8
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat, dvec, Amat)
    return(qp$solution)
  })
  
  return(sc)
}

#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
#seurat <- createSeurat(scrna)

clust <- clusters["9"]
#cluster seurat object
seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)

#get number of clusters
nClust <- length(unique(Idents(seurat)))

#create matrix A with proportions of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cell = Idents(seurat)[variable]) %>% 
  group_by(gene, cell) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cell) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#create pseudo-bulk matrix
Y <- t(createPseudoBulk(scrna))

#reconstruct bulk matrix
Y_hat <- A %*% X

#create bulk matrix
bulk <- t(mrna)

#predict single-cell matrix X'
X_hat_Y <- computeSCprofiles(bulk = Y, timeProportions = A)
X_hat_Yhat <- computeSCprofiles(bulk = Y_hat, timeProportions = A)
X_hat_bulk <- computeSCprofiles(bulk = bulk, timeProportions = A)

#keep only the genes present in both datasets
overlapGenes <- intersect(colnames(X), colnames(X_hat_bulk))
X_hat_Y <- X_hat_Y[,overlapGenes]
X_hat_Yhat <- X_hat_Yhat[,overlapGenes]
X_hat_bulk <- X_hat_bulk[,overlapGenes]
X <- X[,overlapGenes]

#put into one table
allX <- do.call("rbind", list(X, X_hat_Y, X_hat_Yhat, X_hat_bulk))

#names of matrices
matrixNames <- c("X (9 clusters)", "X predicted from pseudobulk Y", "X predicted from re-created pseudobulk Y'", "X predicted from actual bulk")

#create heatmaps
ComplexHeatmap::Heatmap(t(allX),
                        name = "Counts", cluster_columns = FALSE, cluster_rows = FALSE,
                        column_split = rep(matrixNames, each = nClust), use_raster = T, 
                        show_row_names = F, show_column_names = F, 
                        row_title = "Genes")

```

## Predicting single-cell profiles using ridge regression

The condition number of $A^TA$ for the case where we have 8 single-cell clusters, i.e. as many clusters as there are timepoints, is noticeably high (15,828) compared to a smaller number of clusters which suggests that it is a near-singular matrix. This would explain the relatively high error in estimating the single-cell profiles. In an attempt to address this, we use ridge regression to estimate the single-cell profiles instead.

Ridge regression is similar to linear regression but with the addition of a regularization term $\lambda$. A range of values for $\lambda$ are tested to decide on the optimal one. The R package [*glmnet*](https://cran.r-project.org/web/packages/glmnet/glmnet.pdf) is used for this task. We solve the problem by fitting a ridge regression model to each gene. The full procedure is outlined below:

[**Input:**]{.ul} Number of clusters *N*, Single-cell expression matrix *SC*

[**Procedure:**]{.ul}

1.  Cluster single-cell matrix *SC into N* clusters using *Seurat*

2.  Construct cluster \* gene matrix ***X*** by computing the average expression of each gene in each cluster

3.  Construct timepoint \* cluster mixing matrix ***A*** by counting the number of cells in each cluster in each timepoint

4.  Construct timepoint \* gene pseudobulk matrix ***Y*** using the formula $Y = AX$

5.  Define $LambdaSet = \{10^{-8}, 10^{-7}, 10^{-6}, 10^{-5}, 10^{-4}, 10^{-3}, 10^{-2}, 10^{-1}, 10^{0}, 10^{1} \}$

6.  For each column of *Y,* denoted as *y* :

7.  Fit ridge regression model *Beta* using the function `Beta = glmnet(x = A, y = y, lambda = LambdaSet, alpha = 0)`

8.  For each column in *X*, denoted as *x* :

-   For each lambda *L* :

1.  Compute *x'* = column *L* of *Beta*

2.  Compute error in predicting *x* as $||x - x'||^2$

3.  Accumulate error for each lambda as the sum of errors across genes

4.  Select lambda with minimum accumulated error

```{r ridgeRegression, fig.width = 12, fig.height = 8, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
#seurat <- createSeurat(scrna)

#set of lambdas to test for ridge regression (should be in decreasing order)
lambdaSet <- sort(10^(-10:0), decreasing = TRUE)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors <- pblapply(clusters, function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #iterate over genes (columns of Y) and fit regression model based on counts of clusters in each timepoint
  ridge <- apply(Y, 2, function(y){
    #fit ridge regression model
    Beta <- glmnet(x = A, y = y,  lambda = lambdaSet, alpha = 0)$beta
    
    #set column names to indicate lambda values
    colnames(Beta) <- lambdaSet
    
    #return estimated x'
    return(Beta)
  })
  
  #summarize predictions for each lambda into separate tables
  X_hat <- lapply(seq_along(lambdaSet), function(lambda){
    return(do.call("cbind", lapply(ridge, `[`, , lambda)))
  })
  names(X_hat) <- lambdaSet
  
  #compute relative error between X and X' for each lambda
  error <- lapply(X_hat, function(cur_X_hat){
    #find relative error between Y and Y'
    relativeError <- apply(abs(X - cur_X_hat) / X, 2, mean) %>% 
      .[!is.infinite(.) & !is.na(.)] %>% 
      mean(.)
    
    return(relativeError)
  })
  
  #convert error values to matrix (one column per lambda)
  error <- do.call("cbind", error)
  
  return(error)
}, cl = 6)

#combine all the errors into one table
errors <- do.call("rbind", errors)
rownames(errors) <- names(clusters)

#convert to long format for plotting
errors <- reshape2::melt(errors)
colnames(errors) <- c("Number of clusters", "Lambda", "Relative error")
errors$`Number of clusters` <- as.factor(errors$`Number of clusters`)

#plot
ggplot(errors, aes(x = log(Lambda), y = `Relative error`, col = `Number of clusters`)) +
  geom_line() + geom_point() +
  scale_x_continuous("log(Lambda)", labels = paste0("log(", as.character(errors$Lambda), ")"), breaks = log(errors$Lambda)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  labs(title = "Error of estimating single-cell profiles using ridge regression across values of lambda",
       subtitle = "Each color represents a pre-determined number of cell clusters")
```

For each number of clusters, we select the lambda which led to the minimal sum squared error when comparing the predicted single-cell profiles to the actual ones. Those selected lambdas are shown below.

```{r ridgeRegressionBestLambdas}
#for each number of clusters, find optimal lambda
bestLambdas <- errors %>% 
  group_by(`Number of clusters`) %>%
  summarise(`Best lambda` = lambdaSet[which(`Relative error` == min(`Relative error`))]) %>% 
  mutate(`Best lambda` = as.character(signif(`Best lambda`, 3)))

#show table with best lambda values
kable(bestLambdas, caption = "Ridge regression - Lambda values that minimize error") %>%
  kable_styling(latex_options = c("striped", "hold_position")) %>% 
  row_spec(row = 0, bold = T, color = "white", background = "gray")
```

\newpage

#### Comparing ridge regression to OLS

The below plots show a comparison of using ridge regression and non-negative constrained OLS for predicting the single-cell profiles from the bulk data and the timepoint-specific proportions.

```{r compareRidgeRegressionToOLS, fig.width = 14, fig.height = 8, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#predict X' using optimal lambda values for ridge regression
X_hat_ridge <- pblapply(names(clusters), function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #optimal lambda
  lambda <- as.numeric(unlist(bestLambdas[as.character(bestLambdas$`Number of clusters`) == clust, "Best lambda"]))
  
  #iterate over genes (columns of Y) and fit regression model based on counts of clusters in each timepoint
  ridge <- apply(Y, 2, function(y){
    #fit ridge regression model
    Beta <- glmnet(x = A, y = y,  lambda = lambda, alpha = 0)$beta
    
    #return estimated x'
    return(Beta)
  })
  
  #combine predictions of all genes into one matrix
  X_hat <- do.call("cbind", ridge)
  colnames(X_hat) <- names(ridge)
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
  
}, cl = 6)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
X_hat_ols <- pblapply(clusters, function(clust){
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
  
}, cl = 6)

#combine all the errors into one table
errors <- do.call("cbind", list(do.call("rbind", X_hat_ridge), do.call("rbind", X_hat_ols)))
rownames(errors) <- names(clusters)
colnames(errors) <- c("Ridge regression", "OLS")

#convert to long format for plotting
errors <- reshape2::melt(errors)
colnames(errors) <- c("Number_of_clusters", "Method", "Relative error")

#plot
ggplot(errors, aes(x = Number_of_clusters, y = `Relative error`, col = Method)) +
  geom_line() + geom_point() +
  scale_x_continuous(breaks = 5:15) +
  labs(title = "Relative error of estimating single-cell profiles for different numbers of clusters")
```

```{r visualizeXhatHeatmapsForRidgeAndOLS, results = 'hide', fig.width=16}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
#seurat <- createSeurat(scrna)

#scenario with 10 clusters
clust <- clusters["10"]

#cluster seurat object
seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)

#get number of clusters
nClust <- length(unique(Idents(seurat)))

#create matrix A with proportions of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cell = Idents(seurat)[variable]) %>% 
  group_by(gene, cell) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cell) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#reconstruct bulk matrix
Y_hat <- A %*% X

#predict single-cell matrix X' using OLS
X_hat_ols <- computeSCprofiles(bulk = Y_hat, timeProportions = A)

#optimal lambda
lambda <- unlist(bestLambdas[as.character(bestLambdas$`Number of clusters`) == names(clust), "Best lambda"])

#iterate over genes (columns of Y) and fit regression model based on counts of clusters in each timepoint
ridge <- pbapply(Y, 2, function(y){
  #fit ridge regression model
  Beta <- glmnet(x = A, y = y,  lambda = lambda, alpha = 0)$beta
  
  #return estimated x'
  return(Beta)
}, cl = 6)

#combine predictions of all genes into one matrix
X_hat_ridge <- do.call("cbind", ridge)
colnames(X_hat_ridge) <- names(ridge)

#keep only the genes present in all datasets
overlapGenes <- intersect(colnames(X), colnames(X_hat_ols))
X_hat_ols <- X_hat_ols[,overlapGenes]
X_hat_ridge <- X_hat_ridge[,overlapGenes]
X <- X[,overlapGenes]

#put into one table
allX <- as.matrix(do.call("rbind", list(X, X_hat_ols, X_hat_ridge)))

#names of matrices
matrixNames <- c("X (10 clusters)", "X predicted using OLS", "X predicted using Ridge Regression")

#create heatmaps
ComplexHeatmap::Heatmap(t(allX),
                        name = "Counts", cluster_columns = FALSE, cluster_rows = T,
                        column_split = rep(matrixNames, each = nClust), use_raster = T, 
                        show_row_names = F, show_column_names = F, 
                        row_title = "Genes")

```

## Ridge regression with non-negative constraint

The results above do not show an improvement in the single-cell predictions when using ridge regression. In this section, we explore the addition of a non-negative constraint to the ridge regression model, similar to how we applied it for OLS earlier in this report. To achieve this, we solve the equation $\hat{X} = min_{x >= 0}(-2Y^T A X + X^T A^T A X)$ after adding a ridge penalty $\lambda$ to the diagonal of the matrix $A^TA$. The R function [*solve.QP*](https://www.rdocumentation.org/packages/quadprog/versions/1.5-8/topics/solve.QP) from the [*quadprog*](https://cran.r-project.org/web/packages/quadprog/quadprog.pdf) package is used to solve this equation one gene at a time to estimate the expression profile at the cell-type level. To decide on the optimal value for the parameter $\lambda$, we test a range of values between $10^{-10}$ and $1$ for each number of clusters. For each value of $\lambda$, we sum the errors in estimating each gene's single-cell profile as a measure of the accuracy of the predicted single-cell profiles. The $\lambda$ that leads to the minimal error is selected as the optimal value.

```{r nonNegativeRidgeRegression, fig.width = 12, fig.height = 8, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#combine ridge regression with a non-negative constraint
constrainedRidgeRegression <- function(bulk, timeProportions, lambda){
  #define required matrices/vectors for the quadratic solver
  Dmat <- t(timeProportions) %*% timeProportions
  Amat <- diag(ncol(timeProportions))
  
  #add small scaling of the identity matrix to Dmat to regularize prediction
  Dmat <- Dmat + lambda*diag(nrow(Dmat))
  
  #to avoid overflow cause by large values, scale Dmat and dvec
  scalingFactor <- norm(Dmat, "2")
  
  #iterate over genes
  sc <- apply(bulk, 2, function(gene){
    #define required matrices/vectors for the quadratic solver
    dvec <- t(timeProportions) %*% gene
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat / scalingFactor, dvec / scalingFactor, Amat)
    return(qp$solution)
  })
  
  return(sc)
}

#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#set of lambdas to test for ridge regression (should be in decreasing order)
lambdaSet <- sort(10^(-10:0), decreasing = TRUE)

#create seurat object
#seurat <- createSeurat(scrna)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors <- pblapply(clusters, function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #predict single-cell profiles using constrained ridge regression for each value of lambda
  X_hat <- lapply(lambdaSet, function(lambda){
    return(constrainedRidgeRegression(bulk = Y, timeProportions = A, lambda = lambda))
  })
  names(X_hat) <- lambdaSet
  
  #compute relative error between X and X' for each lambda
  error <- lapply(X_hat, function(cur_X_hat){
    #find relative error between Y and Y'
    relativeError <- apply(abs(X - cur_X_hat) / X, 2, mean) %>% 
      .[!is.infinite(.) & !is.na(.)] %>% 
      mean(.)
    
    return(relativeError)
  })
  
  #convert error values to matrix (one column per lambda)
  error <- do.call("cbind", error)
  
  return(error)
}, cl = 6)

#combine all the errors into one table
errors <- do.call("rbind", errors)
rownames(errors) <- names(clusters)

#convert to long format for plotting
errors <- reshape2::melt(errors)
colnames(errors) <- c("Number of clusters", "Lambda", "Relative error")
errors$`Number of clusters` <- as.factor(errors$`Number of clusters`)

#plot
ggplot(errors, aes(x = log(Lambda), y = `Relative error`, col = `Number of clusters`)) +
  geom_line() + geom_point() +
  scale_x_continuous("log(Lambda)", labels = paste0("log(", as.character(errors$Lambda), ")"), breaks = log(errors$Lambda)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  labs(title = "Error of estimating single-cell profiles using constrained ridge regression across values of lambda",
       subtitle = "Each color represents a pre-determined number of cell clusters")
```

For each number of clusters, we select the lambda which led to the minimal sum squared error when comparing the predicted single-cell profiles to the actual ones. Those selected lambdas are shown below.

```{r constrainedRidgeRegressionBestLambdas}
#for each number of clusters, find optimal lambda
bestLambdas <- errors %>% 
  group_by(`Number of clusters`) %>%
  summarise(`Best lambda` = lambdaSet[which(`Relative error` == min(`Relative error`))]) %>% 
  mutate(`Best lambda` = as.character(signif(`Best lambda`, 3)))

#show table with best lambda values
kable(bestLambdas, caption = "Constrained ridge regression - Lambda values that minimize error") %>%
  kable_styling(latex_options = c("striped", "hold_position")) %>% 
  row_spec(row = 0, bold = T, color = "white", background = "gray")
```

After selecting the optimal $\lambda$ for each number of clusters, we compare the results of using non-negative constrained ridge regression and OLS on predicting the single-cell profiles. The errors are reported as relative RMAD (relative mean absolute deviation) using the formula $|X - X'| / X$, where $|X|$ is the absolute value of the difference. This error is computed for each gene and the final reported score is the average RMAD value, in other words: *on average, how different is a gene's predicted values compared to the true ones?* The resultant relative RMAD values for each of the methods are shown below, along with an example predicted matrix.

```{r compareConstrainedRidgeRegressionToOLS, fig.width = 14, fig.height = 8, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#predict X' using optimal lambda values for constrained ridge regression
X_hat_ridge <- pblapply(names(clusters), function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #optimal lambda
  lambda <- as.numeric(unlist(bestLambdas[as.character(bestLambdas$`Number of clusters`) == clust, "Best lambda"]))
  
  #predict single-cell profiles using constrained ridge regression for each value of lambda
  X_hat <- constrainedRidgeRegression(bulk = Y, timeProportions = A, lambda = lambda)
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
X_hat_ols <- pblapply(clusters, function(clust){
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

#combine all the errors into one table
errors <- do.call("cbind", list(do.call("rbind", X_hat_ridge), do.call("rbind", X_hat_ols)))
rownames(errors) <- names(clusters)
colnames(errors) <- c("Ridge regression", "OLS")

#convert to long format for plotting
errors <- reshape2::melt(errors)
colnames(errors) <- c("Number_of_clusters", "Method", "Relative error")

#plot
ggplot(errors, aes(x = Number_of_clusters, y = `Relative error`, col = Method)) +
  geom_line() + geom_point() +
  scale_x_continuous(breaks = 5:15) +
  labs(title = "Relative error of estimating single-cell profiles for different numbers of clusters",
       subtitle = "Non-negative constraint applied to both methods")
```

```{r visualizeXhatHeatmapsForConstrainedRidgeAndOLS, results = 'hide', fig.width=16}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
#seurat <- createSeurat(scrna)

#scenario with 10 clusters
clust <- clusters["10"]

#cluster seurat object
seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)

#get number of clusters
nClust <- length(unique(Idents(seurat)))

#create matrix A with proportions of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cell = Idents(seurat)[variable]) %>% 
  group_by(gene, cell) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cell) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#reconstruct bulk matrix
Y_hat <- A %*% X

#predict single-cell matrix X' using OLS
X_hat_ols <- computeSCprofiles(bulk = Y_hat, timeProportions = A)

#optimal lambda
lambda <- as.numeric(unlist(bestLambdas[as.character(bestLambdas$`Number of clusters`) == names(clust), "Best lambda"]))

#predict single-cell matrix X' using ridge regression
X_hat_ridge <- constrainedRidgeRegression(bulk = Y_hat, timeProportions = A, lambda = lambda)

#keep only the genes present in all datasets
overlapGenes <- intersect(colnames(X), colnames(X_hat_ols))
X_hat_ols <- X_hat_ols[,overlapGenes]
X_hat_ridge <- X_hat_ridge[,overlapGenes]
X <- X[,overlapGenes]

#put into one table
allX <- as.matrix(do.call("rbind", list(X, X_hat_ols, X_hat_ridge)))

#names of matrices
matrixNames <- c("X (10 clusters)", "X predicted using OLS", "X predicted using Ridge Regression")

#create heatmaps
ComplexHeatmap::Heatmap(t(allX),
                        name = "Counts", cluster_columns = FALSE, cluster_rows = T,
                        column_split = rep(matrixNames, each = nClust), use_raster = T, 
                        show_row_names = F, show_column_names = F, 
                        row_title = "Genes")

```

### How does the optimal regression parameter vary for different categories of genes?

We group the genes according to how variable their expression is across clusters and compute and compare the optimal regression parameter for each of the groups. The expression variability is computed as the coefficient of variation (standard deviation / mean) of the gene's expression across clusters.

```{r computeLambdaForDifferentGenes, eval = FALSE}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#set of lambdas to test for ridge regression (should be in decreasing order)
lambdaSet <- sort(10^(-10:10), decreasing = TRUE)

#create seurat object
#seurat <- createSeurat(scrna)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors <- pblapply(names(clusters), function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #compute coefficient of variation of genes across clusters
  geneCV <- apply(X, 2, function(x) return(sd(x) / mean(x)))
  
  #group genes into 3 groups according to variance across clusters
  geneCV <- split(sort(geneCV), sort(1:length(geneCV) %% 3))
  names(geneCV) <- c("Low variation", "Medium variation", "High variation")
  
  #create table with each gene's variation classification
  geneVarClass <- do.call("rbind", lapply(names(geneCV), function(x) return(data.frame(Gene = names(geneCV[[x]]), Cross_cluster_variation = x))))
  
  #construct matrix with all combinations of lambda and gene name and gene variation
  parameters <- merge(geneVarClass, data.frame(Lambda = lambdaSet, Number_of_clusters = clust), by = NULL)
  
  #define required matrices/vectors for the quadratic solver
  Dmat <- t(A) %*% A
  Amat <- diag(ncol(A))
  
  #predict single-cell profiles using constrained ridge regression for each value of lambda
  X_hat <- apply(parameters, 1, function(curParameters){
    #extract current parameters
    lambda <- as.numeric(curParameters[["Lambda"]])
    curGene <- Y[, curParameters[["Gene"]]]
    
    ##predict single-cell profiles
    
    #add small scaling of the identity matrix to Dmat to regularize prediction
    Dmat <- Dmat + lambda*diag(nrow(Dmat))
    
    #to avoid overflow cause by large values, scale Dmat and dvec
    scalingFactor <- norm(Dmat, "2")
    
    #define required matrices/vectors for the quadratic solver
    dvec <- t(A) %*% curGene
    
    #solve quadratic equation
    prediction <- quadprog::solve.QP(Dmat / scalingFactor, dvec / scalingFactor, Amat)$solution
    
    #compute relative error between prediction and real values
    curParameters$Relative_error <- mean(abs(X[, curParameters[["Gene"]]] - prediction) / X[, curParameters[["Gene"]]])
    
    return(as.data.frame(curParameters))
  }) %>% 
    do.call("rbind", .)
  
  return(X_hat)
}, cl = 6) %>% 
  do.call("rbind", .)

errors$Lambda <- as.numeric(errors$Lambda)
saveRDS(errors, "/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/geneLambdas.rds")
```

```{r lambdaForDifferentGenes, fig.width = 16, fig.height = 16}
#read in all scores for all values of lambda and all genes
geneLambdas <- readRDS("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/geneLambdas.rds")

#keep optimal lambda for each gene
geneLambdas <- geneLambdas %>% 
  group_by(Gene, Number_of_clusters) %>% 
  filter(Relative_error == min(Relative_error)) %>% 
  mutate(Number_of_clusters = paste(Number_of_clusters, "clusters"), Lambda = as.numeric(Lambda))

#plot
ggplot(geneLambdas) +
  geom_boxplot(aes(x = Cross_cluster_variation, y = log(Lambda), fill = Cross_cluster_variation)) +
  #scale_y_continuous(limits = quantile(log(geneLambdas$Lambda), c(0.1,0.9))) +
  #scale_y_continuous("log(Lambda)", labels = paste0("log(", as.character(geneLambdas$Lambda), ")"), breaks = log(geneLambdas$Lambda)) +
  facet_wrap( ~ Number_of_clusters) + 
  ggtitle("How does the optimal regression parameter vary for different categories of genes?")

```


## Distribution of errors across genes

This section explores whether a ***partial prediction*** might be more feasible, that is whether the single-cell predictions might be more accurate for a subset of the genes, such as differential markers, by comparing the distributions of prediction errors for individual genes as they relate to cell-type expression specificity.

To explore the relationship between properties of the genes and their corresponding predicted values, for each gene we compute the following measures:

-   ***Expression specificity:*** This metric looks at the relative specificity of a given gene's expression to the clusters. The coefficient of variation of the gene's cluster-specific expression values is computed as the standard deviation of the per-cluster expression values divided by the mean.

-   ***Average expression:*** This metric is concerned with the relative abundance of each gene's transcript, and is simply computed as the mean expression of the gene across clusters.

Each of the above measures are then compared to the error in predicting the gene's expression value using regression.

```{r partialPredictions, fig.width = 16, fig.height = 16}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#for each no. of clusters, predict X' and find corresponding scores
predictions <- pblapply(names(clusters), function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #optimal lambda
  lambda <- as.numeric(unlist(bestLambdas[as.character(bestLambdas$`Number of clusters`) == clust, "Best lambda"]))
  
  #predict single-cell profiles using constrained ridge regression for each value of lambda
  X_hat <- constrainedRidgeRegression(bulk = Y, timeProportions = A, lambda = lambda)
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #compute error between X and X' for each gene
  error <- apply((abs(X - X_hat) / X), 2, mean)
  
  #compute each gene's coeff. of variation across cell types
  cv <- apply(X, 2, function(gene){
    return(sd(gene) / mean(gene))
  })
  
  #compute each gene's average expression value
  average_expression <- colMeans(X)
  
  #construct table with all values of interest to return
  toReturn <- data.frame(Gene = colnames(X),
                         Number_of_clusters = as.numeric(clust),
                         Error = error,
                         Coef_variation = cv,
                         Av_expression = average_expression)
  return(toReturn)
  
}, cl = 6)
names(predictions) <- names(clusters)

#convert list into data frame
predictions <- do.call("rbind", predictions)

#remove 'infinite' entries (dividing by zero)
predictions <- predictions[!is.infinite(predictions$Error),] %>% 
  .[complete.cases(.),]

#correlation plots of errors for each number of clusters
CV_plot <- ggplot(predictions, aes(x = Coef_variation, y = Error)) +
  geom_point() +
  geom_smooth(method = lm) +
  facet_wrap(~ Number_of_clusters, scales = "free") +
  ggpubr::stat_cor(method = "pearson") +
  labs(title = "Relationship between a gene's cluster specificity and prediction errors",
       subtitle = "Each box represents a pre-defined number of clusters")

expression_plot <- ggplot(predictions, aes(x = Av_expression, y = Error)) +
  geom_point() +
  geom_smooth(method = lm) +
  facet_wrap(~ Number_of_clusters, scales = "free") +
  ggpubr::stat_cor(method = "pearson") +
  labs(title = "Relationship between a gene's average expression and prediction errors",
       subtitle = "Each box represents a pre-defined number of clusters")

CV_plot / expression_plot
```

## Evaluation of single-cell predictions

The below sections examine the accuracy of the single-cell predictions made using ridge regression in the previous section. Note: the bulk matrix that is deconvoluted in this section is the reconstructed pseudo-bulk matrix ($Y=AX$).

#### Are our predicted cluster centroids close to the real ones?

The cluster centroid is each cluster's average gene expression profile. Visualizing the two sets of centroids (real & predicted) side-by-side on a *UMAP* will help us answer this question. For each number of clusters between 5 and 15, we cluster the data using *Seurat* and construct the matrix $X$ which contains the average gene expression by cluster. We then use the ridge regression approach defined in the previous section to construct the matrix $X'$. Finally, we perform a *UMAP* projection using the R package [uwot](https://github.com/jlmelville/uwot) on the original gene expression matrix but with the addition of the real and predicted cluster centroids, i.e. the rows of $X$ and $X'$. The *UMAP*s below show the projections for each number of clusters.

```{r UMAPpredictedVsRealCentroids, eval = FALSE}
#for each no. of clusters, construct UMAP
umapList <- pblapply(names(clusters), function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #optimal lambda
  lambda <- as.numeric(unlist(bestLambdas[as.character(bestLambdas$`Number of clusters`) == clust, "Best lambda"]))
  
  #predict single-cell profiles using constrained ridge regression for each value of lambda
  X_hat <- constrainedRidgeRegression(bulk = Y, timeProportions = A, lambda = lambda)
  
  #sort matrices to all follow the same order of genes
  overlapGenes <- Reduce(intersect, list(rownames(scrna), colnames(X), colnames(X_hat)))
  scrna <- scrna[overlapGenes, ]
  X <- X[, overlapGenes]
  X_hat <- X_hat[, overlapGenes]
  
  #concatenate centroids to single-cell expression matrix
  mergedSC <- rbind(t(scrna), X, X_hat)
  
  #UMAP
  set.seed(123)
  umap <- as.data.frame(uwot::umap(mergedSC))
  
  #add label indicating whether point is a centroid
  umap$centroid <- c(rep("cell", ncol(scrna)), rep("real centroid", nrow(X)), rep("predicted centroid", nrow(X_hat)))
  
  #add label indicating the no. of cluster for this UMAP
  umap$number_of_clusters <- paste(clust, "clusters")
  
  #add label indicating cell cluster
  umap$cluster <- c(rep(NA, ncol(scrna)), rep(1:nrow(X), 2))
  
  return(umap)
}, cl = 6)

#merge all results into one table
mergedUmap <- do.call("rbind", umapList)

#save locally
saveRDS(mergedUmap, "/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/UMAP_list_sc_predictions.rds")
```

```{r UMAPcomparisonOfPredcitions, fig.width = 16, fig.height = 16}
#read in pre-computed UMAP projections
mergedUmap <- readRDS("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/UMAP_list_sc_predictions.rds")

#plot
ggplot(mergedUmap, aes(x = V1, y = V2, col = centroid)) +
  geom_point() +
  geom_label(label = mergedUmap$cluster) + 
  facet_wrap( ~ number_of_clusters) + 
  scale_color_manual(values = c("grey", "red", "blue"), name = "Key") +
  theme_classic2() +
  ggtitle("UMAP visualization of the predicted cell cluster centroids relative to the predicted ones")
```

#### How similar is the average cell to it's real centroid compared to the predicted one?

To determine if our predictions are reasonable approximations of the real data, we also compare the predictions to the real data by computing the Euclidean distance between individual cells' measurements and their real cluster average as opposed to the distance between our predictions and the same cluster average.

More specifically, for a given number of clusters, we cluster the data using *Seurat*, followed by iterating over each of the \~1,900 cells in the original single-cell expression matrix and computing the Euclidean distance between it's profile and that of its cluster's centroid. Next, for each cluster we compute the average distance of it's cells to the centroid, as well as the distance between our predicted centroid and the corresponding cluster centroid. By comparing these two distances side-by-side, we can determine whether our predicted centroids fall within the correct intra-cluster range.

```{r distancesBetweenCellsAndCentroids, , fig.width = 16, fig.height = 16}
#for each no. of clusters, predict X' and find average distance between cells and their centroids
centroidDistances <- pblapply(names(clusters), function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #optimal lambda
  lambda <- as.numeric(unlist(bestLambdas[as.character(bestLambdas$`Number of clusters`) == clust, "Best lambda"]))
  
  #predict single-cell profiles using constrained ridge regression
  X_hat <- constrainedRidgeRegression(bulk = Y, timeProportions = A, lambda = lambda)
  
  #sort matrices to all follow the same order of genes
  overlapGenes <- Reduce(intersect, list(rownames(scrna), colnames(X), colnames(X_hat)))
  scrna <- scrna[overlapGenes, ]
  X <- X[, overlapGenes]
  X_hat <- X_hat[, overlapGenes]
  
  #break up single-cell expression matrix by cluster and compare to centroids
  clusterDistances <- lapply(sort(unique(Idents(seurat))), function(curCluster){
    #get counts for cells belonging to this cluster
    curCounts <- t(scrna[, Idents(seurat) == curCluster])
    
    #get centroid belonging to this cluster
    curCentroid <- X[curCluster,]
    
    #compute distances between each cell and the corresponding centroid
    curDistances <- apply(curCounts, 1, function(cell){
      return(sqrt(sum((cell - curCentroid)^2)))
    })
    
    #get average distance
    averageDistance <- mean(curDistances, na.rm = TRUE)
    
    #find distance between predicted centroid and real centroid
    centroidDistance <- sqrt(sum((curCentroid - X_hat[curCluster,])^2))
    
    #return table with distances
    toReturn <- data.frame(Type = c("Average cell", "Predicted centroid"),
                           Distance = c(averageDistance, centroidDistance),
                           Number_of_cells = nrow(curCounts),
                           Cluster = curCluster)
  })
  
  #find coefficient of variation for each cluster's proportion across timepoints
  proportions <- A / rowSums(A)
  cvProportions <- apply(proportions, 2, function(curCluster) return(sd(curCluster) / mean(curCluster)))
  clusterDistances <- lapply(seq_along(cvProportions), function(curTable){
    clusterDistances[[curTable]]$Cell_type_proportion_variation <- cvProportions[curTable]
    return(clusterDistances[[curTable]])
  })
  
  #merge results from all clusters into one table
  clusterDistances <- do.call("rbind", clusterDistances)
  
  #add column indicating the number of clusters
  clusterDistances$Number_of_clusters <- paste(clust, "clusters")
  
  return(clusterDistances)
}, cl = 6)

#merge results into one table
centroidDistances <- do.call("rbind", centroidDistances)

#plot bar plot
ggplot(centroidDistances, aes(x = Cluster, y = Distance, fill = Type)) + 
  geom_bar(stat = "identity", position = "dodge", width = .5) +
  facet_wrap( ~ Number_of_clusters, scales = "free") +
  labs(title = "Average Euclidean distance between each cluster's cells and it's centroid compared to the predicted centroid")+
  theme_bw() +
  coord_flip()
```

#### Which clusters are easier to predict?

The accuracy of recapturing the cell cluster profiles varied by cluster. In this section, we are interested in examining the mathematical properties of the cell clusters derived from the scRNA-Seq data that influence the quality of our predictions. We first compute the correlation between how 'tightly-knit' a cluster is, i.e. average within-cluster distance to the centroid, and the error in predicting the profiles. We also correlate the prediction error with the number of cells in each cluster and the variation of each cell type's proportion across timepoints. The error in this section is taken as the Euclidean distance between the cluster's predicted centroid and the actual centroid.

```{r correlationOfClusterTightnessToError, fig.width = 20, fig.height = 8}
#compute correlations from results of the section comparing centroids
centroidErrors <- centroidDistances[centroidDistances$Type == "Predicted centroid", "Distance"]
clusterTightness <- centroidDistances[centroidDistances$Type == "Average cell", "Distance"]
clusterSizes <- centroidDistances[centroidDistances$Type == "Average cell", "Number_of_cells"]
clusterVariations <- centroidDistances[centroidDistances$Type == "Average cell", "Cell_type_proportion_variation"]
numberClusters <- centroidDistances[centroidDistances$Type == "Average cell", "Number_of_clusters"]

forPlot <- data.frame("Distance_between_real_and_predicted_centroid" = centroidErrors,
                      "Average_within_cluster_distance" = clusterTightness,
                      "Number_of_cells" = clusterSizes,
                      "Cell_type_proportion_variation" = clusterVariations,
                      "Number_of_clusters" = numberClusters)

#plots
p1 <- ggplot(forPlot, aes(x = Average_within_cluster_distance, y = Distance_between_real_and_predicted_centroid)) +
  geom_point() +
  geom_smooth(method = lm) +
  ggpubr::stat_cor(method = "pearson") +
  labs(title = "Relationship between a cluster's tightness and prediction errors", subtitle = "Each point represents a cluster")

p2 <- ggplot(forPlot, aes(x = Number_of_cells, y = Distance_between_real_and_predicted_centroid)) +
  geom_point(aes(col = Number_of_clusters)) +
  geom_smooth(method = lm) +
  ggpubr::stat_cor(method = "pearson") +
  labs(title = "Relationship between a cluster's size and prediction errors", subtitle = "Each point represents a cluster")

p3 <- ggplot(forPlot, aes(x = Cell_type_proportion_variation, y = Distance_between_real_and_predicted_centroid)) +
  geom_point() +
  geom_smooth(method = lm) +
  ggpubr::stat_cor(method = "pearson") +
  labs(title = "Relationship between a cluster's proportion variation across timepoints and prediction errors", subtitle = "Each point represents a cluster")

p1|p2|p3
```

# Algorithm Results

## Prediction accuracy

The previous sections in this report optimized the deconvolution algorithm by using only the single-cell RNA-Seq data. This section applies the resultant deconvolution algorithm to the following 4 bulk datasets:

1) ***Pseudo-bulk***: A pseudo-bulk RNA dataset is created for each timepoint by summing the gene counts of all cells within the timepoint.
2) ***Reconstructed Pseudo-bulk***: The reconstructed pseudo-bulk is created by matrix multiplication of the average cell cluster expression of each gene and the number of cells in each cluster each timepoint, i.e. $Y = AX$.
3) ***Bulk mRNA***: Bulk mRNA data from a microarray experiment.
4) ***Proteomics***: Bulk proteomics data from a mass spectrometry experiment. To make the scale of the data comparable to that of the RNA data, the proteomics intensities are divided by the ratio of the sum of the proteomics intensities to the sum of the reconstructed pseudobulk counts.

For each of the above datasets, we apply the deconvolution algorithm and compute the prediction error as the relative error between our predicted cell-cluster matrix $X'$ and the one obtained from the Seurat clustering of the scRNA data $X$. Since the identified genes differ across the three technologies, we retain only the ~5,000 genes common to all datasets for this comparison.

```{r applyDeconvolutionToDifferentBulkDatasets, fig.width = 16, fig.height = 10}
#combine ridge regression with a non-negative constraint
constrainedRidgeRegression <- function(bulk, timeProportions, lambda){
  #define required matrices/vectors for the quadratic solver
  Dmat <- t(timeProportions) %*% timeProportions
  Amat <- diag(ncol(timeProportions))
  
  #add small scaling of the identity matrix to Dmat to regularize prediction
  Dmat <- Dmat + lambda*diag(nrow(Dmat))
  
  #to avoid overflow cause by large values, scale Dmat and dvec
  scalingFactor <- norm(Dmat, "2")
  
  #iterate over genes
  sc <- apply(bulk, 2, function(gene){
    #define required matrices/vectors for the quadratic solver
    dvec <- t(timeProportions) %*% gene
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat / scalingFactor, dvec / scalingFactor, Amat)
    return(qp$solution)
  })
  
  return(sc)
}

#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#set of lambdas to test for ridge regression (sorted in descending order)
lambdaSet <- 10^(-10:10)

#create seurat object
seurat <- createSeurat(scrna)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters and different values of lambda (~2m)
results <- pblapply(names(clusters), function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #construct pseudo-bulk matrix
  pseudobulk <- t(createPseudoBulk(scrna = scrna))
  
  #reconstruct pseudo-bulk matrix
  Y <- A %*% X
  
  #bulk mRNA matrix
  bulk_RNA <- t(mrna)
  
  #bulk proteomics matrix
  bulk_proteomics <- t(proteome)
  
  #list of overlapping genes
  overlapGenes <- Reduce(intersect, allGenes)
  
  #retain overlapping genes only in the datasets
  X <- X[,overlapGenes]
  pseudobulk <- pseudobulk[,overlapGenes]
  Y <- Y[,overlapGenes]
  bulk_proteomics <- bulk_proteomics[,overlapGenes]
  bulk_RNA <- bulk_RNA[,overlapGenes]
  
  #re-scale proteomics data to be comparable to RNA
  bulk_proteomics <- bulk_proteomics / (sum(bulk_proteomics) / sum(Y))
  
  #create list of bulk datasets
  bulkDatasets <- list("Pseudobulk" = pseudobulk, "Reconstructed pseudobulk" = Y,
                       "Bulk mRNA" = bulk_RNA, "Proteomics" = bulk_proteomics)
  
  #construct matrix with all pairings of lambda and bulk datasets
  parameters <- expand.grid(names(bulkDatasets), lambdaSet) %>% 
    set_colnames(c("Bulk dataset", "Lambda"))
  
  #predict single-cell profiles using constrained ridge regression for each value of lambda
  X_hat <- apply(parameters, 1, function(pairing){
    #extract current parameters
    lambda <- as.numeric(pairing[["Lambda"]])
    bulk <- bulkDatasets[[pairing[["Bulk dataset"]]]]
    
    #predict single-cell profiles
    prediction <- constrainedRidgeRegression(bulk = bulk, timeProportions = A, lambda = lambda)
    
    #compute relative error between prediction and real matrix
    relativeError <- apply(abs(X - prediction) / X, 2, mean) %>% 
      .[!is.infinite(.) & !is.na(.)] %>% 
      mean(.)
    
    #compute relative error between bulk data and reconstructed pseudobulk
    bulkError <- apply(abs(Y - bulk) / Y, 2, mean) %>% 
      .[!is.infinite(.) & !is.na(.)] %>% 
      mean(.)
    
    return(data.frame(Bulk_dataset = pairing[["Bulk dataset"]], Lambda = lambda,
                      Number_of_clusters = clust, Relative_error = relativeError,
                      Bulk_difference = bulkError))
  }) %>% 
    do.call("rbind", .)
  
  return(X_hat)
}, cl = 6) %>% 
  do.call("rbind", .)


#plot lambda values and their corresponding error for deconvoluting each bulk dataset
ggplot(results, aes(x = log(Lambda), y = Relative_error, col = Number_of_clusters)) +
  geom_line() + geom_point() +
  facet_wrap(~ Bulk_dataset, scales = "free") +
  scale_x_continuous("log(Lambda)", labels = paste0("log(", as.character(results$Lambda), ")"), breaks = log(results$Lambda)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  labs(title = "Error of estimating single-cell profiles using ridge regression across values of lambda",
       subtitle = "Each color represents a pre-determined number of cell clusters")

#for each number of clusters, find optimal lambda
bestLambdas <- results %>% 
  group_by(Number_of_clusters, Bulk_dataset) %>%
  filter(Relative_error == min(Relative_error)) %>% 
  mutate(Number_of_clusters = as.integer(Number_of_clusters))

#plot relative error for each dataset after selecting optimal lambda parameters
ggplot(bestLambdas, aes(x = Number_of_clusters, y = Relative_error, col = Bulk_dataset)) +
  geom_line() + geom_point() +
  scale_x_continuous(breaks = 5:15) +
  labs(title = "Relative error of estimating single-cell profiles for different numbers of clusters",
       subtitle = "Predictions by ridge regression using optimal lambda value")
```

### Accounting for differences in experimental technologies

The errors computed in the previous section compared the predicted single-cell profiles to those derived from scRNA-Seq without accounting for the fact that the bulk mRNA and proteomics data were obtained from different technologies, namely microarray and mass spectrometry, which introduce their own technical noise. Indeed, even the pseudobulk that was reconstructed from the scRNA-Seq data after clustering differs from the actual summed-up measurements from the raw data. To account for these differences, we find the relative error between each of the bulk datasets and the "reconstructed" pseudobulk that was used to optimize the algorithm. By plotting that difference on the same plot as the prediction errors, we can place the prediction errors within the context of the underlying experimental differences. For example, in the case of proteomics it would correspond to adjusting the prediction error based on the discrepancy between the protein and RNA levels.

```{r accountForTechnologyDifferences, fig.width = 16}
#subset values to optimal lambda values and exclude reconstructed pseudobulk from comparison
techDifferences <- results %>% 
  group_by(Number_of_clusters, Bulk_dataset) %>%
  filter(Relative_error == min(Relative_error) & !Bulk_dataset == "Reconstructed pseudobulk") %>% 
  set_colnames(c("Bulk_dataset", "Lambda", "Number_of_clusters", "Prediction_error", "Bulk_difference")) %>% 
  mutate(Number_of_clusters = as.integer(Number_of_clusters)) %>% 
  melt(., id = c("Bulk_dataset", "Number_of_clusters", "Lambda"))

#plot prediction errors for each bulk dataset alongside technology differences
ggplot(techDifferences, aes(x = Number_of_clusters, y = value, col = variable)) +
  geom_line() + geom_point() +
  facet_wrap(~ Bulk_dataset) +
  scale_x_continuous(breaks = 5:15) +
  labs(title = "Precition error of single-cell profiles compared to error between sequencing technolgies",
       subtitle = "Predictions by ridge regression using optimal lambda value")

```

## Deconvolution of proteomics data

In this section of the report, we focus on deconvoluting the bulk proteomics data with 11 Seurat-defined clusters. We furthermore focus on a set of 80 hallmark genes associated with EMT from the [MSigDB database](https://www.gsea-msigdb.org/gsea/msigdb/cards/HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION.html). 

#### Seurat clustering results

```{r seurat11clusters, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#create seurat object
seurat <- createSeurat(scrna[overlapGenes,])

#determine number of seurat clusters
clust <- "11"

#cluster seurat object
seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)

#UMAP dimensionality reduction
seurat <- RunUMAP(seurat, dims = 1:10)

#plot UMAP
DimPlot(seurat, reduction = "umap", label = T) + ggtitle("Seurat-identified cell clusters")

#create matrix A with counts of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#convert cell type counts to proportions
timeProportions <- data.frame(apply(A, 1, function(x) return(x/sum(x))))

#convert to long format for ggplot
timeProportions <- melt(timeProportions)
colnames(timeProportions) <- c('Timepoint', 'Proportion')
timeProportions$Proportion <- round(timeProportions$Proportion, 2)

#add column for cluster name
timeProportions$Cell_Type <- as.factor(rep(0:(length(unique(Idents(seurat)))-1), ncol(mrna)))

#plot
ggplot(timeProportions, aes(x = Timepoint, y = Proportion, fill = Cell_Type,
                            label = ifelse(Proportion > 0.015, paste0(Proportion*100,'%'), "") )) +
  geom_bar(stat = 'identity') + 
  geom_text(size = 2, position = position_stack(vjust = 0.5)) +
  ggtitle("Cell type composition in each timepoint")
```

#### Single-cell proteomics predictions

```{r deconvoluteProteomics, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold', fig.height = 12}
#select particular case to deconvolute
clust <- "11"
lambda <- unlist(bestLambdas[bestLambdas$Number_of_clusters == as.numeric(clust) & bestLambdas$Bulk_dataset == "Proteomics","Lambda"])

#cluster seurat object
seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cluster = Idents(seurat)[variable]) %>% 
  group_by(gene, cluster) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cluster) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#create matrix A with proportions of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#bulk proteomics matrix
bulk_proteomics <- t(proteome)

#reconstruct pseudo-bulk matrix
Y <- A %*% X

#list of genes detected in each dataset
allGenes <- list("scRNA-Seq" = rownames(scrna), "Proteomics" = rownames(proteome), "Bulk mRNA" = rownames(mrna))

#list of overlapping genes
overlapGenes <- Reduce(intersect, allGenes)

#retain overlapping genes only in the datasets
X <- X[,overlapGenes]
Y <- Y[,overlapGenes]
bulk_proteomics <- bulk_proteomics[,overlapGenes]

#re-scale proteomics data to be comparable to RNA
bulk_proteomics <- bulk_proteomics / (sum(bulk_proteomics) / sum(Y))

#predict single-cell profiles using constrained ridge regression
prediction <- constrainedRidgeRegression(bulk = bulk_proteomics, timeProportions = A, lambda = lambda)

#remove zero variance genes
prediction <- prediction[,unlist(apply(prediction, 2, var)) > 0]

#hallmark genes to keep
#read in EMT hallmark genes
hallmark <- read.delim("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/hallmark_emt_geneset.txt", header = F)[,1]
hallmarkOverlap <- intersect(overlapGenes, hallmark)
prediction_hallmark <- prediction[,intersect(colnames(prediction), hallmarkOverlap)]

#visualize
pheatmap(t(prediction), scale = "row", show_rownames = F, cluster_cols = F, main = "Single-cell proteomics prediction - Seurat 11 clusters - all genes")
pheatmap(t(prediction_hallmark), scale = "row", show_rownames = T, cluster_cols = F, main = "Single-cell proteomics prediction - Seurat 11 clusters - EMT hallmark genes", cluster_rows = F)

#subset of known epithelial/mesenchymal markers
E <- c("SDC1", "RHOB", "GPC1", "SDC4")

M <- c("VIM", "FN1", "PLOD1", "FLNA")
```

\newpage

### Alternative clustering

Here, we examine an alternative clustering of the data, which clustered the scRNA data into 20 clusters using the [Monocle3 algorithm](https://cole-trapnell-lab.github.io/monocle3/).

```{r monocleClusters, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold', fig.height = 8, fig.width = 6}
#read in monocle clustering labels
monocle <- read.delim("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/scRNAseq - 22 monocle clusters.txt")
monocle <- setNames(monocle$clusters.HSMM., monocle$cells)
Idents(seurat) <- monocle
  
#plot UMAP
DimPlot(seurat, reduction = "umap", label = T) + ggtitle("Monocle-identified cell clusters")

#construct matrix with number of cells from each type in each timepoint
A <- as.data.frame(seurat@assays$RNA@counts) %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cluster = monocle[variable], timepoint = gsub(".*_","", variable)) %>% 
  group_by(cluster, timepoint) %>% 
  summarize(count = length(unique(variable))) %>% 
  tidyr::spread(key = cluster, value = count, fill = 0) %>% 
  tibble::column_to_rownames("timepoint")

#convert to matrix format
A <- as.matrix(A)

#convert cell type counts to proportions
timeProportions <- data.frame(apply(A, 1, function(x) return(x/sum(x))))

#convert to long format for ggplot
timeProportions <- melt(timeProportions)
colnames(timeProportions) <- c('Timepoint', 'Proportion')
timeProportions$Proportion <- round(timeProportions$Proportion, 2)

#add column for cluster name
timeProportions$Cell_Type <- as.factor(rep(0:(length(unique(monocle))-1), ncol(mrna)))

#plot
ggplot(timeProportions, aes(x = Timepoint, y = Proportion, fill = Cell_Type,
                            label = ifelse(Proportion > 0.015, paste0(Proportion*100,'%'), "") )) +
  geom_bar(stat = 'identity') + 
  geom_text(size = 2, position = position_stack(vjust = 0.5)) +
  ggtitle("Cell type composition in each timepoint - Monocle clustering")
```



```{r deconvoluteProteomicsMonocle, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold', fig.height = 12}
#select particular case to deconvolute
clust <- "11"
lambda <- unlist(bestLambdas[bestLambdas$Number_of_clusters == as.numeric(clust) & bestLambdas$Bulk_dataset == "Proteomics","Lambda"])

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cluster = Idents(seurat)[variable]) %>% 
  group_by(gene, cluster) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cluster) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#bulk proteomics matrix
bulk_proteomics <- t(proteome)

#reconstruct pseudo-bulk matrix
Y <- A %*% X

#list of genes detected in each dataset
allGenes <- list("scRNA-Seq" = rownames(scrna), "Proteomics" = rownames(proteome), "Bulk mRNA" = rownames(mrna))

#list of overlapping genes
overlapGenes <- Reduce(intersect, allGenes)

#retain overlapping genes only in the datasets
X <- X[,overlapGenes]
Y <- Y[,overlapGenes]
bulk_proteomics <- bulk_proteomics[,overlapGenes]

#re-scale proteomics data to be comparable to RNA
bulk_proteomics <- bulk_proteomics / (sum(bulk_proteomics) / sum(Y))

#predict single-cell profiles using constrained ridge regression
prediction <- constrainedRidgeRegression(bulk = bulk_proteomics, timeProportions = A, lambda = lambda)

#remove zero variance genes
prediction <- prediction[,unlist(apply(prediction, 2, var)) > 0]

#hallmark genes to keep
#read in EMT hallmark genes
hallmark <- read.delim("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/hallmark_emt_geneset.txt", header = F)[,1]
hallmarkOverlap <- intersect(overlapGenes, hallmark)
prediction_hallmark <- prediction[,intersect(colnames(prediction), hallmarkOverlap)]

#visualize
pheatmap(t(prediction), scale = "row", show_rownames = F, cluster_cols = F, main = "Single-cell proteomics prediction - Monocle 20 clusters - all genes")
pheatmap(t(prediction_hallmark), scale = "row", show_rownames = T, cluster_cols = F, main = "Single-cell proteomics prediction - Monocle 20 clusters - EMT hallmark genes", cluster_rows = T)
```


# Deconvolution of proteomics data - tuning lambda to individual genes

In this section of the report, we once agin focus on deconvoluting the bulk proteomics data with 11 Seurat-defined clusters, with a focus on a set of 80 hallmark genes associated with EMT from the [MSigDB database](https://www.gsea-msigdb.org/gsea/msigdb/cards/HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION.html). This time, we fine-tune the regression parameter $\lambda$ to individual genes.

For each gene, we test the prediction accuracy of 21 values of $\lambda$ (ranging from $1e^{-10}$ to $1e^{10}$) for deconvoluting pseudobulk RNA data to the single-cell level, with the scRNA data being the benchmark value. The value of $\lambda$ that minimized the error to the scRNA profiles is retained as the optimal value.

#### Seurat clustering results

```{r seurat11clustersIndividualGenesLambda, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#create seurat object
#seurat <- createSeurat(scrna[overlapGenes,])

#determine number of seurat clusters
clust <- "11"

#cluster seurat object
seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)

#UMAP dimensionality reduction
seurat <- RunUMAP(seurat, dims = 1:10)

#plot UMAP
DimPlot(seurat, reduction = "umap", label = T) + ggtitle("Seurat-identified cell clusters")

#create matrix A with counts of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#convert cell type counts to proportions
timeProportions <- data.frame(apply(A, 1, function(x) return(x/sum(x))))

#convert to long format for ggplot
timeProportions <- melt(timeProportions)
colnames(timeProportions) <- c('Timepoint', 'Proportion')
timeProportions$Proportion <- round(timeProportions$Proportion, 2)

#add column for cluster name
timeProportions$Cell_Type <- as.factor(rep(0:(length(unique(Idents(seurat)))-1), ncol(mrna)))

#plot
ggplot(timeProportions, aes(x = Timepoint, y = Proportion, fill = Cell_Type,
                            label = ifelse(Proportion > 0.015, paste0(Proportion*100,'%'), "") )) +
  geom_bar(stat = 'identity') + 
  geom_text(size = 2, position = position_stack(vjust = 0.5)) +
  ggtitle("Cell type composition in each timepoint")
```

#### Single-cell proteomics predictions

```{r deconvoluteProteomicsIndividualGeneLambdas, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold', fig.height = 12}
#constrained ridge regression with gene-level lambdas
perGeneConstrainedRidgeRegression <- function(bulk, timeProportions, optimalLambdas){
  #subset bulk to include genes for which optimal lambdas are present
  bulk <- bulk[,colnames(bulk) %in% optimalLambdas$Gene]
  
  #define required matrices/vectors for the quadratic solver
  Dmat <- t(timeProportions) %*% timeProportions
  Amat <- diag(ncol(timeProportions))
  
  #iterate over genes
  sc <- lapply(colnames(bulk), function(gene){
    #find optimal lambda for this gene
    lambda <- as.numeric(unlist(optimalLambdas[optimalLambdas$Gene == gene,"Lambda"]))
    
    #get expression values for this gene
    geneAbundances <- bulk[,gene]
    
    #define required matrices/vectors for the quadratic solver
    dvec <- t(timeProportions) %*% geneAbundances
    
    #add small scaling of the identity matrix to Dmat to regularize prediction
    Dmat <- Dmat + lambda*diag(nrow(Dmat))
    
    #to avoid overflow cause by large values, scale Dmat and dvec
    scalingFactor <- norm(Dmat, "2")
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat / scalingFactor, dvec / scalingFactor, Amat)
    return(qp$solution)
  }) %>% 
    do.call("cbind",.)
  colnames(sc) <- colnames(bulk)
  
  return(sc)
}

#select particular case to deconvolute
clust <- "11"

#read in all scores for all values of lambda and all genes
geneLambdas <- readRDS("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/geneLambdas.rds")

#subset table to optimal values for current clustering
optimalLambdas <- geneLambdas %>% 
  group_by(Gene) %>% 
  filter(Number_of_clusters == clust) %>% 
  filter(Relative_error == min(Relative_error)) %>% 
  filter(!is.infinite(Relative_error))

#cluster seurat object
seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)

#create matrix A with proportions of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cluster = Idents(seurat)[variable]) %>% 
  group_by(gene, cluster) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cluster) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#bulk proteomics matrix
bulk_proteomics <- t(proteome)

#reconstruct pseudo-bulk matrix
Y <- A %*% X

#list of genes detected in each dataset
allGenes <- list("scRNA-Seq" = rownames(scrna), "Proteomics" = rownames(proteome), "Bulk mRNA" = rownames(mrna))

#list of overlapping genes
overlapGenes <- Reduce(intersect, allGenes)

#retain overlapping genes only in the datasets
X <- X[,overlapGenes]
Y <- Y[,overlapGenes]
bulk_proteomics <- bulk_proteomics[,overlapGenes]

#re-scale proteomics data to be comparable to RNA
bulk_proteomics <- bulk_proteomics / (sum(bulk_proteomics) / sum(Y))

#predict single-cell profiles using constrained ridge regression
prediction <- perGeneConstrainedRidgeRegression(bulk = bulk_proteomics, timeProportions = A, optimalLambdas = optimalLambdas)

#remove zero variance genes
prediction <- prediction[,unlist(apply(prediction, 2, var)) > 0]

#add cluster labels
rownames(prediction) <- paste0("cluster_", 0:(length(unique(Idents(seurat)))-1))

#hallmark genes to keep
#read in EMT hallmark genes
hallmark <- read.delim("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/hallmark_emt_geneset.txt", header = F)[,1]
hallmarkOverlap <- intersect(overlapGenes, hallmark)
prediction_hallmark <- prediction[,intersect(colnames(prediction), hallmarkOverlap)]

#subset of known epithelial/mesenchymal markers
E <- c("SDC1", "RHOB", "GPC1", "SDC4")
M <- c("VIM", "FN1", "PLOD1", "FLNA")

#visualize
pheatmap(t(prediction), scale = "row", show_rownames = F, cluster_cols = F, main = "Single-cell proteomics prediction - Seurat 11 clusters - all genes")
pheatmap(t(prediction_hallmark), scale = "row", show_rownames = T, cluster_cols = F, main = "Single-cell proteomics prediction - Seurat 11 clusters - EMT hallmark genes", cluster_rows = T)
```