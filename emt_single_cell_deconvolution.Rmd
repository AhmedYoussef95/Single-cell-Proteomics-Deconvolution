---
title: "EMT Multi-Omics"
subtitle: "Deconvolution of proteomics data using scRNA-Seq"
author: "Ahmed Youssef"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: pdf_document
urlcolor: blue
toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

#required packages
library(data.table) #reading in large files quickly
library(kableExtra) #for tables
library(dplyr) #data wrangling
library(magrittr) #data wrangling
library(reshape2) #data wrangling
library(tidyr) #data wrangling
library(tibble) #data wrangling
library(ggplot2) #plots
library(patchwork) #plot figures plots on same plot
library(ComplexHeatmap) #heatmaps
library(celda) #scRNA clustering
library(Seurat) #scRNA clustering
library(VennDiagram) #venn diagram
library(umap) #UMAP
library(pracma) #distance between matrices
library(Matrix) #matrix operations
library(quadprog) #solving constrained OLS problem
library(glmnet) #ridge regression
library(pbapply) # parallel operations
library(ggpubr) #correlation plots annotation
```

# Introduction

The fundamental unit of all living organisms is the cell, and recent technological advances have granted us unprecedented opportunities to study life at this principal level. Proteins, through their networks of interactions, carry out most of the vital biological processes governing cellular functions, yet remain largely unexplored in the single-cell space, representing crucial gaps in our knowledge of cell biology. While single-cell proteomics methods are still in their infancy, single-cell RNA sequencing (scRNA-Seq) has emerged in recent years as a powerful technology for defining cell states on a large scale, enabling breakthroughs in many areas of cell biology research, and begging the question of whether it can be used for making inferences at the protein level. **In this report, I explore the deconvolution of bulk proteomics data to the single-cell level using scRNA-Seq data.**

# Experiment summary

Epithelial-to-mesenchymal transition (EMT) is a biological process in which epithelial cells gradually lose their adhesion and transition into mesenchymal cells. As one of the hallmarks of cancer progression, it is one of the long-standing interests of the biomedical research community. Towards profiling this process, protein and RNA samples were extracted from cells at 8 different timepoints during EMT and multiple layers of omics data were generated. These omics layers include proteomics, transcriptomics, phosphoproteomics, secretome, exosome among others. A pre-print with more details on the experiment and generated data can be found on bioRxiv [here (Paul et al, 2021)](https://www.biorxiv.org/node/2018285.external-links.html). This report is interested in the scRNA-Seq, microarray, and proteomics datasets generated in this study.

# Approach

Bulk proteomics data gives a view of the aggregated protein abundance from all cell types within a sequenced sample. Using single-cell data, derived from the same samples, we can investigate the sample heterogeneity by estimating proportions of cell types within a bulk sample. We cannot reliably use these proportions to directly estimate the contribution of each population to each gene/protein's expression at the bulk-level however, since there is low correlation between RNA and protein levels of the same genes due to multiple biological factors such as alternative splicing and post-translational modifications. Leveraging the timepoints present in this dataset, which conveniently show shifts in cell type abundances across time, we can instead look for changes in cell-type proportions and corresponding changes in bulk-level protein abundance as suggestive of relationships between specific cell types and specific proteins. This information can then potentially be used to estimate the contribution of individual cell types to the bulk proteomics measurements.

The step-by-step process is outlined below:

1)  Pool together all single cells across timepoints into one scRNA-Seq dataset
2)  Cluster the pooled scRNA data to identify cell states
3)  Compute proportion of each cell state in each timepoint using the cluster labels derived from the pooled data
4)  For each gene-cell state pairing, compute the Pearson correlation coefficient between the 8 timepoint proteomics measurements (gene) and the cell cluster proportions (scRNA)

# Data summary - Proteomics

The bulk proteomics data was generated in the Emili Lab using standard mass-spectrometry. Summary of the dataset follows:

-   6,426 proteins
-   10 different timepoints
-   Three replicates

The average intensity across replicates was computed for each protein in each timepoint. Timepoints 3 and 9 were removed since they are not present in the scRNA data.

```{r readProteome, fig.height = 3}
#read in '2D' proteomics data and average replicates in each timepoint
proteome <- read.delim("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/dat_irs_norm_emt_proteome.txt", stringsAsFactors = F) %>% 
  melt() %>% 
  #average replicates
  mutate(variable = gsub("_.*","", variable)) %>% 
  group_by(Gene.names, variable) %>% 
  summarize(intensity = mean(value)) %>% 
  #convert to wide format
  dcast(Gene.names ~ variable) %>% 
  magrittr::set_rownames(.$Gene.names) %>% 
  #remove inconsistent timepoints
  select(-c(1, 5, 11)) %>%
  as.matrix()

#scale original matrix row-wise
scaledProts <- t(apply(proteome, 1, scale))

#visualize heatmap
ComplexHeatmap::Heatmap(scaledProts,
                        name = "Intensity (scaled row-wise)", cluster_columns = FALSE, 
                        column_split = colnames(proteome), 
                        show_row_names = F, show_column_names = F, 
                        use_raster = T, row_title = "Proteins")
```

# Data summary - scRNA-Seq

The bulk proteomics data was generated in the Emili Lab using standard mass-spectrometry. Summary of the dataset follows:

-   9,785 genes
-   1,913 cells (\~200 cells per timepoint)
-   8 different timepoints

Prior to this summation, genes with zero variance as well as those with non-zero counts in less than 5% of all cells were removed. This removed 17 genes (0.2% of all genes).

```{r readSCRNA}
#read in data
scrna <- data.frame(fread("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/scRNAseq_filt_dat.txt", stringsAsFactors = FALSE)) %>% 
  magrittr::set_rownames(.$Gene.names) %>% 
  select(-1)

#compute variance of genes
geneVar <- apply(scrna, 1, var) %>% 
  .[. > 0]

#remove genes with zero variance
scrna <- scrna[names(geneVar),]

#get percentage of cells each gene is expressed in
cellsPerGene <- apply(scrna, 1, function(x) sum(x > 0) / length(x)) %>% 
  .[. >= 0.05]

#remove genes expressed in less than 5% of all cells
scrna <- scrna[names(cellsPerGene),]

#filter out lowly-expressed genes (threshold is at least 3 counts in 3 cells - removed 1,240 genes)
scrna <- scrna[rowSums(scrna > 3) > 3,]

#get number of cells in each timepoint
cellsPerTimepoint <- table(gsub(".*_","", colnames(scrna)))

#display table with no. of cells per timepoint
kable(t(cellsPerTimepoint), caption = "Number of cells in each timepoint") %>%
  kable_styling(latex_options = c("striped", "hold_position")) %>% 
  row_spec(row = 0, bold = T, color = "white", background = "gray")
```

# Data summary - Bulk mRNA

The bulk mRNA data comes from a microarray experiment. Summary of the dataset follows:

-   23,743 genes
-   10 different timepoints
-   Three replicates

The average intensity across replicates was computed for each protein in each timepoint. Timepoints 3 and 9 were removed since they are not present in the scRNA data.

```{r bulkRNA, results='hide'}
#read in data
mrna <- read.delim("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/emt_mRNA.txt", stringsAsFactors = F) %>% 
  melt() %>% 
  ##average replicates
  mutate(variable = gsub("RIC.","T", variable), Gene.names = gsub("_mRNA", "", .$Gene.names)) %>% 
  group_by(Gene.names, variable) %>% 
  summarize(counts = mean(value)) %>% 
  #remove log-transformation
  mutate(counts = (2^counts)-1) %>% 
  ##convert to wide format
  dcast(Gene.names ~ variable) %>% 
  magrittr::set_rownames(.$Gene.names) %>% 
  #remove inconsistent timepoints
  select(-c(1, 5, 11)) %>%
  as.matrix()
```

# Protein overlap

The venn diagram below shows the overlap of the identified proteins in the datasets.

```{r proteinOverlap, fig.height = 3, fig.width = 4}
#venn diagram
venn <- venn.diagram(x = list(rownames(scrna), rownames(proteome), rownames(mrna)),
                     category.names = c("scRNA-Seq", "Proteomics", "Bulk mRNA"),
                     filename = NULL,
                     fill = c("skyblue", "orange", "lightgreen"),
                     print.mode = c("raw", "percent"),
                     cat.default.pos = "outer",
                     height = 240, 
                     width = 240, 
                     scaled = FALSE)
grid::grid.draw(venn)
```

# Pseudo-bulk RNA vs bulk RNA

A pseudo-bulk RNA dataset is created for each timepoint by summing the gene counts of all cells within the timepoint. This pseudo-bulk data is then compared to the actual microarray bulk mRNA data present for each timepoint. The cross-timepoint measurements for each genes were also correlated. The distributions of these correlations are showed below.

```{r createPseudoBulk}
#create list of timepoints
timepoints <- colnames(mrna)

#create single-cell pseudo bulk data
pseudoBulk <- list()
for(t in timepoints){
  #get single-cell rna-seq in this timepoint
  curSC <- scrna[, grep(pattern = t, colnames(scrna))]
  
  #create pseudo-bulk by summing values
  curPseudo <- rowSums(curSC)
  curPseudo[is.na(curPseudo)] <- 0
  
  #log-transform and quantile normalize
  #curPseudo <- log2(curPseudo+1)
  #curPseudo <- preprocessCore::normalize.quantiles(as.matrix(curPseudo))
  
  #add current timepoint pseudo-bulk to list 
  pseudoBulk[[t]] <- curPseudo
  rm(curPseudo, curSC)
}
pseudoBulk <- data.frame(pseudoBulk)
rownames(pseudoBulk) <- rownames(scrna)
```

```{r pseudoBulkVsBulk, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold', results='hide'}
cors <- c()
#for each timepoint
for(t in timepoints){
  #get rna-seq in this timepoint
  curSC <- pseudoBulk[intersect(rownames(pseudoBulk), rownames(mrna)), grep(pattern = t, colnames(pseudoBulk))]
  curBulk <- mrna[intersect(rownames(pseudoBulk), rownames(mrna)), grep(pattern = t, colnames(mrna))]
  
  #add current timepoint correlation to list of correlations
  cors <- c(cors, cor(curSC, curBulk))
}

#create bar plot of correlations
cors <- data.frame(Timepoint=timepoints, Pearson_R2=cors)
ggplot(cors, aes(x=Timepoint, y=Pearson_R2)) +
  geom_bar(stat = "identity") +
  scale_y_continuous(limits = c(0,1)) +
  labs(title = "Correlation between pseudo-bulk RNA-Seq data and bulk microarray data",
       subtitle="Pseudo-bulk created by summing expression across all cells")

#correlate across timepoints for each gene
cors <- unlist(lapply(intersect(rownames(pseudoBulk), rownames(mrna)), function(g)
  return(cor(unlist(pseudoBulk[g,]), unlist(mrna[g,])))))

hist(cors, breaks = 100, main = "Correlation of pseudo-bulk and bulk RNA across genes", ylab = "Genes", xlab = "Pearson R2")
```

# Relationship between scRNA and bulk mRNA

To investigate the ability to recover the scRNA data from the pseudo-bulk data, we start by clustering the scRNA data to identify the cell clusters followed by creating the following matrices:

-   Matrix $A$ of dimensions $timepoints X clusters$. (cell type proportions)
-   Matrix $X$ of dimensions $clusters X genes$. (cluster-averaged single-cell RNA data)
-   Matrix $Y$ of dimensions $timepoints X genes$. (pseudo-bulk RNA data)

We then attempt to re-create the single-cell matrix $X$ data by computing $Y = AX'$.

![](/Users/Ahmed/Documents/Emili_Lab/Aim%203/EMT%20Multi-omics/Plots/bulk%20decnovolution%20outline.png)

## Identify cell clusters

The cell states in our dataset are identified in an unsupervised manner based on similarity of gene expression profiles. All cells from all timepoints are pooled together for this analysis.

For data pre-processing, we remove the genes with low expression counts, retaining genes with a minimum of 3 counts in at least 3 cells. This removed 1,240 genes (13% of all genes). On average, each cell expressed \~3,600 genes after processing. [Seurat](https://www.nature.com/articles/nbt.4096) is then used to cluster the cells based on the 2,000 most variable genes.

The initial model defines 7 cell clusters at a Seurat resolution of 0.4. We intentionally begin with a number of clusters less than the number of timepoints to avoid creating an undetermined problem. The below UMAP plot visualizes the identified cell clusters.

```{r seuratClusterSixClusters, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold', results='hide'}
#Cluster with Seurat
# Initialize the Seurat object with the raw (non-normalized data).
seurat <- CreateSeuratObject(counts = scrna, project = "EMT")

#normalize data
seurat <- NormalizeData(seurat)

#find most variable genes
seurat <- FindVariableFeatures(seurat, selection.method = "vst", nfeatures = 2000)

#scale data
all.genes <- rownames(seurat)
seurat <- ScaleData(seurat, features = all.genes)

#PCA
seurat <- RunPCA(seurat, features = VariableFeatures(object = seurat))

#construct KNN using 10 PCs
seurat <- FindNeighbors(seurat, dims = 1:10)

#cluster cells
seurat <- FindClusters(seurat, resolution = 0.4, random.seed = 123)

#UMAP dimensionality reduction
seurat <- RunUMAP(seurat, dims = 1:10)

#plot UMAP
DimPlot(seurat, reduction = "umap", label = T) + ggtitle("Identified cell clusters")
```

## Changes in cell state composition over time

Since this dataset is investigating cells undergoing EMT, the cell population abundances are changing over time. The below figures visualize these proportion changes.

Note: this approach assumes the single-cell data accurately captures the sample heterogeneity. In practice, biased cell sampling upstream could lead to an inaccurate view of sample heterogeneity here.

```{r cellTypeProportions, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
## get proportion of each cell type at each timepoint ##

#create list of timepoints
timepoints <- colnames(mrna)

#create vector which contains the timepoint each cell comes from
cellTimepoints <- as.factor(gsub(pattern = '.*_', replacement = "", colnames(scrna)))

#initialize empty list
timeProportions <- list()

#iterate over timepoints 
for(t in timepoints){
  #get cells from this timepoint
  curTimepoint <- Idents(seurat)[which(cellTimepoints == t)]
  
  #list which will contain abundance for each population
  pops <- c()
  
  #iterate over clusters
  for(i in unique(Idents(seurat))){
    #no. of cells in this timepoint and also this cluster
    curMembers <- length(which(curTimepoint == i))
    
    #proportion
    pops <- c(pops, curMembers / length(curTimepoint))
  }
  
  #add to final list
  timeProportions[t] <- list(pops)
}

## stacked bar chart
#convert to dataframe for ggplot
forPlot <- data.frame(timeProportions)

#convert to long format for ggplot
forPlot <- melt(forPlot)
colnames(forPlot) <- c('Timepoint', 'Proportion')
forPlot$Proportion <- round(forPlot$Proportion, 2)

#add column for cluster name
forPlot$Cell_Type <- as.factor(rep(0:(length(unique(Idents(seurat)))-1), length(timepoints)))

#plot
ggplot(forPlot, aes(x = Timepoint, y = Proportion, fill = Cell_Type,
                    label = ifelse(Proportion > 0.015, paste0(Proportion*100,'%'), "") )) +
  geom_bar(stat = 'identity') + 
  geom_text(size = 2, position = position_stack(vjust = 0.5)) +
  ggtitle("Cell type composition in each timepoint")

#line chart
ggplot(forPlot, aes(x = as.numeric(Timepoint), y = Proportion, col = Cell_Type)) +
  geom_line() +
  scale_x_continuous(labels = timepoints, breaks = 1:8) +
  ggtitle("Cell type proportions across timepoints") +
  labs(x = 'Timepoint')
```

## Re-construct pseudo-bulk data from single-cell data

We now attempt to re-create the pseudo-bulk data ($Y$) from the single-cell data using the simple formula $Y’ = AX$. The matrix $X$ was constructed by averaging the gene expression of each cluster. The matrix $A$ contains the number of cells from each cell cluster in each timepoint.

The below heatmaps show the pseudo-bulk data and the re-constructed data side-by-side, with the 8,528 genes in the same order. The heatmaps are scaled by row for visualization purposes. This reconstructed bulk data is then compared to the pseudo-bulk data in each timepoint. Correlations were also computed across the cross-timepoint measurements for each gene. The distributions of these correlations are shown below.

```{r keyFunctions}
#function to create pseudobulk from scRNA-Seq data
createPseudoBulk <- function(scrna){
  #create list of timepoints
  timepoints <- unique(gsub(pattern = ".*_", replacement = "", colnames(seurat)))
  
  #create single-cell pseudo bulk data
  pseudoBulk <- list()
  for(t in timepoints){
    #get single-cell rna-seq in this timepoint
    curSC <- scrna[, grep(pattern = t, colnames(scrna))]
    
    #create pseudo-bulk by summing values
    curPseudo <- rowSums(curSC)
    curPseudo[is.na(curPseudo)] <- 0
    
    #log-transform and quantile normalize
    #curPseudo <- log2(curPseudo+1)
    #curPseudo <- preprocessCore::normalize.quantiles(as.matrix(curPseudo))
    
    #add current timepoint pseudo-bulk to list 
    pseudoBulk[[t]] <- curPseudo
    rm(curPseudo, curSC)
  }
  pseudoBulk <- data.frame(pseudoBulk)
  rownames(pseudoBulk) <- rownames(scrna)
  return(as.matrix(pseudoBulk))
}

#create seurat object for downstream clustering
createSeurat <- function(counts){
  # Initialize the Seurat object with the raw (non-normalized data).
  seurat <- CreateSeuratObject(counts = counts, project = "EMT")
  
  #normalize data
  seurat <- NormalizeData(seurat)
  
  #scale data
  all.genes <- rownames(seurat)
  seurat <- ScaleData(seurat, features = all.genes)
  
  #find most variable genes
  seurat <- FindVariableFeatures(seurat, selection.method = "vst", nfeatures = 2000)
  
  #PCA on most variable genes
  seurat <- RunPCA(seurat, features = VariableFeatures(object = seurat))
  
  #construct KNN using 10 PCs
  seurat <- FindNeighbors(seurat, dims = 1:10)
  
  return(seurat)
}

#function to compute cell-type proportions 'A' given seurat-clustered data
computeCellProportions <- function(seurat){
  #construct matrix with number of cells from each type in each timepoint
  A <- as.data.frame(seurat@assays$RNA@counts) %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cluster = Idents(seurat)[variable], timepoint = gsub(".*_","", variable)) %>% 
    group_by(cluster, timepoint) %>% 
    summarize(count = length(unique(variable))) %>% 
    tidyr::spread(key = cluster, value = count, fill = 0) %>% 
    tibble::column_to_rownames("timepoint")
  
  #convert to matrix format
  A <- as.matrix(A)
  
  return(A)
}

#function to recover X from Y' by using X = pseudo-inverse of A * Y'
computeSCprofiles <- function(bulk, timeProportions){
  
  #predict scRNA matrix based on bulk and time proportions matrix
  #X_hat <- solve(t(A) %*% A) %*% (t(A) %*% Y_hat)
  sc <- pracma::pinv(timeProportions) %*% bulk
  
  return(sc)
}
```

```{r reconstructBulkRNA, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#construct matrix with cell-type proportions in each timepoint
#A <- t(data.frame(timeProportions))

#construct matrix with number of cells from each type in each timepoint
A <- do.call("rbind",(lapply(timepoints, function(t){
  #get cells from this timepoint
  curTimepoint <- as.character(Idents(seurat)[which(cellTimepoints == t)])
  
  #list which will contain number of cells for each population
  pops <- c()
  
  #iterate over clusters
  for(cluster in unique(Idents(seurat))){
    #no. of cells in this timepoint and also this cluster
    pops <- c(pops,length(which(curTimepoint == cluster)))
  }
  
  return(pops)
})))
rownames(A) <- timepoints

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cell = Idents(seurat)[variable]) %>% 
  group_by(gene, cell) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cell) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#reconstruct bulk matrix
Y_hat <- A %*% X

#construct pseudo-bulk RNA matrix
Y <- t(pseudoBulk)

#keep only the genes present in both datasets
overlapGenes <- intersect(colnames(Y), colnames(Y_hat))
Y <- Y[,overlapGenes]
Y_hat <- Y_hat[,overlapGenes]
X <- X[,overlapGenes]

#scale original matrices gene-wise
scaledY <- t(apply(Y, 2, scale))
scaledY_hat <- t(apply(Y_hat, 2, scale))
colnames(scaledY) <- colnames(scaledY_hat) <- timepoints

#visualize heatmap
ComplexHeatmap::Heatmap(scaledY, name = "Z-score",
                        cluster_columns = FALSE, cluster_rows = FALSE,
                        show_row_names = F, show_column_names = T, 
                        use_raster = T, row_title = "Genes",
                        column_title = "Original pseudo-bulk data")

ComplexHeatmap::Heatmap(scaledY_hat, name = "Z-score",
                        cluster_columns = FALSE, cluster_rows = FALSE,
                        show_row_names = F, show_column_names = T, 
                        use_raster = T, row_title = "Genes",
                        column_title = "Reconstructed bulk data")
```

```{r compareYtoYhat, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold', results='hide'}
cors <- c()
#for each timepoint
for(t in timepoints){
  #get rna-seq in this timepoint
  curSC <- Y_hat[t, intersect(colnames(Y_hat), colnames(Y))]
  curBulk <- Y[t, intersect(colnames(Y_hat), colnames(Y))]
  
  #add current timepoint correlation to list of correlations
  cors <- c(cors, cor(curSC, curBulk))
}

#create bar plot of correlations
cors <- data.frame(Timepoint=timepoints, Pearson_R2=cors)
ggplot(cors, aes(x=Timepoint, y=Pearson_R2)) +
  geom_bar(stat = "identity") +
  scale_y_continuous(limits = c(0,1)) +
  labs(title = "Correlation between reconstructed bulk RNA data and pseudo-bulk data",
       subtitle="Pseudo-bulk created by summing expression across all cells")

#correlation of genes
cors <- unlist(lapply(overlapGenes, function(g)
  return(cor(Y[,g], Y_hat[,g]))))

hist(cors, breaks = 100, main = "Correlation of reconstructed bulk RNA and pseudo-bulk RNA across genes", ylab = "Genes", xlab = "Pearson R2")
```

```{r bulkSimilarityToPseudo, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
#seurat <- createSeurat(scrna)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
bulkRMSE <- pblapply(clusters, function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #reconstruct bulk matrix
  Y_hat <- A %*% X
  
  #create pseudo-bulk matrix
  Y <- t(createPseudoBulk(scrna))
  
  #make Y and Y' follow the same order
  Y <- Y[,order(colnames(Y))]
  Y_hat <- Y_hat[,order(colnames(Y_hat))]
  
  #find relative error between Y and Y'
  relativeError <- apply(abs(Y - Y_hat) / Y, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

plot(x = 5:15, y = unlist(bulkRMSE), type = 'b',
     main = "Relative error between Y and Y' for different no. of clusters",
     ylab = "Relative error", xlab = "Number of clusters")
```

## Re-construct single-cell data from pseudo-bulk data

In this section, we attempt to re-create the single-cell data from the pseudo-bulk data and the timepoint-specific cell cluster counts. Based on the formula $Y = AX$ outlined in previous sections, given the pseudobulk matrix Y and the timepoint-specific cell counts 'mixing' matrix A, we aim to compute X using the formula $X' = (A^TA)^{-1}(A^TY)$, which is essentially the pseudo-inverse of A multiplied by the pseudo-bulk Y. Recall that the pseudo-bulk is computed by summing up the counts of individual cells in each timepoint.

We vary the number of cell clusters by varying the *resolution* parameter in Seurat's clustering algorithm. We try this method for a number of clusters ranging between 5-15. For each given number of clusters, we solve the formula above to predict $X'$. We then compare this to the actual observed $X$ from the scRNA-Seq data, which is the per-cluster average of gene counts. The errors are reported as relative RMAD (relative mean absolute deviation) using the formula $|X - X'| / X$, where $|X|$ is the absolute value of the difference. This error is computed for each gene and the final reported score is the average RMAD value, in other words: *on average, how different is a gene's predicted values compared to the true ones?*

This process above is repeated once using $Y'$ as the bulk data, where $Y' = AX$ is computed first prior to computing $X'$ as above, and once using the actual bulk data in this dataset. The resultant cluster-RMAD relationships are shown in the below plot.

```{r predictSingleCellProfilesFromPseudoBulk, message=FALSE, results='hide', eval=F}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
seurat <- createSeurat(scrna)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors <- pblapply(clusters, function(clust){
  #create pseudo-bulk matrix
  Y <- t(createPseudoBulk(scrna))
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cluster = Idents(seurat)[variable]) %>% 
    group_by(gene, cluster) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cluster) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors2 <- pblapply(clusters, function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #reconstruct bulk matrix
  Y_hat <- A %*% X
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y_hat, timeProportions = A)
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors3 <- pblapply(clusters, function(clust){
  #create bulk matrix
  Y <- t(mrna)
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #keep only the genes present in both datasets
  overlapGenes <- intersect(colnames(X), colnames(X_hat))
  X_hat <- X_hat[,overlapGenes]
  X <- X[,overlapGenes]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

#show all RMSEs on one plot
allErrors <- do.call("rbind", list(unlist(errors), unlist(errors2), unlist(errors3) ))
rownames(allErrors) <- c("Pseudo-bulk Y", "Pseudo-bulk Y'", "Actual bulk")
saveRDS(allErrors, "/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/relative_RMAD_OLS.rds")
```

```{r  plotSCpredictionsRMSE, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
allErrors <- readRDS("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/relative_RMAD_OLS.rds")
matplot(t(allErrors), type = c("b"), pch = 1, col = 1:3,
        main = "Predicting single-cell profiles from bulk using OLS", xlab = "Number of clusters", ylab = "Relative error", x = 5:15)
legend("topleft", legend = rownames(allErrors), col=1:3, pch=1) # optional legend
```

```{r visualizeXhatHeatmaps, results = 'hide', fig.width=16}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
#seurat <- createSeurat(scrna)

clust <- clusters["8"]
#cluster seurat object
seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)

#get number of clusters
nClust <- length(unique(Idents(seurat)))

#create matrix A with proportions of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cell = Idents(seurat)[variable]) %>% 
  group_by(gene, cell) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cell) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#create pseudo-bulk matrix
Y <- t(createPseudoBulk(scrna))

#reconstruct bulk matrix
Y_hat <- A %*% X

#create bulk matrix
bulk <- t(mrna)

#predict single-cell matrix X'
X_hat_Y <- computeSCprofiles(bulk = Y, timeProportions = A)
X_hat_Yhat <- computeSCprofiles(bulk = Y_hat, timeProportions = A)
X_hat_bulk <- computeSCprofiles(bulk = bulk, timeProportions = A)

#keep only the genes present in both datasets
overlapGenes <- intersect(colnames(X), colnames(X_hat_bulk))
X_hat_Y <- X_hat_Y[,overlapGenes]
X_hat_Yhat <- X_hat_Yhat[,overlapGenes]
X_hat_bulk <- X_hat_bulk[,overlapGenes]
X <- X[,overlapGenes]

#put into one table
allX <- do.call("rbind", list(X, X_hat_Y, X_hat_Yhat, X_hat_bulk))

#names of matrices
matrixNames <- c("X (8 clusters)", "X predicted from pseudobulk Y", "X predicted from re-created pseudobulk Y'", "X predicted from actual bulk")

#create heatmaps
ComplexHeatmap::Heatmap(t(allX),
                        name = "Counts", cluster_columns = FALSE, cluster_rows = T,
                        column_split = rep(matrixNames, each = nClust), use_raster = T, 
                        show_row_names = F, show_column_names = F, 
                        row_title = "Genes")
```

## Variation of gene expression within cell type across timepoints

```{r geneVarWithinCluster, fig.width = 12, fig.height = 8, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
#seurat <- createSeurat(scrna)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
geneCV <- pblapply(clusters, function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #find pairings where a cluster is not present in a timepoint
  pairings <- which(A==0, arr.ind = T) %>% 
    as.data.frame() %>% 
    mutate(row = rownames(A)[.$row], col = colnames(A)[.$col], key = paste(row, col, sep = "-")) %>% 
    .$key
  
  #compute coefficient of variation of genes in each cluster
  geneCV <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cluster = Idents(seurat)[variable], timepoint = gsub(".*_","", variable), key = paste(timepoint, cluster, sep = "-")) %>%
    filter(! key %in% pairings) %>% 
    group_by(cluster, gene, timepoint) %>% 
    summarise(counts = mean(value)) %>% 
    group_by(cluster, gene) %>% 
    summarise(cv = sd(counts) / mean(counts))
  
  return(mean(geneCV$cv, na.rm = TRUE))
}, cl = 6)


plot(x = 5:15, y = unlist(geneCV), type = 'b',
     main = "For a given cluster, how does its average expression of a gene change across timepoints?",
     ylab = "Average Coef. of Variation", xlab = "Number of clusters")
```

## Constraining the solution to be non-negative

The [Tsoucas et al](https://www.nature.com/articles/s41467-019-10802-z) publication proposed a strategy for RNA deconvolution based on the OLS formulation we used in this report, with the addition of constraining the solution to be non-negative since there are no possible negative gene counts, and increasing the weight of cell types with low average expression levels. Since we typically have more cell types than time points, our problem is underdetermined and as such there are multiple possible solutions. In this section, we follow their strategy for constraining the solution to be non-negative.

We solve $\hat{X} = min_{x >= 0}||AX-Y||^2$ which algebraically is the same as solving $\hat{X} = min_{x >= 0}(-2Y^T A X + X^T A^T A X)$. The R function [*solve.QP*](https://www.rdocumentation.org/packages/quadprog/versions/1.5-8/topics/solve.QP) from the [*quadprog*](https://cran.r-project.org/web/packages/quadprog/quadprog.pdf) package is used to solve this equation one gene at a time to estimate the expression profile at the cell-type level. This algorithm, however, expects a positive definite matrix. The matrix $A^TA$ is positive definite when $A$ has more rows than columns, i.e. when the problem is a least-squares problem. When we have more clusters than timepoints then $A$ has more columns than rows, and so the matrix is not invertible, and by extension not positive definite. As a workaround, we use the function [*nearPD*](https://www.rdocumentation.org/packages/Matrix/versions/1.3-4/topics/nearPD) to find the nearest positive matrix instead.

```{r solveQP, results='hide', eval = FALSE}
#function to solve QP problem given A and Y using nearest positive-definite matrix
computeSCprofiles <- function(bulk, timeProportions){
  
  #iterate over genes
  sc <- apply(bulk, 2, function(gene){
    #define required matrices/vectors for the quadratic solver
    Dmat <- t(timeProportions) %*% timeProportions
    dvec <- t(timeProportions) %*% gene
    Amat <- diag(ncol(timeProportions))
    
    #find nearest positive-definite matrix for D to be able to solve OLS problem
    Dmat <- as.matrix(Matrix::nearPD(Dmat)$mat)
    
    #add small scaling of the identitiy matrix to Dmat to make it positive definite
    #diag(Dmat) <- diag(Dmat)+1e-8
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat, dvec, Amat)
    return(qp$solution)
  })
  
  return(sc)
}

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors <- pblapply(clusters, function(clust){
  #create pseudo-bulk matrix
  Y <- t(createPseudoBulk(scrna))
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors2 <- pblapply(clusters, function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #reconstruct bulk matrix
  Y_hat <- A %*% X
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y_hat, timeProportions = A)
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

errors3 <- pblapply(clusters, function(clust){
  #create bulk matrix
  Y <- t(mrna)
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #keep only the genes present in both datasets
  overlapGenes <- intersect(colnames(X), colnames(X_hat))
  X_hat <- X_hat[,overlapGenes]
  X <- X[,overlapGenes]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

#combine results into one matrix
allErrors <- do.call("rbind", list(errors, errors2, errors3))
rownames(allErrors) <- c("Pseudo-bulk Y", "Pseudo-bulk Y'", "Actual bulk")
saveRDS(allErrors, "/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/relative_RMAD_constrained_OLS_nearPD.rds")
```

```{r plotQPresults, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
allErrors <- readRDS("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/relative_RMAD_constrained_OLS_nearPD.rds")
matplot(t(allErrors), type = c("b"), pch = 1, col = 1:3, xlab = "Number of clusters", ylab = "Relative RMSE",
        main = "Solving constrained OLS using nearest positive-definite matrix", x = 5:15)
legend("topleft", legend = rownames(allErrors), col=1:3, pch=1)
```

```{r visualizeXhatHeatmapsConstrainedOLSusingNearPD, results = 'hide', fig.width=16}
#function to solve QP problem given A and Y
computeSCprofiles <- function(bulk, timeProportions){
  
  #iterate over genes
  sc <- apply(bulk, 2, function(gene){
    #define required matrices/vectors for the quadratic solver
    Dmat <- t(timeProportions) %*% timeProportions
    dvec <- t(timeProportions) %*% gene
    Amat <- diag(ncol(timeProportions))
    
    #find nearest positive-definite matrix for D to be able to solve OLS problem
    Dmat <- as.matrix(Matrix::nearPD(Dmat)$mat)
    
    #add small scaling of the identitiy matrix to Dmat to make it positive definite
    #diag(Dmat) <- diag(Dmat)+1e-8
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat, dvec, Amat)
    return(qp$solution)
  })
  
  return(sc)
}

#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
#seurat <- createSeurat(scrna)

clust <- clusters["9"]
#cluster seurat object
seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)

#get number of clusters
nClust <- length(unique(Idents(seurat)))

#create matrix A with proportions of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cell = Idents(seurat)[variable]) %>% 
  group_by(gene, cell) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cell) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#create pseudo-bulk matrix
Y <- t(createPseudoBulk(scrna))

#reconstruct bulk matrix
Y_hat <- A %*% X

#create bulk matrix
bulk <- t(mrna)

#predict single-cell matrix X'
X_hat_Y <- computeSCprofiles(bulk = Y, timeProportions = A)
X_hat_Yhat <- computeSCprofiles(bulk = Y_hat, timeProportions = A)
X_hat_bulk <- computeSCprofiles(bulk = bulk, timeProportions = A)

#keep only the genes present in both datasets
overlapGenes <- intersect(colnames(X), colnames(X_hat_bulk))
X_hat_Y <- X_hat_Y[,overlapGenes]
X_hat_Yhat <- X_hat_Yhat[,overlapGenes]
X_hat_bulk <- X_hat_bulk[,overlapGenes]
X <- X[,overlapGenes]

#put into one table
allX <- do.call("rbind", list(X, X_hat_Y, X_hat_Yhat, X_hat_bulk))

#names of matrices
matrixNames <- c("X (9 clusters)", "X predicted from pseudobulk Y", "X predicted from re-created pseudobulk Y'", "X predicted from actual bulk")

#create heatmaps
ComplexHeatmap::Heatmap(t(allX),
                        name = "Counts", cluster_columns = FALSE, cluster_rows = FALSE,
                        column_split = rep(matrixNames, each = nClust), use_raster = T, 
                        show_row_names = F, show_column_names = F, 
                        row_title = "Genes")

```

As an alternative to the *nearPD* function, we add a small scaling of the identity matrix ($10^{-9}$) to $A^T A$, which will make it positive definite and as such allow *solve.QP* to work. The result is shown below.

```{r solveQPSmallScalingOfIdentityMatrix, results='hide', eval = FALSE}
#function to predict single-cell profiles by adding small scaling of identity matrix
computeSCprofiles <- function(bulk, timeProportions){
  
  #iterate over genes
  sc <- apply(bulk, 2, function(gene){
    #define required matrices/vectors for the quadratic solver
    Dmat <- t(timeProportions) %*% timeProportions
    dvec <- t(timeProportions) %*% gene
    Amat <- diag(ncol(timeProportions))
    
    #find nearest positive-definite matrix for D to be able to solve OLS problem
    #Dmat <- as.matrix(Matrix::nearPD(Dmat)$mat)
    
    #add small scaling of the identitiy matrix to Dmat to make it positive definite
    diag(Dmat) <- diag(Dmat) + 1e-8
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat, dvec, Amat)
    return(qp$solution)
  })
  
  return(sc)
}

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors <- pblapply(clusters, function(clust){
  #create pseudo-bulk matrix
  Y <- t(createPseudoBulk(scrna))
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors2 <- pblapply(clusters, function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #reconstruct bulk matrix
  Y_hat <- A %*% X
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y_hat, timeProportions = A)
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

errors3 <- pblapply(clusters, function(clust){
  #create bulk matrix
  Y <- t(mrna)
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #keep only the genes present in both datasets
  overlapGenes <- intersect(colnames(X), colnames(X_hat))
  X_hat <- X_hat[,overlapGenes]
  X <- X[,overlapGenes]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

#combine results into one matrix
allErrors <- do.call("rbind", list(errors, errors2, errors3))
rownames(allErrors) <- c("Pseudo-bulk Y", "Pseudo-bulk Y'", "Actual bulk")
saveRDS(allErrors, "/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/relative_RMAD_constrained_OLS.rds")
```

```{r plotQPresultsWithScalingIdentityMatrix, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
allErrors <- readRDS("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/relative_RMAD_constrained_OLS.rds")
matplot(t(allErrors), type = c("b"), pch = 1, col = 1:3, xlab = "Number of clusters", ylab = "Relative error",
        main = "Solving constrained OLS by adding small scaling of identity matrix", x = 5:15)
legend("topleft", legend = rownames(allErrors), col=1:3, pch=1)
```

```{r visualizeXhatHeatmapsQP2, results = 'hide', fig.width=16}
#non-negative OLS by adding small scaling of identity matrix
computeSCprofiles <- function(bulk, timeProportions){
  
  #iterate over genes
  sc <- apply(bulk, 2, function(gene){
    #define required matrices/vectors for the quadratic solver
    Dmat <- t(timeProportions) %*% timeProportions
    dvec <- t(timeProportions) %*% gene
    Amat <- diag(ncol(timeProportions))
    
    #find nearest positive-definite matrix for D to be able to solve OLS problem
    #Dmat <- as.matrix(Matrix::nearPD(Dmat)$mat)
    
    #add small scaling of the identitiy matrix to Dmat to make it positive definite
    diag(Dmat) <- diag(Dmat)+1e-8
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat, dvec, Amat)
    return(qp$solution)
  })
  
  return(sc)
}

#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
#seurat <- createSeurat(scrna)

clust <- clusters["9"]
#cluster seurat object
seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)

#get number of clusters
nClust <- length(unique(Idents(seurat)))

#create matrix A with proportions of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cell = Idents(seurat)[variable]) %>% 
  group_by(gene, cell) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cell) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#create pseudo-bulk matrix
Y <- t(createPseudoBulk(scrna))

#reconstruct bulk matrix
Y_hat <- A %*% X

#create bulk matrix
bulk <- t(mrna)

#predict single-cell matrix X'
X_hat_Y <- computeSCprofiles(bulk = Y, timeProportions = A)
X_hat_Yhat <- computeSCprofiles(bulk = Y_hat, timeProportions = A)
X_hat_bulk <- computeSCprofiles(bulk = bulk, timeProportions = A)

#keep only the genes present in both datasets
overlapGenes <- intersect(colnames(X), colnames(X_hat_bulk))
X_hat_Y <- X_hat_Y[,overlapGenes]
X_hat_Yhat <- X_hat_Yhat[,overlapGenes]
X_hat_bulk <- X_hat_bulk[,overlapGenes]
X <- X[,overlapGenes]

#put into one table
allX <- do.call("rbind", list(X, X_hat_Y, X_hat_Yhat, X_hat_bulk))

#names of matrices
matrixNames <- c("X (9 clusters)", "X predicted from pseudobulk Y", "X predicted from re-created pseudobulk Y'", "X predicted from actual bulk")

#create heatmaps
ComplexHeatmap::Heatmap(t(allX),
                        name = "Counts", cluster_columns = FALSE, cluster_rows = FALSE,
                        column_split = rep(matrixNames, each = nClust), use_raster = T, 
                        show_row_names = F, show_column_names = F, 
                        row_title = "Genes")

```

## Predicting single-cell profiles using ridge regression

The condition number of $A^TA$ for the case where we have 8 single-cell clusters, i.e. as many clusters as there are timepoints, is noticeably high (15,828) compared to a smaller number of clusters which suggests that it is a near-singular matrix. This would explain the relatively high error in estimating the single-cell profiles. In an attempt to address this, we use ridge regression to estimate the single-cell profiles instead.

Ridge regression is similar to linear regression but with the addition of a regularization term $\lambda$. A range of values for $\lambda$ are tested to decide on the optimal one. The R package [*glmnet*](https://cran.r-project.org/web/packages/glmnet/glmnet.pdf) is used for this task. We solve the problem by fitting a ridge regression model to each gene. The full procedure is outlined below:

[**Input:**]{.ul} Number of clusters *N*, Single-cell expression matrix *SC*

[**Procedure:**]{.ul}

1.  Cluster single-cell matrix *SC into N* clusters using *Seurat*

2.  Construct cluster \* gene matrix ***X*** by computing the average expression of each gene in each cluster

3.  Construct timepoint \* cluster mixing matrix ***A*** by counting the number of cells in each cluster in each timepoint

4.  Construct timepoint \* gene pseudobulk matrix ***Y*** using the formula $Y = AX$

5.  Define $LambdaSet = \{10^{-8}, 10^{-7}, 10^{-6}, 10^{-5}, 10^{-4}, 10^{-3}, 10^{-2}, 10^{-1}, 10^{0}, 10^{1} \}$

6.  For each column of *Y,* denoted as *y* :

7.  Fit ridge regression model *Beta* using the function `Beta = glmnet(x = A, y = y, lambda = LambdaSet, alpha = 0)`

8.  For each column in *X*, denoted as *x* :

-   For each lambda *L* :

1.  Compute *x'* = column *L* of *Beta*

2.  Compute error in predicting *x* as $||x - x'||^2$

3.  Accumulate error for each lambda as the sum of errors across genes

4.  Select lambda with minimum accumulated error

```{r ridgeRegression, fig.width = 12, fig.height = 8, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
#seurat <- createSeurat(scrna)

#set of lambdas to test for ridge regression (should be in decreasing order)
lambdaSet <- sort(10^(-10:0), decreasing = TRUE)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors <- pblapply(clusters, function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #iterate over genes (columns of Y) and fit regression model based on counts of clusters in each timepoint
  ridge <- apply(Y, 2, function(y){
    #fit ridge regression model
    Beta <- glmnet(x = A, y = y,  lambda = lambdaSet, alpha = 0)$beta
    
    #set column names to indicate lambda values
    colnames(Beta) <- lambdaSet
    
    #return estimated x'
    return(Beta)
  })
  
  #summarize predictions for each lambda into separate tables
  X_hat <- lapply(seq_along(lambdaSet), function(lambda){
    return(do.call("cbind", lapply(ridge, `[`, , lambda)))
  })
  names(X_hat) <- lambdaSet
  
  #compute relative error between X and X' for each lambda
  error <- lapply(X_hat, function(cur_X_hat){
    #find relative error between Y and Y'
    relativeError <- apply(abs(X - cur_X_hat) / X, 2, mean) %>% 
      .[!is.infinite(.) & !is.na(.)] %>% 
      mean(.)
    
    return(relativeError)
  })
  
  #convert error values to matrix (one column per lambda)
  error <- do.call("cbind", error)
  
  return(error)
}, cl = 6)

#combine all the errors into one table
errors <- do.call("rbind", errors)
rownames(errors) <- names(clusters)

#convert to long format for plotting
errors <- reshape2::melt(errors)
colnames(errors) <- c("Number of clusters", "Lambda", "Relative error")
errors$`Number of clusters` <- as.factor(errors$`Number of clusters`)

#plot
ggplot(errors, aes(x = log(Lambda), y = `Relative error`, col = `Number of clusters`)) +
  geom_line() + geom_point() +
  scale_x_continuous("log(Lambda)", labels = paste0("log(", as.character(errors$Lambda), ")"), breaks = log(errors$Lambda)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  labs(title = "Error of estimating single-cell profiles using ridge regression across values of lambda",
       subtitle = "Each color represents a pre-determined number of cell clusters")
```

For each number of clusters, we select the lambda which led to the minimal sum squared error when comparing the predicted single-cell profiles to the actual ones. Those selected lambdas are shown below.

```{r ridgeRegressionBestLambdas}
#for each number of clusters, find optimal lambda
bestLambdas <- errors %>% 
  group_by(`Number of clusters`) %>%
  summarise(`Best lambda` = lambdaSet[which(`Relative error` == min(`Relative error`))]) %>% 
  mutate(`Best lambda` = as.character(signif(`Best lambda`, 3)))

#show table with best lambda values
kable(bestLambdas, caption = "Ridge regression - Lambda values that minimize error") %>%
  kable_styling(latex_options = c("striped", "hold_position")) %>% 
  row_spec(row = 0, bold = T, color = "white", background = "gray")
```

\newpage

#### Comparing ridge regression to OLS

The below plots show a comparison of using ridge regression and non-negative constrained OLS for predicting the single-cell profiles from the bulk data and the timepoint-specific proportions.

```{r compareRidgeRegressionToOLS, fig.width = 14, fig.height = 8, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#predict X' using optimal lambda values for ridge regression
X_hat_ridge <- pblapply(names(clusters), function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #optimal lambda
  lambda <- as.numeric(unlist(bestLambdas[as.character(bestLambdas$`Number of clusters`) == clust, "Best lambda"]))
  
  #iterate over genes (columns of Y) and fit regression model based on counts of clusters in each timepoint
  ridge <- apply(Y, 2, function(y){
    #fit ridge regression model
    Beta <- glmnet(x = A, y = y,  lambda = lambda, alpha = 0)$beta
    
    #return estimated x'
    return(Beta)
  })
  
  #combine predictions of all genes into one matrix
  X_hat <- do.call("cbind", ridge)
  colnames(X_hat) <- names(ridge)
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
  
}, cl = 6)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
X_hat_ols <- pblapply(clusters, function(clust){
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
  
}, cl = 6)

#combine all the errors into one table
errors <- do.call("cbind", list(do.call("rbind", X_hat_ridge), do.call("rbind", X_hat_ols)))
rownames(errors) <- names(clusters)
colnames(errors) <- c("Ridge regression", "OLS")

#convert to long format for plotting
errors <- reshape2::melt(errors)
colnames(errors) <- c("Number_of_clusters", "Method", "Relative error")

#plot
ggplot(errors, aes(x = Number_of_clusters, y = `Relative error`, col = Method)) +
  geom_line() + geom_point() +
  scale_x_continuous(breaks = 5:15) +
  labs(title = "Relative error of estimating single-cell profiles for different numbers of clusters")
```

```{r visualizeXhatHeatmapsForRidgeAndOLS, results = 'hide', fig.width=16}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
#seurat <- createSeurat(scrna)

#scenario with 10 clusters
clust <- clusters["10"]

#cluster seurat object
seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)

#get number of clusters
nClust <- length(unique(Idents(seurat)))

#create matrix A with proportions of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cell = Idents(seurat)[variable]) %>% 
  group_by(gene, cell) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cell) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#reconstruct bulk matrix
Y_hat <- A %*% X

#predict single-cell matrix X' using OLS
X_hat_ols <- computeSCprofiles(bulk = Y_hat, timeProportions = A)

#optimal lambda
lambda <- unlist(bestLambdas[as.character(bestLambdas$`Number of clusters`) == names(clust), "Best lambda"])

#iterate over genes (columns of Y) and fit regression model based on counts of clusters in each timepoint
ridge <- pbapply(Y, 2, function(y){
  #fit ridge regression model
  Beta <- glmnet(x = A, y = y,  lambda = lambda, alpha = 0)$beta
  
  #return estimated x'
  return(Beta)
}, cl = 6)

#combine predictions of all genes into one matrix
X_hat_ridge <- do.call("cbind", ridge)
colnames(X_hat_ridge) <- names(ridge)

#keep only the genes present in all datasets
overlapGenes <- intersect(colnames(X), colnames(X_hat_ols))
X_hat_ols <- X_hat_ols[,overlapGenes]
X_hat_ridge <- X_hat_ridge[,overlapGenes]
X <- X[,overlapGenes]

#put into one table
allX <- as.matrix(do.call("rbind", list(X, X_hat_ols, X_hat_ridge)))

#names of matrices
matrixNames <- c("X (10 clusters)", "X predicted using OLS", "X predicted using Ridge Regression")

#create heatmaps
ComplexHeatmap::Heatmap(t(allX),
                        name = "Counts", cluster_columns = FALSE, cluster_rows = T,
                        column_split = rep(matrixNames, each = nClust), use_raster = T, 
                        show_row_names = F, show_column_names = F, 
                        row_title = "Genes")

```

## Ridge regression with non-negative constraint

The results above do not show an improvement in the single-cell predictions when using ridge regression. In this section, we explore the addition of a non-negative constraint to the ridge regression model, similar to how we applied it for OLS earlier in this report. To achieve this, we solve the equation $\hat{X} = min_{x >= 0}(-2Y^T A X + X^T A^T A X)$ after adding a ridge penalty $\lambda$ to the diagonal of the matrix $A^TA$. The R function [*solve.QP*](https://www.rdocumentation.org/packages/quadprog/versions/1.5-8/topics/solve.QP) from the [*quadprog*](https://cran.r-project.org/web/packages/quadprog/quadprog.pdf) package is used to solve this equation one gene at a time to estimate the expression profile at the cell-type level. To decide on the optimal value for the parameter $\lambda$, we test a range of values between $10^{-10}$ and $1$ for each number of clusters. For each value of $\lambda$, we sum the errors in estimating each gene's single-cell profile as a measure of the accuracy of the predicted single-cell profiles. The $\lambda$ that leads to the minimal error is selected as the optimal value.

```{r nonNegativeRidgeRegression, fig.width = 12, fig.height = 8, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#combine ridge regression with a non-negative constraint
constrainedRidgeRegression <- function(bulk, timeProportions, lambda){
  
  #iterate over genes
  sc <- apply(bulk, 2, function(gene){
    #define required matrices/vectors for the quadratic solver
    Dmat <- t(timeProportions) %*% timeProportions
    dvec <- t(timeProportions) %*% gene
    Amat <- diag(ncol(timeProportions))
    
    #find nearest positive-definite matrix for D to be able to solve OLS problem
    #Dmat <- as.matrix(Matrix::nearPD(Dmat)$mat)
    
    #add small scaling of the identity matrix to Dmat to regularize prediction
    Dmat <- Dmat + lambda*diag(nrow(Dmat))
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat, dvec, Amat)
    return(qp$solution)
  })
  
  return(sc)
}

#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#set of lambdas to test for ridge regression (should be in decreasing order)
lambdaSet <- sort(10^(-10:0), decreasing = TRUE)

#create seurat object
#seurat <- createSeurat(scrna)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors <- pblapply(clusters, function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #predict single-cell profiles using constrained ridge regression for each value of lambda
  X_hat <- lapply(lambdaSet, function(lambda){
    return(constrainedRidgeRegression(bulk = Y, timeProportions = A, lambda = lambda))
  })
  names(X_hat) <- lambdaSet
  
  #compute relative error between X and X' for each lambda
  error <- lapply(X_hat, function(cur_X_hat){
    #find relative error between Y and Y'
    relativeError <- apply(abs(X - cur_X_hat) / X, 2, mean) %>% 
      .[!is.infinite(.) & !is.na(.)] %>% 
      mean(.)
    
    return(relativeError)
  })
  
  #convert error values to matrix (one column per lambda)
  error <- do.call("cbind", error)
  
  return(error)
}, cl = 6)

#combine all the errors into one table
errors <- do.call("rbind", errors)
rownames(errors) <- names(clusters)

#convert to long format for plotting
errors <- reshape2::melt(errors)
colnames(errors) <- c("Number of clusters", "Lambda", "Relative error")
errors$`Number of clusters` <- as.factor(errors$`Number of clusters`)

#plot
ggplot(errors, aes(x = log(Lambda), y = `Relative error`, col = `Number of clusters`)) +
  geom_line() + geom_point() +
  scale_x_continuous("log(Lambda)", labels = paste0("log(", as.character(errors$Lambda), ")"), breaks = log(errors$Lambda)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  labs(title = "Error of estimating single-cell profiles using constrained ridge regression across values of lambda",
       subtitle = "Each color represents a pre-determined number of cell clusters")
```

For each number of clusters, we select the lambda which led to the minimal sum squared error when comparing the predicted single-cell profiles to the actual ones. Those selected lambdas are shown below.

```{r constrainedRidgeRegressionBestLambdas}
#for each number of clusters, find optimal lambda
bestLambdas <- errors %>% 
  group_by(`Number of clusters`) %>%
  summarise(`Best lambda` = lambdaSet[which(`Relative error` == min(`Relative error`))]) %>% 
  mutate(`Best lambda` = as.character(signif(`Best lambda`, 3)))

#show table with best lambda values
kable(bestLambdas, caption = "Constrained ridge regression - Lambda values that minimize error") %>%
  kable_styling(latex_options = c("striped", "hold_position")) %>% 
  row_spec(row = 0, bold = T, color = "white", background = "gray")
```

After selecting the optimal $\lambda$ for each number of clusters, we compare the results of using non-negative constrained ridge regression and OLS on predicting the single-cell profiles. The errors are reported as relative RMAD (relative mean absolute deviation) using the formula $|X - X'| / X$, where $|X|$ is the absolute value of the difference. This error is computed for each gene and the final reported score is the average RMAD value, in other words: *on average, how different is a gene's predicted values compared to the true ones?* The resultant relative RMAD values for each of the methods are shown below, along with an example predicted matrix.

```{r compareConstrainedRidgeRegressionToOLS, fig.width = 14, fig.height = 8, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#predict X' using optimal lambda values for constrained ridge regression
X_hat_ridge <- pblapply(names(clusters), function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #optimal lambda
  lambda <- as.numeric(unlist(bestLambdas[as.character(bestLambdas$`Number of clusters`) == clust, "Best lambda"]))
  
  #predict single-cell profiles using constrained ridge regression for each value of lambda
  X_hat <- constrainedRidgeRegression(bulk = Y, timeProportions = A, lambda = lambda)
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
X_hat_ols <- pblapply(clusters, function(clust){
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find relative error between X and X'
  relativeError <- apply(abs(X - X_hat) / X, 2, mean) %>% 
    .[!is.infinite(.) & !is.na(.)] %>% 
    mean(.)
  
  return(relativeError)
}, cl = 6)

#combine all the errors into one table
errors <- do.call("cbind", list(do.call("rbind", X_hat_ridge), do.call("rbind", X_hat_ols)))
rownames(errors) <- names(clusters)
colnames(errors) <- c("Ridge regression", "OLS")

#convert to long format for plotting
errors <- reshape2::melt(errors)
colnames(errors) <- c("Number_of_clusters", "Method", "Relative error")

#plot
ggplot(errors, aes(x = Number_of_clusters, y = `Relative error`, col = Method)) +
  geom_line() + geom_point() +
  scale_x_continuous(breaks = 5:15) +
  labs(title = "Relative RMSE of estimating single-cell profiles for different numbers of clusters",
       subtitle = "Non-negative constraint applied to both methods")
```

```{r visualizeXhatHeatmapsForConstrainedRidgeAndOLS, results = 'hide', fig.width=16}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
#seurat <- createSeurat(scrna)

#scenario with 10 clusters
clust <- clusters["10"]

#cluster seurat object
seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)

#get number of clusters
nClust <- length(unique(Idents(seurat)))

#create matrix A with proportions of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cell = Idents(seurat)[variable]) %>% 
  group_by(gene, cell) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cell) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#reconstruct bulk matrix
Y_hat <- A %*% X

#predict single-cell matrix X' using OLS
X_hat_ols <- computeSCprofiles(bulk = Y_hat, timeProportions = A)

#optimal lambda
lambda <- as.numeric(unlist(bestLambdas[as.character(bestLambdas$`Number of clusters`) == names(clust), "Best lambda"]))

#predict single-cell matrix X' using ridge regression
X_hat_ridge <- constrainedRidgeRegression(bulk = Y_hat, timeProportions = A, lambda = lambda)

#keep only the genes present in all datasets
overlapGenes <- intersect(colnames(X), colnames(X_hat_ols))
X_hat_ols <- X_hat_ols[,overlapGenes]
X_hat_ridge <- X_hat_ridge[,overlapGenes]
X <- X[,overlapGenes]

#put into one table
allX <- as.matrix(do.call("rbind", list(X, X_hat_ols, X_hat_ridge)))

#names of matrices
matrixNames <- c("X (10 clusters)", "X predicted using OLS", "X predicted using Ridge Regression")

#create heatmaps
ComplexHeatmap::Heatmap(t(allX),
                        name = "Counts", cluster_columns = FALSE, cluster_rows = T,
                        column_split = rep(matrixNames, each = nClust), use_raster = T, 
                        show_row_names = F, show_column_names = F, 
                        row_title = "Genes")

```

## Distribution of errors across genes

This section explores whether a ***partial prediction*** might be more feasible, that is whether the single-cell predictions might be more accurate for a subset of the genes, such as differential markers, by comparing the distributions of prediction errors for individual genes as they relate to cell-type expression specificity.

To explore the relationship between properties of the genes and their corresponding predicted values, for each gene we compute the following measures:

-   ***Expression specificity:*** This metric looks at the relative specificity of a given gene's expression to the clusters. The coefficient of variation of the gene's cluster-specific expression values is computed as the standard deviation of the per-cluster expression values divided by the mean.

-   ***Average expression:*** This metric is concerned with the relative abundance of each gene's transcript, and is simply computed as the mean expression of the gene across clusters.

Each of the above measures are then compared to the error in predicting the gene's expression value using regression.

```{r partialPredictions, fig.width = 16, fig.height = 16}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#for each no. of clusters, predict X' and find corresponding scores
predictions <- pblapply(names(clusters), function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #optimal lambda
  lambda <- as.numeric(unlist(bestLambdas[as.character(bestLambdas$`Number of clusters`) == clust, "Best lambda"]))
  
  #predict single-cell profiles using constrained ridge regression for each value of lambda
  X_hat <- constrainedRidgeRegression(bulk = Y, timeProportions = A, lambda = lambda)
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #compute error between X and X' for each gene
  error <- apply((abs(X - X_hat) / X), 2, mean)
  
  #compute each gene's coeff. of variation across cell types
  cv <- apply(X, 2, function(gene){
    return(sd(gene) / mean(gene))
  })
  
  #compute each gene's average expression value
  average_expression <- colMeans(X)
  
  #construct table with all values of interest to return
  toReturn <- data.frame(Gene = colnames(X),
                         Number_of_clusters = as.numeric(clust),
                         Error = error,
                         Coef_variation = cv,
                         Av_expression = average_expression)
  return(toReturn)
  
}, cl = 6)
names(predictions) <- names(clusters)

#convert list into data frame
predictions <- do.call("rbind", predictions)

#remove 'infinite' entries (dividing by zero)
predictions <- predictions[!is.infinite(predictions$Error),] %>% 
  .[complete.cases(.),]

#correlation plots of errors for each number of clusters
CV_plot <- ggplot(predictions, aes(x = Coef_variation, y = Error)) +
  geom_point() +
  geom_smooth(method = lm) +
  facet_wrap(~ Number_of_clusters, scales = "free") +
  ggpubr::stat_cor(method = "pearson") +
  labs(title = "Relationship between a gene's cluster specificity and prediction errors",
       subtitle = "Each box represents a pre-defined number of clusters")

expression_plot <- ggplot(predictions, aes(x = Av_expression, y = Error)) +
  geom_point() +
  geom_smooth(method = lm) +
  facet_wrap(~ Number_of_clusters, scales = "free") +
  ggpubr::stat_cor(method = "pearson") +
  labs(title = "Relationship between a gene's average expression and prediction errors",
       subtitle = "Each box represents a pre-defined number of clusters")

CV_plot / expression_plot
```
## Evaluation of single-cell predictions

The below sections examine the accuracy of the single-cell predictions made using ridge regression in the previous section. Note: the bulk matrix that is deconvoluted in this section is the reconstructed pseudo-bulk matrix ($Y=AX$).

#### Are our predicted cluster centroids close to the real ones?

The cluster centroid is each cluster’s average gene expression profile. Visualizing the two sets of centroids (real & predicted) side-by-side on a *UMAP* will help us answer this question. For each number of clusters between 5 and 15, we cluster the data using *Seurat* and construct the matrix $X$ which contains the average gene expression by cluster. We then use the ridge regression approach defined in the previous section to construct the matrix $X'$. Finally, we perform a *UMAP* projection using the R package [umap][https://cran.r-project.org/web/packages/umap/vignettes/umap.html] on the original gene expression matrix but with the addition of the real and predicted cluster centroids, i.e. the rows of $X$ and $X'$. The *UMAP*s below show the projections for each number of clusters.

```{r UMAPpredictedVsRealCentroids, eval = FALSE}
#for each no. of clusters, construct UMAP
umapList <- pblapply(names(clusters), function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #optimal lambda
  lambda <- as.numeric(unlist(bestLambdas[as.character(bestLambdas$`Number of clusters`) == clust, "Best lambda"]))
  
  #predict single-cell profiles using constrained ridge regression for each value of lambda
  X_hat <- constrainedRidgeRegression(bulk = Y, timeProportions = A, lambda = lambda)
  
  #sort matrices to all follow the same order of genes
  overlapGenes <- Reduce(intersect, list(rownames(scrna), colnames(X), colnames(X_hat)))
  scrna <- scrna[overlapGenes, ]
  X <- X[, overlapGenes]
  X_hat <- X_hat[, overlapGenes]
  
  #concatenate centroids to single-cell expression matrix
  mergedSC <- rbind(t(scrna), X, X_hat)
  
  #UMAP
  set.seed(123)
  umap <- as.data.frame(umap::umap(mergedSC)$layout)
  
  #add label indicating whether point is a centroid
  umap$centroid <- c(rep("cell", ncol(scrna)), rep("real centroid", nrow(X)), rep("predicted centroid", nrow(X_hat)))
  
  #add label indicating the no. of cluster for this UMAP
  umap$number_of_clusters <- paste(clust, "clusters")
  
  #add label indicating cell cluster
  umap$cluster <- c(rep(NA, ncol(scrna)), rep(1:nrow(X), 2))
  
  return(umap)
}, cl = 6)

#merge all results into one table
mergedUmap <- do.call("rbind", umapList)

#save locally
saveRDS(mergedUmap, "/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/UMAP_list_sc_predictions.rds")
```

```{r UMAPcomparisonOfPredcitions, fig.width = 16, fig.height = 16}
#read in pre-computed UMAP projections
mergedUmap <- readRDS("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/UMAP_list_sc_predictions.rds")

#plot
ggplot(mergedUmap, aes(x = V1, y = V2, col = centroid)) +
  geom_point() +
  geom_label(label = mergedUmap$cluster) + 
  facet_wrap( ~ number_of_clusters) + 
  scale_color_manual(values = c("grey", "red", "blue"), name = "Key") +
  theme_classic2() +
  ggtitle("UMAP visualization of the predicted cell cluster centroids relative to the predicted ones")
```

#### How similar is the average cell to it's real centroid compared to the predicted one?

To determine if our predictions are reasonable approximations of the real data, we also compare the predictions to the real data by computing the Euclidean distance between individual cells’ measurements and their real cluster average as opposed to the distance between our predictions and the same cluster average.

More specifically, for a given number of clusters, we cluster the data using *Seurat*, followed by iterating over each of the ~1,900 cells in the original single-cell expression matrix and computing the Euclidean distance between it's profile and that of its cluster's centroid. Next, for each cluster we compute the average distance of it's cells to the centroid, as well as the distance between our predicted centroid and the corresponding cluster centroid. By comparing these two distances side-by-side, we can determine whether our predicted centroids fall within the correct intra-cluster range.

```{r distancesBetweenCellsAndCentroids, , fig.width = 16, fig.height = 16}
#for each no. of clusters, predict X' and find average distance between cells and their centroids
centroidDistances <- pblapply(names(clusters), function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #optimal lambda
  lambda <- as.numeric(unlist(bestLambdas[as.character(bestLambdas$`Number of clusters`) == clust, "Best lambda"]))
  
  #predict single-cell profiles using constrained ridge regression
  X_hat <- constrainedRidgeRegression(bulk = Y, timeProportions = A, lambda = lambda)
  
  #sort matrices to all follow the same order of genes
  overlapGenes <- Reduce(intersect, list(rownames(scrna), colnames(X), colnames(X_hat)))
  scrna <- scrna[overlapGenes, ]
  X <- X[, overlapGenes]
  X_hat <- X_hat[, overlapGenes]
  
  #break up single-cell expression matrix by cluster and compare to centroids
  clusterDistances <- lapply(sort(unique(Idents(seurat))), function(curCluster){
    #get counts for cells belonging to this cluster
    curCounts <- t(scrna[, Idents(seurat) == curCluster])
    
    #get centroid belonging to this cluster
    curCentroid <- X[curCluster,]
    
    #compute distances between each cell and the corresponding centroid
    curDistances <- apply(curCounts, 1, function(cell){
      return(sqrt(sum((cell - curCentroid)^2)))
    })
    
    #get average distance
    averageDistance <- mean(curDistances, na.rm = TRUE)
    
    #find distance between predicted centroid and real centroid
    centroidDistance <- sqrt(sum((curCentroid - X_hat[curCluster,])^2))
    
    #return table with distances
    toReturn <- data.frame(Type = c("Average cell", "Predicted centroid"),
                           Distance = c(averageDistance, centroidDistance),
                           Cluster = curCluster)
  })

  #merge results from all clusters into one table
  clusterDistances <- do.call("rbind", clusterDistances)
  
  #add column indicating the number of clusters
  clusterDistances$Number_of_clusters <- paste(clust, "clusters")
  
  return(clusterDistances)
}, cl = 6)

#merge results into one table
centroidDistances <- do.call("rbind", centroidDistances)

#plot bar plot
ggplot(centroidDistances, aes(x = Cluster, y = Distance, fill = Type)) + 
  geom_bar(stat = "identity", position = "dodge", width = .5) +
  facet_wrap( ~ Number_of_clusters, scales = "free") +
  labs(title = "Average Euclidean distance between each cluster's cells and it's centroid compared to the predicted centroid")+
  theme_bw() +
  coord_flip()
```

#### Which clusters are easier to predict?

We compute the correlation between how ’tightly-knit’ a cluster is, i.e. average within-cluster distance to the centroid, and the error in predicting the profiles. The error in this case is taken as the Euclidean distance between the cluster's predicted centroid and the actual centroid.

```{r correlationOfClusterTightnessToError}
#compute correlations from results of the section comparing centroids
centroidErrors <- centroidDistances[centroidDistances$Type == "Predicted centroid", "Distance"]
clusterTightness <- centroidDistances[centroidDistances$Type == "Average cell", "Distance"]
forPlot <- data.frame("Distance_between_real_and_predicted_centroid" = centroidErrors,
                      "Average_within_cluster_distance" = clusterTightness)

#plot
ggplot(forPlot, aes(x = Average_within_cluster_distance, y = Distance_between_real_and_predicted_centroid)) +
  geom_point() +
  geom_smooth(method = lm) +
  ggpubr::stat_cor(method = "pearson") +
  labs(title = "Relationship between a cluster's tightness and prediction errors")
```









