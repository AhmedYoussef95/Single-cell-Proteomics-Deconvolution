---
title: "EMT Multi-Omics"
subtitle: "Deconvolution of proteomics data using scRNA-Seq"
author: "Ahmed Youssef"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: pdf_document
urlcolor: blue
toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

#required packages
library(data.table) #reading in large files quickly
library(kableExtra) #for tables
library(dplyr) #data wrangling
library(magrittr) #data wrangling
library(reshape2) #data wrangling
library(tidyr) #data wrangling
library(tibble) #data wrangling
library(ggplot2) #plots
library(patchwork) #plot figures plots on same plot
library(ComplexHeatmap) #heatmaps
library(celda) #scRNA clustering
library(Seurat) #scRNA clustering
library(VennDiagram) #venn diagram
library(umap) #UMAP
library(pracma) #distance between matrices
library(Matrix) #matrix operations
library(quadprog) #solving constrained OLS problem
library(glmnet) #ridge regression
library(pbapply) # parallelize operations
```

# Introduction

The fundamental unit of all living organisms is the cell, and recent technological advances have granted us unprecedented opportunities to study life at this principal level. Proteins, through their networks of interactions, carry out most of the vital biological processes governing cellular functions, yet remain largely unexplored in the single-cell space, representing crucial gaps in our knowledge of cell biology. While singl-cell proteomics methods are still in their infancy, single-cell RNA sequencing (scRNA-Seq) has emerged in recent years as a powerful technology for defining cell states on a large scale, enabling breakthroughs in many areas of cell biology research, and begging the question of whether it can be used for making inferences at the protein level. **In this report, I explore the deconvolution of bulk proteomics data to the single-cell level using scRNA-Seq data.**

# Experiment summary

Epithelial-to-mesenchymal transition (EMT) is a biological process in which epithelial cells gradually lose their adhesion and transition into mesenchymal cells. As one of the hallmarks of cancer progression, it is one of the long-standing interests of the biomedical research community. Towards profiling this process, protein and RNA samples were extracted from cells at 8 different timepoints during EMT and multiple layers of omics data were generated. These omics layers include proteomics, transcriptomics, phosphoproteomics, secretome, exosome among others. A pre-print with more details on the experiment and generated data can be found on bioRxiv [here (Paul et al, 2021)](https://www.biorxiv.org/node/2018285.external-links.html). This report is interested in the scRNA-Seq, microarray, and proteomics datasets generated in this study.

# Approach

Bulk proteomics data gives a view of the aggregated protein abundance from all cell types within a sequenced sample. Using single-cell data, derived from the same samples, we can investigate the sample heterogeneity by estimating proportions of cell types within a bulk sample. We cannot reliably use these proportions to directly estimate the contribution of each population to each gene/protein's expression at the bulk-level however, since there is low correlation between RNA and protein levels of the same genes due to multiple biological factors such as alternative splicing and post-translational modifications. Leveraging the timepoints present in this dataset, which conveniently show shifts in cell type abundances across time, we can instead look for changes in cell-type proportions and corresponding changes in bulk-level protein abundance as suggestive of relationships between specific cell types and specific proteins. This information can then potentially be used to estimate the contribution of individual cell types to the bulk proteomics measurements.

The step-by-step process is outlined below:

1)  Pool together all single cells across timepoints into one scRNA-Seq dataset
2)  Cluster the pooled scRNA data to identify cell states
3)  Compute proportion of each cell state in each timepoint using the cluster labels derived from the pooled data
4)  For each gene-cell state pairing, compute the Pearson correlation coefficient between the 8 timepoint proteomics measurements (gene) and the cell cluster proportions (scRNA)

# Data summary - Proteomics

The bulk proteomics data was generated in the Emili Lab using standard mass-spectrometry. Summary of the dataset follows:

-   6,426 proteins
-   10 different timepoints
-   Three replicates

The average intensity across replicates was computed for each protein in each timepoint. Timepoints 3 and 9 were removed since they are not present in the scRNA data.

```{r readProteome, fig.height = 3}
#read in '2D' proteomics data and average replicates in each timepoint
proteome <- read.delim("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/dat_irs_norm_emt_proteome.txt", stringsAsFactors = F) %>% 
  melt() %>% 
  #average replicates
  mutate(variable = gsub("_.*","", variable)) %>% 
  group_by(Gene.names, variable) %>% 
  summarize(intensity = mean(value)) %>% 
  #convert to wide format
  dcast(Gene.names ~ variable) %>% 
  magrittr::set_rownames(.$Gene.names) %>% 
  #remove inconsistent timepoints
  select(-c(1, 5, 11)) %>%
  as.matrix()

#scale original matrix row-wise
scaledProts <- t(apply(proteome, 1, scale))

#visualize heatmap
ComplexHeatmap::Heatmap(scaledProts,
                        name = "Intensity (scaled row-wise)", cluster_columns = FALSE, 
                        column_split = colnames(proteome), 
                        show_row_names = F, show_column_names = F, 
                        use_raster = T, row_title = "Proteins")
```

# Data summary - scRNA-Seq

The bulk proteomics data was generated in the Emili Lab using standard mass-spectrometry. Summary of the dataset follows:

-   9,785 genes
-   1,913 cells (\~200 cells per timepoint)
-   8 different timepoints

Prior to this summation, genes with zero variance as well as those with non-zero counts in less than 5% of all cells were removed. This removed 17 genes (0.2% of all genes).

```{r readSCRNA}
#read in data
scrna <- data.frame(fread("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/scRNAseq_filt_dat.txt", stringsAsFactors = FALSE)) %>% 
  magrittr::set_rownames(.$Gene.names) %>% 
  select(-1)

#compute variance of genes
geneVar <- apply(scrna, 1, var) %>% 
  .[. > 0]

#remove genes with zero variance
scrna <- scrna[names(geneVar),]

#get percentage of cells each gene is expressed in
cellsPerGene <- apply(scrna, 1, function(x) sum(x > 0) / length(x)) %>% 
  .[. >= 0.05]

#remove genes expressed in less than 5% of all cells
scrna <- scrna[names(cellsPerGene),]

#get number of cells in each timepoint
cellsPerTimepoint <- table(gsub(".*_","", colnames(scrna)))

#display table with no. of cells per timepoint
kable(t(cellsPerTimepoint), caption = "Number of cells in each timepoint") %>%
  kable_styling(latex_options = c("striped", "hold_position")) %>% 
  row_spec(row = 0, bold = T, color = "white", background = "gray")
```

# Data summary - Bulk mRNA

The bulk mRNA data comes from a microarray experiment. Summary of the dataset follows:

-   23,743 genes
-   10 different timepoints
-   Three replicates

The average intensity across replicates was computed for each protein in each timepoint. Timepoints 3 and 9 were removed since they are not present in the scRNA data.

```{r bulkRNA, results='hide'}
#read in data
mrna <- read.delim("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/emt_mRNA.txt", stringsAsFactors = F) %>% 
  melt() %>% 
  ##average replicates
  mutate(variable = gsub("RIC.","T", variable), Gene.names = gsub("_mRNA", "", .$Gene.names)) %>% 
  group_by(Gene.names, variable) %>% 
  summarize(counts = mean(value)) %>% 
  #remove log-transformation
  mutate(counts = (2^counts)-1) %>% 
  ##convert to wide format
  dcast(Gene.names ~ variable) %>% 
  magrittr::set_rownames(.$Gene.names) %>% 
  #remove inconsistent timepoints
  select(-c(1, 5, 11)) %>%
  as.matrix()
```

# Protein overlap

The venn diagram below shows the overlap of the identified proteins in the datasets.

```{r proteinOverlap, fig.height = 3, fig.width = 4}
#venn diagram
venn <- venn.diagram(x = list(rownames(scrna), rownames(proteome), rownames(mrna)),
                     category.names = c("scRNA-Seq", "Proteomics", "Bulk mRNA"),
                     filename = NULL,
                     fill = c("skyblue", "orange", "lightgreen"),
                     print.mode = c("raw", "percent"),
                     cat.default.pos = "outer",
                     height = 240, 
                     width = 240, 
                     scaled = FALSE)
grid::grid.draw(venn)
```

# Pseudo-bulk RNA vs bulk RNA

A pseudo-bulk RNA dataset is created for each timepoint by summing the gene counts of all cells within the timepoint. This pseudo-bulk data is then compared to the actual microarray bulk mRNA data present for each timepoint. The cross-timepoint measurements for each genes were also correlated. The distributions of these correlations are showed below.

```{r createPseudoBulk}
#create list of timepoints
timepoints <- colnames(mrna)

#create single-cell pseudo bulk data
pseudoBulk <- list()
for(t in timepoints){
  #get single-cell rna-seq in this timepoint
  curSC <- scrna[, grep(pattern = t, colnames(scrna))]
  
  #create pseudo-bulk by summing values
  curPseudo <- rowSums(curSC)
  curPseudo[is.na(curPseudo)] <- 0
  
  #log-transform and quantile normalize
  #curPseudo <- log2(curPseudo+1)
  #curPseudo <- preprocessCore::normalize.quantiles(as.matrix(curPseudo))
  
  #add current timepoint pseudo-bulk to list 
  pseudoBulk[[t]] <- curPseudo
  rm(curPseudo, curSC)
}
pseudoBulk <- data.frame(pseudoBulk)
rownames(pseudoBulk) <- rownames(scrna)
```

```{r pseudoBulkVsBulk, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold', results='hide'}
cors <- c()
#for each timepoint
for(t in timepoints){
  #get rna-seq in this timepoint
  curSC <- pseudoBulk[intersect(rownames(pseudoBulk), rownames(mrna)), grep(pattern = t, colnames(pseudoBulk))]
  curBulk <- mrna[intersect(rownames(pseudoBulk), rownames(mrna)), grep(pattern = t, colnames(mrna))]
  
  #add current timepoint correlation to list of correlations
  cors <- c(cors, cor(curSC, curBulk))
}

#create bar plot of correlations
cors <- data.frame(Timepoint=timepoints, Pearson_R2=cors)
ggplot(cors, aes(x=Timepoint, y=Pearson_R2)) +
  geom_bar(stat = "identity") +
  scale_y_continuous(limits = c(0,1)) +
  labs(title = "Correlation between pseudo-bulk RNA-Seq data and bulk microarray data",
       subtitle="Pseudo-bulk created by summing expression across all cells")

#correlate across timepoints for each gene
cors <- unlist(lapply(intersect(rownames(pseudoBulk), rownames(mrna)), function(g)
  return(cor(unlist(pseudoBulk[g,]), unlist(mrna[g,])))))

hist(cors, breaks = 100, main = "Correlation of pseudo-bulk and bulk RNA across genes", ylab = "Genes", xlab = "Pearson R2")
```

# Relationship between scRNA and bulk mRNA

To investigate the ability to recover the scRNA data from the pseudo-bulk data, we start by clustering the scRNA data to identify the cell clusters followed by creating the following matrices:

-   Matrix $A$ of dimensions $timepoints X clusters$. (cell type proportions)
-   Matrix $X$ of dimensions $clusters X genes$. (cluster-averaged single-cell RNA data)
-   Matrix $Y$ of dimensions $timepoints X genes$. (pseudo-bulk RNA data)

We then attempt to re-create the single-cell matrix $X$ data by computing $Y = AX'$.

![](/Users/Ahmed/Documents/Emili_Lab/Aim%203/EMT%20Multi-omics/Plots/bulk%20decnovolution%20outline.png)

## Identify cell clusters

The cell states in our dataset are identified in an unsupervised manner based on similarity of gene expression profiles. All cells from all timepoints are pooled together for this analysis.

For data pre-processing, we remove the genes with low expression counts, retaining genes with a minimum of 3 counts in at least 3 cells. This removed 1,240 genes (13% of all genes). On average, each cell expressed \~3,600 genes after processing. [Seurat](https://www.nature.com/articles/nbt.4096) is then used to cluster the cells based on the 2,000 most variable genes.

The initial model defines 7 cell clusters at a Seurat resolution of 0.4. We intentionally begin with a number of clusters less than the number of timepoints to avoid creating an undetermined problem. The below UMAP plot visualizes the identified cell clusters.

```{r seuratClusterSixClusters, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold', results='hide'}
#filter out lowly-expressed genes (threshold is at least 3 counts in 3 cells - removed 1,240 genes)
scrna <- scrna[rowSums(scrna > 3) > 3,]

#Cluster with Seurat
# Initialize the Seurat object with the raw (non-normalized data).
seurat <- CreateSeuratObject(counts = scrna, project = "EMT")

#normalize data
seurat <- NormalizeData(seurat)

#find most variable genes
seurat <- FindVariableFeatures(seurat, selection.method = "vst", nfeatures = 2000)

#scale data
all.genes <- rownames(seurat)
seurat <- ScaleData(seurat, features = all.genes)

#PCA
seurat <- RunPCA(seurat, features = VariableFeatures(object = seurat))

#construct KNN using 10 PCs
seurat <- FindNeighbors(seurat, dims = 1:10)

#cluster cells
seurat <- FindClusters(seurat, resolution = 1.8, random.seed = 123)

#UMAP dimensionality reduction
seurat <- RunUMAP(seurat, dims = 1:10)

#plot UMAP
DimPlot(seurat, reduction = "umap", label = T) + ggtitle("Identified cell clusters")
```

## Changes in cell state composition over time

Since this dataset is investigating cells undergoing EMT, the cell population abundances are changing over time. The below figures visualize these proportion changes.

Note: this approach assumes the single-cell data accurately captures the sample heterogeneity. In practice, biased cell sampling upstream could lead to an inaccurate view of sample heterogeneity here.

```{r cellTypeProportions, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
## get proportion of each cell type at each timepoint ##

#create list of timepoints
timepoints <- colnames(mrna)

#create vector which contains the timepoint each cell comes from
cellTimepoints <- as.factor(gsub(pattern = '.*_', replacement = "", colnames(scrna)))

#initialize empty list
timeProportions <- list()

#iterate over timepoints 
for(t in timepoints){
  #get cells from this timepoint
  curTimepoint <- Idents(seurat)[which(cellTimepoints == t)]
  
  #list which will contain abundance for each population
  pops <- c()
  
  #iterate over clusters
  for(i in unique(Idents(seurat))){
    #no. of cells in this timepoint and also this cluster
    curMembers <- length(which(curTimepoint == i))
    
    #proportion
    pops <- c(pops, curMembers / length(curTimepoint))
  }
  
  #add to final list
  timeProportions[t] <- list(pops)
}

## stacked bar chart
#convert to dataframe for ggplot
forPlot <- data.frame(timeProportions)

#convert to long format for ggplot
forPlot <- melt(forPlot)
colnames(forPlot) <- c('Timepoint', 'Proportion')
forPlot$Proportion <- round(forPlot$Proportion, 2)

#add column for cluster name
forPlot$Cell_Type <- as.factor(rep(0:(length(unique(Idents(seurat)))-1), length(timepoints)))

#plot
ggplot(forPlot, aes(x = Timepoint, y = Proportion, fill = Cell_Type,
                    label = ifelse(Proportion > 0.015, paste0(Proportion*100,'%'), "") )) +
  geom_bar(stat = 'identity') + 
  geom_text(size = 2, position = position_stack(vjust = 0.5)) +
  ggtitle("Cell type composition in each timepoint")

#line chart
ggplot(forPlot, aes(x = as.numeric(Timepoint), y = Proportion, col = Cell_Type)) +
  geom_line() +
  scale_x_continuous(labels = timepoints, breaks = 1:8) +
  ggtitle("Cell type proportions across timepoints") +
  labs(x = 'Timepoint')
```

## Re-construct pseudo-bulk data from single-cell data

We now attempt to re-create the pseudo-bulk data ($Y$) from the single-cell data using the simple formula $Yâ€™ = AX$. The matrix $X$ was constructed by averaging the gene expression of each cluster. The matrix $A$ contains the number of cells from each cell cluster in each timepoint.

The below heatmaps show the pseudo-bulk data and the re-constructed data side-by-side, with the 8,528 genes in the same order. The heatmaps are scaled by row for visualization purposes. This reconstructed bulk data is then compared to the pseudo-bulk data in each timepoint. Correlations were also computed across the cross-timepoint measurements for each gene. The distributions of these correlations are shown below.

```{r keyFunctions}
#function to create pseudobulk from scRNA-Seq data
createPseudoBulk <- function(scrna){
  #create list of timepoints
  timepoints <- unique(gsub(pattern = ".*_", replacement = "", colnames(seurat)))
  
  #create single-cell pseudo bulk data
  pseudoBulk <- list()
  for(t in timepoints){
    #get single-cell rna-seq in this timepoint
    curSC <- scrna[, grep(pattern = t, colnames(scrna))]
    
    #create pseudo-bulk by summing values
    curPseudo <- rowSums(curSC)
    curPseudo[is.na(curPseudo)] <- 0
    
    #log-transform and quantile normalize
    #curPseudo <- log2(curPseudo+1)
    #curPseudo <- preprocessCore::normalize.quantiles(as.matrix(curPseudo))
    
    #add current timepoint pseudo-bulk to list 
    pseudoBulk[[t]] <- curPseudo
    rm(curPseudo, curSC)
  }
  pseudoBulk <- data.frame(pseudoBulk)
  rownames(pseudoBulk) <- rownames(scrna)
  return(as.matrix(pseudoBulk))
}

#create seurat object for downstream clustering
createSeurat <- function(scrna){
  # Initialize the Seurat object with the raw (non-normalized data).
  seurat <- CreateSeuratObject(counts = scrna, project = "EMT")
  
  #normalize data
  seurat <- NormalizeData(seurat)
  
  #find most variable genes
  seurat <- FindVariableFeatures(seurat, selection.method = "vst", nfeatures = 2000)
  
  #scale data
  all.genes <- rownames(seurat)
  seurat <- ScaleData(seurat, features = all.genes)
  
  #PCA
  seurat <- RunPCA(seurat, features = VariableFeatures(object = seurat))
  
  #construct KNN using 10 PCs
  seurat <- FindNeighbors(seurat, dims = 1:10)
  
  return(seurat)
}

#function to compute cell-type proportions 'A' given seurat-clustered data
computeCellProportions <- function(seurat){
  #construct matrix with number of cells from each type in each timepoint
  A <- as.data.frame(seurat@assays$RNA@counts) %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cluster = Idents(seurat)[variable], timepoint = gsub(".*_","", variable)) %>% 
    group_by(cluster, timepoint) %>% 
    summarize(count = length(unique(variable))) %>% 
    tidyr::spread(key = cluster, value = count, fill = 0) %>% 
    tibble::column_to_rownames("timepoint")
  
  #convert to matrix format
  A <- as.matrix(A)
  
  return(A)
}

#function to recover X from Y' by using X = pseudo-inverse of A * Y'
computeSCprofiles <- function(bulk, timeProportions){
  
  #predict scRNA matrix based on bulk and time proportions matrix
  #X_hat <- solve(t(A) %*% A) %*% (t(A) %*% Y_hat)
  sc <- pracma::pinv(timeProportions) %*% bulk
  
  return(sc)
}
```

```{r reconstructBulkRNA, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#construct matrix with cell-type proportions in each timepoint
#A <- t(data.frame(timeProportions))

#construct matrix with number of cells from each type in each timepoint
A <- do.call("rbind",(lapply(timepoints, function(t){
  #get cells from this timepoint
  curTimepoint <- as.character(Idents(seurat)[which(cellTimepoints == t)])
  
  #list which will contain number of cells for each population
  pops <- c()
  
  #iterate over clusters
  for(cluster in unique(Idents(seurat))){
    #no. of cells in this timepoint and also this cluster
    pops <- c(pops,length(which(curTimepoint == cluster)))
  }
  
  return(pops)
})))
rownames(A) <- timepoints

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cell = Idents(seurat)[variable]) %>% 
  group_by(gene, cell) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cell) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#reconstruct bulk matrix
Y_hat <- A %*% X

#construct pseudo-bulk RNA matrix
Y <- t(pseudoBulk)

#keep only the genes present in both datasets
overlapGenes <- intersect(colnames(Y), colnames(Y_hat))
Y <- Y[,overlapGenes]
Y_hat <- Y_hat[,overlapGenes]
X <- X[,overlapGenes]

#scale original matrices gene-wise
scaledY <- t(apply(Y, 2, scale))
scaledY_hat <- t(apply(Y_hat, 2, scale))
colnames(scaledY) <- colnames(scaledY_hat) <- timepoints

#visualize heatmap
ComplexHeatmap::Heatmap(scaledY, name = "Z-score",
                        cluster_columns = FALSE, cluster_rows = FALSE,
                        show_row_names = F, show_column_names = T, 
                        use_raster = T, row_title = "Genes",
                        column_title = "Original pseudo-bulk data")

ComplexHeatmap::Heatmap(scaledY_hat, name = "Z-score",
                        cluster_columns = FALSE, cluster_rows = FALSE,
                        show_row_names = F, show_column_names = T, 
                        use_raster = T, row_title = "Genes",
                        column_title = "Reconstructed bulk data")
```

```{r compareYtoYhat, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold', results='hide'}
cors <- c()
#for each timepoint
for(t in timepoints){
  #get rna-seq in this timepoint
  curSC <- Y_hat[t, intersect(colnames(Y_hat), colnames(Y))]
  curBulk <- Y[t, intersect(colnames(Y_hat), colnames(Y))]
  
  #add current timepoint correlation to list of correlations
  cors <- c(cors, cor(curSC, curBulk))
}

#create bar plot of correlations
cors <- data.frame(Timepoint=timepoints, Pearson_R2=cors)
ggplot(cors, aes(x=Timepoint, y=Pearson_R2)) +
  geom_bar(stat = "identity") +
  scale_y_continuous(limits = c(0,1)) +
  labs(title = "Correlation between reconstructed bulk RNA data and pseudo-bulk data",
       subtitle="Pseudo-bulk created by summing expression across all cells")

#correlation of genes
cors <- unlist(lapply(overlapGenes, function(g)
  return(cor(Y[,g], Y_hat[,g]))))

hist(cors, breaks = 100, main = "Correlation of reconstructed bulk RNA and pseudo-bulk RNA across genes", ylab = "Genes", xlab = "Pearson R2")
```

```{r bulkSimilarityToPseudo, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
seurat <- createSeurat(scrna)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
bulkRMSE <- pblapply(clusters, function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #reconstruct bulk matrix
  Y_hat <- A %*% X
  
  #create pseudo-bulk matrix
  Y <- t(createPseudoBulk(scrna))
  
  #make Y and Y' follow the same order
  Y <- Y[,order(colnames(Y))]
  Y_hat <- Y_hat[,order(colnames(Y_hat))]
  
  #find RMSE between Y and Y'
  rmse <- norm(Y - Y_hat, type = "f") / norm(Y, type = "f")
  
  return(rmse)
}, cl = 6)

plot(x = 5:15, y = unlist(bulkRMSE), type = 'b',
     main = "Relative RMSE between Y and Y' for different no. of clusters",
     ylab = "Relative RMSE", xlab = "Number of clusters")
```

## Re-construct single-cell data from pseudo-bulk data

In this section, we attempt to re-create the single-cell data from the pseudo-bulk data and the timepoint-specific cell cluster counts. Based on the formula $Y = AX$ outlined in previous sections, given the pseudobulk matrix Y and the timepoint-specific cell counts 'mixing' matrix A, we aim to compute X using the formula $X' = (A^TA)^{-1}(A^TY)$, which is essentially the pseudo-inverse of A multiplied by the pseudo-bulk Y. Recall that the pseudo-bulk is computed by summing up the counts of individual cells in each timepoint.

We vary the number of cell clusters by varying the *resolution* parameter in Seurat's clustering algorithm. We try this method for a number of clusters ranging between 5-15. For each given number of clusters, we solve the formula above to predict $X'$. We then compare this to the actual observed $X$ from the scRNA-Seq data, which is the per-cluster average of gene counts. The errors are reported as relative RMSE using the formula $||X - X'|| / ||X||$, where $||X||$ is the Frobenius norm of the matrix (the square root of the sum of squares of the matrix elements).

This process above is repeated once using $Y'$ as the bulk data, where $Y' = AX$ is computed first prior to computing $X'$ as above, and once using the actual bulk data in this dataset. The resultant cluster-RMSE relationships are shown in the below plot.

```{r predictSingleCellProfilesFromPseudoBulk, message=FALSE, results='hide', eval=F}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
seurat <- createSeurat(scrna)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors <- lapply(clusters, function(clust){
  #create pseudo-bulk matrix
  Y <- t(createPseudoBulk(scrna))
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find RMSE between X and X'
  rmse <- norm(X - X_hat, type = "f") / norm(X, type = "f")
  
  return(rmse)
})

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors2 <- lapply(clusters, function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #reconstruct bulk matrix
  Y_hat <- A %*% X
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y_hat, timeProportions = A)
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find RMSE between X and X'
  rmse <- norm(X - X_hat, type = "f") / norm(X, type = "f")
  
  return(rmse)
})

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors3 <- lapply(clusters, function(clust){
  #create bulk matrix
  Y <- t(mrna)
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #keep only the genes present in both datasets
  overlapGenes <- intersect(colnames(X), colnames(X_hat))
  X_hat <- X_hat[,overlapGenes]
  X <- X[,overlapGenes]
  
  #find RMSE between X and X'
  rmse <- norm(X - X_hat, type = "f") / norm(X, type = "f")
  
  return(rmse)
})

#show all RMSEs on one plot
allErrors <- do.call("rbind", list(unlist(errors), unlist(errors2), unlist(errors3) ))
rownames(allErrors) <- c("Pseudo-bulk Y", "Pseudo-bulk Y'", "Actual bulk")
saveRDS(allErrors, "/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/relative_RMSE_OLS.rds")
```

```{r  plotSCpredictionsRMSE, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
allErrors <- readRDS("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/relative_RMSE_OLS.rds")
matplot(t(allErrors), type = c("b"), pch = 1, col = 1:3,
        main = "Predicting single-cell profiles from bulk using OLS", xlab = "Number of clusters", ylab = "Relative RMSE", x = 5:15)
legend("topleft", legend = rownames(allErrors), col=1:3, pch=1) # optional legend
```


```{r visualizeXhatHeatmaps, results = 'hide', fig.width=16}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
seurat <- createSeurat(scrna)

#for(clust in clusters){

clust <- clusters["8"]
#cluster seurat object
seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)

#get number of clusters
nClust <- length(unique(Idents(seurat)))

#create matrix A with proportions of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cell = Idents(seurat)[variable]) %>% 
  group_by(gene, cell) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cell) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#create pseudo-bulk matrix
Y <- t(createPseudoBulk(scrna))

#reconstruct bulk matrix
Y_hat <- A %*% X

#create bulk matrix
bulk <- t(mrna)

#predict single-cell matrix X'
X_hat_Y <- computeSCprofiles(bulk = Y, timeProportions = A)
X_hat_Yhat <- computeSCprofiles(bulk = Y_hat, timeProportions = A)
X_hat_bulk <- computeSCprofiles(bulk = bulk, timeProportions = A)

#keep only the genes present in both datasets
overlapGenes <- intersect(colnames(X), colnames(X_hat_bulk))
X_hat_Y <- X_hat_Y[,overlapGenes]
X_hat_Yhat <- X_hat_Yhat[,overlapGenes]
X_hat_bulk <- X_hat_bulk[,overlapGenes]
X <- X[,overlapGenes]

#put into one table
allX <- do.call("rbind", list(X, X_hat_Y, X_hat_Yhat, X_hat_bulk))

#names of matrices
matrixNames <- c("X (8 clusters)", "X predicted from pseudobulk Y", "X predicted from re-created pseudobulk Y'", "X predicted from actual bulk")

#create heatmaps
ComplexHeatmap::Heatmap(t(allX),
                        name = "Counts", cluster_columns = FALSE, cluster_rows = T,
                        column_split = rep(matrixNames, each = nClust), use_raster = T, 
                        show_row_names = F, show_column_names = F, 
                        row_title = "Genes")

```

## Variation of gene expression within cell type across timepoints

```{r geneVarWithinCluster, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold', fig.width = 10}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
seurat <- createSeurat(scrna)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
geneCV <- pblapply(clusters, function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #find pairings where a cluster is not present in a timepoint
  pairings <- which(A==0, arr.ind = T) %>% 
    as.data.frame() %>% 
    mutate(row = rownames(A)[.$row], col = colnames(A)[.$col], key = paste(row, col, sep = "-")) %>% 
    .$key
  
  #compute coefficient of variation of genes in each cluster
  geneCV <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cluster = Idents(seurat)[variable], timepoint = gsub(".*_","", variable), key = paste(timepoint, cluster, sep = "-")) %>%
    filter(! key %in% pairings) %>% 
    group_by(cluster, gene, timepoint) %>% 
    summarise(counts = mean(value)) %>% 
    group_by(cluster, gene) %>% 
    summarise(cv = sd(counts) / mean(counts))
  
  return(mean(geneCV$cv, na.rm=TRUE))
}, cl = 6)


plot(x = 5:15, y = unlist(geneCV), type = 'b',
     main = "For a given cluster, how does its average expression of a gene change across timepoints?",
     ylab = "Average CV", xlab = "Number of clusters")
```
## Constraining the solution to be positive

The (Tsoucas et al)[<https://www.nature.com/articles/s41467-019-10802-z>] publication proposed a strategy for RNA deconvolution based on the OLS formulation we used in this report, with the addition of constraining the solution to be positive since there are no possible negative gene counts, and increasing the weight of cell types with low average expression levels. Since we typically have more cell types than time points, our problem is underdetermined and as such there are multiple possible solutions. In this section, we follow their strategy for constraining the solution to be non-negative.

We solve $\hat{X} = min_{x >= 0}||AX-Y||^2$ which algebraically is the same as solving $\hat{X} = min_{x >= 0}(-2Y^T A X + X^T A^T A X)$. The R function (solve.QP)[<https://www.rdocumentation.org/packages/quadprog/versions/1.5-8/topics/solve.QP>] from the *quadprog* package is used to solve this equation one gene at a time to estimate the expression profile at the cell-type level. This algorithm, however, expects a positive definite matrix. The matrix $A^TA$ is positive definite when $A$ has more rows than columns -- i.e., when the problem is a least-squares problem. When we have more clusters than timepoints then $A$ has more columns than rows, and so the matrix is not invertible, and so it is not positive definite. As a workaround, we use the function *nearPD()* to find the nearest positive matrix instead.

```{r solveQP, results='hide', eval=F}
#function to solve QP problem given A and Y
computeSCprofiles <- function(bulk, timeProportions){
  
  #iterate over genes
  sc <- apply(bulk, 2, function(gene){
    #define required matrices/vectors for the quadratic solver
    Dmat <- t(timeProportions) %*% timeProportions
    dvec <- t(timeProportions) %*% gene
    Amat <- diag(ncol(timeProportions))
    
    #find nearest positive-definite matrix for D to be able to solve OLS problem
    #Dmat <- as.matrix(Matrix::nearPD(Dmat)$mat)
    
    #add small scaling of the identitiy matrix to Dmat to make it positive definite
    #diag(Dmat) <- diag(Dmat)+1e-8
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat, dvec, Amat)
    return(qp$solution)
  })
  
  return(sc)
}

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors <- lapply(clusters, function(clust){
  #create pseudo-bulk matrix
  Y <- t(createPseudoBulk(scrna))
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find RMSE between X and X'
  rmse <- norm(X - X_hat, type = "f") / norm(X, type = "f")
  
  return(rmse)
})

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors2 <- lapply(clusters, function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #reconstruct bulk matrix
  Y_hat <- A %*% X
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y_hat, timeProportions = A)
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find RMSE between X and X'
  rmse <- norm(X - X_hat, type = "f") / norm(X, type = "f")
  
  return(rmse)
})

errors3 <- lapply(clusters, function(clust){
  #create bulk matrix
  Y <- t(mrna)
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #keep only the genes present in both datasets
  overlapGenes <- intersect(colnames(X), colnames(X_hat))
  X_hat <- X_hat[,overlapGenes]
  X <- X[,overlapGenes]
  
  #find RMSE between X and X'
  rmse <- norm(X - X_hat, type = "f") / norm(X, type = "f")
  
  return(rmse)
})
```

```{r plotQPresults}
allErrors <- readRDS("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/relative_RMSE_constrained_OLS.rds")
matplot(t(allErrors), type = c("b"), pch = 1, col = 1:3, xlab = "Number of clusters", ylab = "Relative RMSE",
        main = "Solving constrained OLS using nearest positive-definite matrix", x = 5:15)
legend("topleft", legend = rownames(allErrors), col=1:3, pch=1)
```

```{r visualizeXhatHeatmapsQP, results = 'hide', fig.width=16}
#function to solve QP problem given A and Y
computeSCprofiles <- function(bulk, timeProportions){
  
  #iterate over genes
  sc <- apply(bulk, 2, function(gene){
    #define required matrices/vectors for the quadratic solver
    Dmat <- t(timeProportions) %*% timeProportions
    dvec <- t(timeProportions) %*% gene
    Amat <- diag(ncol(timeProportions))
    
    #find nearest positive-definite matrix for D to be able to solve OLS problem
    #Dmat <- as.matrix(Matrix::nearPD(Dmat)$mat)
    
    #add small scaling of the identitiy matrix to Dmat to make it positive definite
    #diag(Dmat) <- diag(Dmat)+1e-8
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat, dvec, Amat)
    return(qp$solution)
  })
  
  return(sc)
}

#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
seurat <- createSeurat(scrna)

#for(clust in clusters){

clust <- clusters["9"]
#cluster seurat object
seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)

#get number of clusters
nClust <- length(unique(Idents(seurat)))

#create matrix A with proportions of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cell = Idents(seurat)[variable]) %>% 
  group_by(gene, cell) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cell) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#create pseudo-bulk matrix
Y <- t(createPseudoBulk(scrna))

#reconstruct bulk matrix
Y_hat <- A %*% X

#create bulk matrix
bulk <- t(mrna)

#predict single-cell matrix X'
X_hat_Y <- computeSCprofiles(bulk = Y, timeProportions = A)
X_hat_Yhat <- computeSCprofiles(bulk = Y_hat, timeProportions = A)
X_hat_bulk <- computeSCprofiles(bulk = bulk, timeProportions = A)

#keep only the genes present in both datasets
overlapGenes <- intersect(colnames(X), colnames(X_hat_bulk))
X_hat_Y <- X_hat_Y[,overlapGenes]
X_hat_Yhat <- X_hat_Yhat[,overlapGenes]
X_hat_bulk <- X_hat_bulk[,overlapGenes]
X <- X[,overlapGenes]

#put into one table
allX <- do.call("rbind", list(X, X_hat_Y, X_hat_Yhat, X_hat_bulk))

#names of matrices
matrixNames <- c("X (8 clusters)", "X predicted from pseudobulk Y", "X predicted from re-created pseudobulk Y'", "X predicted from actual bulk")

#create heatmaps
ComplexHeatmap::Heatmap(t(allX),
                        name = "Counts", cluster_columns = FALSE, cluster_rows = FALSE,
                        column_split = rep(matrixNames, each = nClust), use_raster = T, 
                        show_row_names = F, show_column_names = F, 
                        row_title = "Genes")

```

As an alternative to the *nearPD* function, we add a small scaling of the identity matrix ($10^{-9}$) to $A^T A$, which will make it positive definite and allow *solve.QP* to work. The result is shown below.

```{r visualizeXhatHeatmapsQP2, results = 'hide', fig.width=16}
computeSCprofiles <- function(bulk, timeProportions){
  
  #iterate over genes
  sc <- apply(bulk, 2, function(gene){
    #define required matrices/vectors for the quadratic solver
    Dmat <- t(timeProportions) %*% timeProportions
    dvec <- t(timeProportions) %*% gene
    Amat <- diag(ncol(timeProportions))
    
    #find nearest positive-definite matrix for D to be able to solve OLS problem
    #Dmat <- as.matrix(Matrix::nearPD(Dmat)$mat)
    
    #add small scaling of the identitiy matrix to Dmat to make it positive definite
    diag(Dmat) <- diag(Dmat)+1e-8
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat, dvec, Amat)
    return(qp$solution)
  })
  
  return(sc)
}

#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
seurat <- createSeurat(scrna)

#for(clust in clusters){

clust <- clusters["8"]
#cluster seurat object
seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)

#get number of clusters
nClust <- length(unique(Idents(seurat)))

#create matrix A with proportions of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cell = Idents(seurat)[variable]) %>% 
  group_by(gene, cell) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cell) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#create pseudo-bulk matrix
Y <- t(createPseudoBulk(scrna))

#reconstruct bulk matrix
Y_hat <- A %*% X

#create bulk matrix
bulk <- t(mrna)

#predict single-cell matrix X'
X_hat_Y <- computeSCprofiles(bulk = Y, timeProportions = A)
X_hat_Yhat <- computeSCprofiles(bulk = Y_hat, timeProportions = A)
X_hat_bulk <- computeSCprofiles(bulk = bulk, timeProportions = A)

#keep only the genes present in both datasets
overlapGenes <- intersect(colnames(X), colnames(X_hat_bulk))
X_hat_Y <- X_hat_Y[,overlapGenes]
X_hat_Yhat <- X_hat_Yhat[,overlapGenes]
X_hat_bulk <- X_hat_bulk[,overlapGenes]
X <- X[,overlapGenes]

#put into one table
allX <- do.call("rbind", list(X, X_hat_Y, X_hat_Yhat, X_hat_bulk))

#names of matrices
matrixNames <- c("X (8 clusters)", "X predicted from pseudobulk Y", "X predicted from re-created pseudobulk Y'", "X predicted from actual bulk")

#create heatmaps
ComplexHeatmap::Heatmap(t(allX),
                        name = "Counts", cluster_columns = FALSE, cluster_rows = FALSE,
                        column_split = rep(matrixNames, each = nClust), use_raster = T, 
                        show_row_names = F, show_column_names = F, 
                        row_title = "Genes")

```

## Predicting single-cell profiles using ridge regression

The condition number of $A^TA$ for the case where we have 8 single-cell clusters, i.e. as many clusters as there are timepoints, is noticeably high (15,828) compared to a smaller number of clusters which suggests that it is a near-singular matrix. This would explain the relatively high error in estimating the single-cell profiles. In an attemp to address this, we use ridge regression to estimate the single-cell profiles instead.

Ridge regression is similar to linear regression but with the addition of a regularization term $\lambda$. A range of values for $\lambda$ are tested to decide on the optimal one. The R package *glmnet* is used for this task. We solve the problem by fitting a ridge regression model to each gene. The full procedure is outlined below:

[**Input:**]{.ul} Number of clusters *N,* Single-cell expression matrix *SC*

[**Procedure:**]{.ul}

1.  Cluster single-cell matrix *SC into N* clusters using *Seurat*

2.  Construct cluster \* gene matrix ***X*** by computing the average expression of each gene in each cluster

3.  Construct timepoint \* cluster mixing matrix ***A*** by counting the number of cells in each cluster in each timepoint

4.  Construct timepoint \* gene pseudobulk matrix ***Y*** using the formula $Y = AX$

5.  Define $LambdaSet = \{10^0,10^{1}, 10^{2}, 10^{3}, 10^{4}, 10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}\}$

6.  For each column of *Y,* denoted as *y* :

7.  Fit ridge regression model *Beta* using the function `Beta = glmnet(x = A, y = y, lambda = LambdaSet, alpha = 0)`

8.  For each column in *X*, denoted as *x* :

-   For each lambda *L* :

1.  Compute *x'* = column *L* of *Beta*

2.  Compute error in predicting *x* as $||x - x'||^2$

3.  Accumulate error for each lambda as the sum of errors across genes

4.  Select lambda with minimum accumulated error

```{r ridgeRegression, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
seurat <- createSeurat(scrna)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
errors <- pblapply(clusters, function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #set of lambdas to test for ridge regression
  lambdaSet <- 10^(4:-4)
  
  #iterate over genes (columns of Y) and fit regression model based on counts of clusters in each timepoint
  ridge <- apply(Y, 2, function(y){
    #fit ridge regression model
    Beta <- glmnet(x = A, y = y,  lambda = lambdaSet, alpha = 0)$beta
    
    #set column names to indicate lambda values
    colnames(Beta) <- lambdaSet
    
    #return estimated x'
    return(Beta)
  })
  
  #summarize predictions for each lambda into separate tables
  X_hat <- lapply(seq_along(lambdaSet), function(lambda){
    return(do.call("cbind", lapply(ridge, `[`, , lambda)))
  })
  names(X_hat) <- lambdaSet
  
  #compute squared error between X and X' for each lambda
  error <- lapply(X_hat, function(cur_X_hat){
    return(sum(colSums(abs(X - cur_X_hat))^2))
  })
  
  #convert error values to matrix (one column per lambda)
  error <- do.call("cbind", error)
  
  return(error)
}, cl = 6)

#combine all the errors into one table
errors <- do.call("rbind", errors)
rownames(errors) <- names(clusters)

#convert to long format for plotting
errors <- reshape2::melt(errors)
colnames(errors) <- c("Number_of_clusters", "Lambda", "Sum_squared_error")
errors$Number_of_clusters <- as.factor(errors$Number_of_clusters)

#plot
ggplot(errors, aes(x = log(Lambda), y = Sum_squared_error, col = Number_of_clusters)) +
  geom_line() + geom_point() +
  labs(title = "Error of estimating single-cell profiles using ridge regression across values of lambda",
       subtitle = "Each color represents a pre-determined number of cell clusters")
```

For each number of clusters, we select the lambda which led to the minimal sum squared error when comparing the predicted single-cell profiles to the actual ones. Those selected lambdas are shown below.

```{r ridgeRegressionBestLambdas}
#set of lambdas to test for ridge regression
lambdaSet <- 10^(4:-4)

#for each number of clusters, find optimal lambda
bestLambdas <- errors %>% 
  group_by(Number_of_clusters) %>%
  summarise(best_lambda = lambdaSet[which(Sum_squared_error == min(Sum_squared_error))])

#show table with best lambda values
kable(bestLambdas, caption = "Ridge regression - Lambda values that minimize error") %>%
  kable_styling(latex_options = c("striped", "hold_position")) %>% 
  row_spec(row = 0, bold = T, color = "white", background = "gray")
```

#### Comparing ridge regression to OLS

```{r compareRidgeRegressionToOLS, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold', fig.width = 12}
#predict X' using optimal lambda values for ridge regression
X_hat_ridge <- pblapply(names(clusters), function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #optimal lambda
  lambda <- unlist(bestLambdas[as.character(bestLambdas$Number_of_clusters) == clust, "best_lambda"])
  
  #iterate over genes (columns of Y) and fit regression model based on counts of clusters in each timepoint
  ridge <- apply(Y, 2, function(y){
    #fit ridge regression model
    Beta <- glmnet(x = A, y = y,  lambda = lambda, alpha = 0)$beta
    
    #return estimated x'
    return(Beta)
  })
  
  #combine predictions of all genes into one matrix
  X_hat <- do.call("cbind", ridge)
  colnames(X_hat) <- names(ridge)
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find RMSE between X and X'
  rmse <- norm(X - X_hat, type = "f") / norm(X, type = "f")
  
  return(rmse)
  
}, cl = 6)

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
X_hat_ols <- pblapply(clusters, function(clust){
  #create pseudo-bulk matrix
  Y <- t(createPseudoBulk(scrna))
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #predict single-cell matrix X'
  X_hat <- computeSCprofiles(bulk = Y, timeProportions = A)
  
  #construct matrix with cell-type expression of each gene
  X <- scrna %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #make X and X' follow the same order
  X <- X[,order(colnames(X))]
  X_hat <- X_hat[,order(colnames(X_hat))]
  
  #find RMSE between X and X'
  rmse <- norm(X - X_hat, type = "f") / norm(X, type = "f")
  
  return(rmse)
}, cl = 6)

#combine all the errors into one table
errors <- do.call("cbind", list(do.call("rbind", X_hat_ridge), do.call("rbind", X_hat_ols)))
rownames(errors) <- names(clusters)
colnames(errors) <- c("Ridge regression", "OLS")

#convert to long format for plotting
errors <- reshape2::melt(errors)
colnames(errors) <- c("Number_of_clusters", "Method", "Relative RMSE")

#plot
ggplot(errors, aes(x = Number_of_clusters, y = `Relative RMSE`, col = Method)) +
  geom_line() + geom_point() +
  scale_x_continuous(breaks = 5:15) +
  labs(title = "Relative RMSE of estimating single-cell profiles for different numbers of clusters")
```
```{r visualizeXhatHeatmapsForRidgeAndOLS, results = 'hide', fig.width=16}
#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#create seurat object
seurat <- createSeurat(scrna)

#scenario with 8 clusters
clust <- clusters["8"]

#cluster seurat object
seurat <- FindClusters(seurat, resolution = clust, random.seed = 123)

#get number of clusters
nClust <- length(unique(Idents(seurat)))

#create matrix A with proportions of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cell = Idents(seurat)[variable]) %>% 
  group_by(gene, cell) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cell) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.matrix() %>% 
  t()

#reconstruct bulk matrix
Y_hat <- A %*% X

#predict single-cell matrix X' using OLS
X_hat_ols <- computeSCprofiles(bulk = Y_hat, timeProportions = A)

#optimal lambda
lambda <- unlist(bestLambdas[as.character(bestLambdas$Number_of_clusters) == names(clust), "best_lambda"])

#iterate over genes (columns of Y) and fit regression model based on counts of clusters in each timepoint
ridge <- pbapply(Y, 2, function(y){
  #fit ridge regression model
  Beta <- glmnet(x = A, y = y,  lambda = lambda, alpha = 0)$beta
  
  #return estimated x'
  return(Beta)
}, cl = 6)

#combine predictions of all genes into one matrix
X_hat_ridge <- do.call("cbind", ridge)
colnames(X_hat_ridge) <- names(ridge)

#keep only the genes present in all datasets
overlapGenes <- intersect(colnames(X), colnames(X_hat_ols))
X_hat_ols <- X_hat_ols[,overlapGenes]
X_hat_ridge <- X_hat_ridge[,overlapGenes]
X <- X[,overlapGenes]

#put into one table
allX <- as.matrix(do.call("rbind", list(X, X_hat_ols, X_hat_ridge)))

#names of matrices
matrixNames <- c("X (8 clusters)", "X predicted using OLS", "X predicted using Ridge Regression")

#create heatmaps
ComplexHeatmap::Heatmap(t(allX),
                        name = "Counts", cluster_columns = FALSE, cluster_rows = T,
                        column_split = rep(matrixNames, each = nClust), use_raster = T, 
                        show_row_names = F, show_column_names = F, 
                        row_title = "Genes")

```

