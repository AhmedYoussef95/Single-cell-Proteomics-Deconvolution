---
title: "Deconvolution of proteomics data using scRNA-Seq"
subtitle: "Validating computationally-predicted proteomes using single-cell proteomics"
author: "Ahmed Youssef"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: pdf_document
urlcolor: blue
toc: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, results = 'hide')

#required packages
library(data.table) #reading in large files quickly
library(kableExtra) #for tables
library(dplyr) #data wrangling
library(magrittr) #data wrangling
library(reshape2) #data wrangling
library(tidyr) #data wrangling
library(tibble) #data wrangling
library(ggplot2) #plots
library(patchwork) #plot figures plots on same plot
library(ComplexHeatmap) #heatmaps
library(pheatmap) #heatmaps
library(Seurat) #scRNA clustering
library(VennDiagram) #venn diagram
library(uwot) #UMAP
library(pracma) #distance between matrices
library(Matrix) #matrix operations
library(quadprog) #solving constrained OLS problem
library(glmnet) #ridge regression
library(pbapply) # parallel operations
library(ggpubr) #correlation plots annotation
library(gridExtra) #arrange multiple non-ggplot2 plots in one figure
library(WGCNA) #quick correlation computation
```

# Introduction

The fundamental unit of all living organisms is the cell, and recent technological advances have granted us unprecedented opportunities to study life at this principal level. Proteins, through their networks of interactions, carry out most of the vital biological processes governing cellular functions, yet remain largely unexplored in the single-cell space, representing crucial gaps in our knowledge of cell biology. Single-cell RNA sequencing (scRNA-Seq) has emerged in recent years as a powerful technology for defining cell states on a large scale, enabling breakthroughs in many areas of cell biology research, and raising the question of whether it can be used for making inferences at the protein level. **In this report, we explore the deconvolution of bulk proteomics data to the single-cell level using scRNA-Seq data and validate the results using single-cell proteomics data.**

# Experiment summary

Epithelial-to-mesenchymal transition (EMT) is a biological process in which epithelial cells gradually lose their adhesion and transition into mesenchymal cells. As one of the hallmarks of cancer progression, it is one of the long-standing interests of the biomedical research community. Towards profiling this process, protein and RNA samples were extracted from cells at 8 different timepoints during EMT and multiple layers of omics data were generated. These omics layers include proteomics, transcriptomics, phosphoproteomics, secretome, exosome among others. A pre-print with more details on the experiment and generated data can be found on bioRxiv [here (Paul et al, 2021)](https://www.biorxiv.org/node/2018285.external-links.html). This report is interested in the scRNA-Seq and proteomics datasets generated in this study.

# Rationale

Bulk proteomics data gives a view of the aggregated protein abundance from all cell types within a sequenced sample. Using single-cell data, derived from the same samples, we can investigate the sample heterogeneity by estimating proportions of cell types within the bulk sample. We cannot reliably use these proportions to directly estimate the contribution of each population to each gene/protein's expression at the bulk-level however, since there is low correlation between RNA and protein levels of the same genes due to multiple biological and technical factors, such as alternative splicing and post-translational modifications. Leveraging the timepoints present in this dataset, which conveniently show shifts in cell state proportions across time, we can instead combine changes in cell state proportions with the corresponding changes in bulk-level protein abundance as suggestive of relationships between specific cell states and protein levels. This information can then potentially be used to estimate the contribution of individual cell states to the bulk proteomics measurements.

# Data summary - Proteomics

The bulk proteomics data was generated in the Emili Lab using standard tandem mass-spectrometry. Summary of the dataset follows:

-   6,967 proteins
-   10 different timepoints
-   Three replicates

The average intensity across replicates was computed for each protein in each timepoint.Timepoints 3 and 9 were removed since they are not present in the scRNA data.

```{r readProteome, fig.height = 3}
#read in '2D' proteomics data and average replicates in each timepoint
proteome <- fread("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/proteinGroups_Prot.txt") %>% 
  as.data.frame() %>% 
  .[, c("Gene names", grep("Reporter intensity corrected .* [A-C]", colnames(.), value = TRUE))] %>% 
  magrittr::set_names(c("Gene", gsub("Reporter intensity corrected ", "T", colnames(.)[-1]))) %>% 
  melt() %>% 
  #average replicates
  mutate(variable = gsub(" .*","", variable)) %>% 
  group_by(Gene, variable) %>% 
  summarize(intensity = mean(value)) %>% 
  #convert to wide format
  dcast(Gene ~ variable) %>% 
  magrittr::set_rownames(.$Gene) %>% 
  #remove timepoints that are not present in scRNA data
  select(-c(1, 5, 11)) %>%
  as.matrix()

#normalize data such that each timepoint sums to 1
#proteome <- apply(proteome, 2, function(x) return(x/sum(x)))
```

# Data summary - scRNA-Seq

The bulk proteomics data was generated in the Emili Lab using standard mass-spectrometry. Summary of the dataset follows:

-   9,785 genes
-   1,913 cells (\~200 cells per timepoint)
-   8 different timepoints

Prior to this summation, genes with zero variance as well as those with non-zero counts in less than 5% of all cells were removed. This removed 17 genes (0.2% of all genes). The data was also normalized such that each cell sums to 1.

```{r readSCRNA}
#read in data
scrna <- data.frame(fread("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/scRNAseq_filt_dat.txt", stringsAsFactors = FALSE)) %>% 
  magrittr::set_rownames(.$Gene.names) %>% 
  select(-1)

#compute variance of genes
geneVar <- apply(scrna, 1, var) %>% 
  .[. > 0]

#remove genes with zero variance
scrna <- scrna[names(geneVar),]

#get percentage of cells each gene is expressed in
cellsPerGene <- apply(scrna, 1, function(x) sum(x > 0) / length(x)) %>% 
  .[. >= 0.05]

#remove genes expressed in less than 5% of all cells
scrna <- scrna[names(cellsPerGene),]

#filter out lowly-expressed genes (threshold is at least 3 counts in 3 cells - removed 1,240 genes)
scrna <- scrna[rowSums(scrna > 3) > 3,]

#group scRNA data by cell and normalize to sum to 1
scrna <- scrna %>% 
  as.data.frame() %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  group_by(variable) %>% 
  mutate(value = value / sum(value)) %>%
  dcast(gene ~ variable) %>% 
  magrittr::set_rownames(.$gene) %>% 
  select(-1) %>% 
  as.data.frame()

#get number of cells in each timepoint
cellsPerTimepoint <- table(gsub(".*_","", colnames(scrna)))
```


# Approach

Prior to making inferences from the proteomics data, we first investigate the ability to recover the scRNA data from the bulk data at the RNA-level where we have the true single-cell profiles to compare against. The underlying principle of our model is that the bulk data is the  summation of the single-cell data, which can be represented using the simple formula $Bulk = Number\_of\_cells * Single\_cell\_expression$, for which we will use the notation $Y = AX$ throughout this report. The figure below shows a graphical representation of this model.


![Schematic of single-cell deconvolution model](/Users/Ahmed/Documents/Emili_Lab/Aim%203/EMT%20Multi-omics/Plots/bulk%20decnovolution%20outline.png) 
The five main steps underlying our approach are outlined below:

1) ***Clustering***:  The cell states in our dataset are identified in an unsupervised manner based on similarity of gene expression profiles. All cells from all timepoints are pooled together for this analysis. For data pre-processing, we remove the genes with low expression counts, retaining genes with a minimum of 3 counts in at least 3 cells. This removed 1,240 genes (13% of all genes). On average, each cell expressed ~3,600 genes after processing. [Seurat](https://www.nature.com/articles/nbt.4096) is then used to cluster the cells with their default workflow based on the 2,000 most variable genes. We tested our approach on different pre-defined numbers of clusters in our analysis.

2) ***Construct cell type proportions matrix A***: The timepoint \* cluster mixing matrix $A$ is constructed by counting the numbers of cell from each cluster in each timepoint.

3) ***Construct cell cluster matrix X***: The cluster \* gene matrix $X$ is constructed by averaging the gene expression of each cluster.

4) ***Create pseudo-bulk matrix Y***: Construct timepoint \* gene pseudobulk matrix $Y$ using the formula $Y = AX$.

5) ***Predicting single-cell profiles using ridge regression***: Re-create the single-cell data from the pseudo-bulk data $Y$ and the timepoint-specific cell cluster counts $A$ based on the formula $Y = AX$ by using the formula $X' = (A^TA)^{-1}(A^TY)$, which is essentially the pseudo-inverse of $A$ multiplied by the pseudo-bulk $Y$. To achieve this, we solve the non-negative constrained equation $\hat{X} = min_{x >= 0}(-2Y^T A X + X^T A^T A X)$ after adding a ridge penalty $\lambda$ to the diagonal of the matrix $A^TA$. The R function [*solve.QP*](https://www.rdocumentation.org/packages/quadprog/versions/1.5-8/topics/solve.QP) from the [*quadprog*](https://cran.r-project.org/web/packages/quadprog/quadprog.pdf) package is used to solve this equation one gene at a time to estimate the expression profile at the cell-type level. To decide on the optimal value for the parameter $\lambda$, we test a range of 21 values between $1^{-10}$ to $1^{10}$ for each gene and each number of clusters. For each value of $\lambda$, we compute the relative error in estimating each gene's single-cell profile as a measure of the accuracy of the predicted single-cell profile. The $\lambda$ that leads to the minimal error is selected as the optimal value for the corresponding gene. 

To summarize, the following three matrices represent the key variables in our model:

-   Matrix $A$ of dimensions $timepoints * clusters$. (cell type counts in each timepoint)
-   Matrix $X$ of dimensions $clusters * genes$. (cluster-averaged single-cell data)
-   Matrix $Y$ of dimensions $timepoints * genes$. (bulk data)

We then attempt to re-create the single-cell matrix $X'$ data by computing $Y = AX'$.

```{r keyFunctions}
#function to create pseudobulk from scRNA-Seq data
createPseudoBulk <- function(scrna){
  #create list of timepoints
  timepoints <- unique(gsub(pattern = ".*_", replacement = "", colnames(scrna)))
  
  #create single-cell pseudo bulk data
  pseudoBulk <- list()
  for(t in timepoints){
    #get single-cell rna-seq in this timepoint
    curSC <- scrna[, grep(pattern = t, colnames(scrna))]
    
    #create pseudo-bulk by summing values
    curPseudo <- rowSums(curSC)
    curPseudo[is.na(curPseudo)] <- 0
    
    #log-transform and quantile normalize
    #curPseudo <- log2(curPseudo+1)
    #curPseudo <- preprocessCore::normalize.quantiles(as.matrix(curPseudo))
    
    #add current timepoint pseudo-bulk to list 
    pseudoBulk[[t]] <- curPseudo
    rm(curPseudo, curSC)
  }
  pseudoBulk <- data.frame(pseudoBulk)
  rownames(pseudoBulk) <- rownames(scrna)
  return(as.matrix(pseudoBulk))
}

#create seurat object for downstream clustering
createSeurat <- function(counts){
  # Initialize the Seurat object with the raw (non-normalized data).
  seurat <- CreateSeuratObject(counts = counts, project = "EMT")
  
  #normalize data
  seurat <- NormalizeData(seurat)
  
  #scale data
  all.genes <- rownames(seurat)
  seurat <- ScaleData(seurat, features = all.genes)
  
  #find most variable genes
  seurat <- FindVariableFeatures(seurat, selection.method = "vst", nfeatures = 2000)
  
  #PCA on most variable genes
  seurat <- RunPCA(seurat, features = VariableFeatures(object = seurat))
  
  #construct KNN using 10 PCs
  seurat <- FindNeighbors(seurat, dims = 1:10)
  
  return(seurat)
}

#function to compute cell-type proportions 'A' given seurat-clustered data
computeCellProportions <- function(seuratObject){
  #construct matrix with number of cells from each type in each timepoint
  A <- as.data.frame(seuratObject@assays$RNA@counts) %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cluster = Idents(seuratObject)[variable], timepoint = gsub(".*_","", variable)) %>% 
    group_by(cluster, timepoint) %>% 
    summarize(count = length(unique(variable))) %>% 
    tidyr::spread(key = cluster, value = count, fill = 0) %>% 
    tibble::column_to_rownames("timepoint")
  
  #convert to matrix format
  A <- as.matrix(A)
  
  return(A)
}

#function to recover X from Y' by using X = pseudo-inverse of A * Y'
computeSCprofiles <- function(bulk, timeProportions){
  
  #predict scRNA matrix based on bulk and time proportions matrix
  #X_hat <- solve(t(A) %*% A) %*% (t(A) %*% Y_hat)
  sc <- pracma::pinv(timeProportions) %*% bulk
  
  return(sc)
}

#combine ridge regression with a non-negative constraint
constrainedRidgeRegression <- function(bulk, timeProportions, lambda){
  #define required matrices/vectors for the quadratic solver
  Dmat <- t(timeProportions) %*% timeProportions
  Amat <- diag(ncol(timeProportions))
  
  #add small scaling of the identity matrix to Dmat to regularize prediction
  Dmat <- Dmat + lambda*diag(nrow(Dmat))
  
  #to avoid overflow cause by large values, scale Dmat and dvec
  scalingFactor <- norm(Dmat, "2")
  
  #iterate over genes
  sc <- apply(bulk, 2, function(gene){
    #define required matrices/vectors for the quadratic solver
    dvec <- t(timeProportions) %*% gene
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat / scalingFactor, dvec / scalingFactor, Amat)
    return(qp$solution)
  })
  
  return(sc)
}

#constrained ridge regression with gene-level lambdas
perGeneConstrainedRidgeRegression <- function(bulk, timeProportions, optimalLambdas){
  #subset bulk to include genes for which optimal lambdas are present
  bulk <- bulk[,colnames(bulk) %in% optimalLambdas$Gene]
  
  #define required matrices/vectors for the quadratic solver
  Dmat <- t(timeProportions) %*% timeProportions
  Amat <- diag(ncol(timeProportions))
  
  #iterate over genes
  sc <- lapply(colnames(bulk), function(gene){
    #find optimal lambda for this gene
    lambda <- as.numeric(unlist(optimalLambdas[optimalLambdas$Gene == gene,"Lambda"]))
    
    #get expression values for this gene
    geneAbundances <- bulk[,gene]
    
    #define required matrices/vectors for the quadratic solver
    dvec <- t(timeProportions) %*% geneAbundances
    
    #add small scaling of the identity matrix to Dmat to regularize prediction
    Dmat <- Dmat + lambda*diag(nrow(Dmat))
    
    #to avoid overflow cause by large values, scale Dmat and dvec
    scalingFactor <- norm(Dmat, "2")
    
    #solve quadratic equation
    qp <- quadprog::solve.QP(Dmat / scalingFactor, dvec / scalingFactor, Amat)
    return(qp$solution)
  }) %>% 
    do.call("cbind",.)
  colnames(sc) <- colnames(bulk)
  
  return(sc)
}
```

# Deconvolution of bulk proteomics data using scRNA-defined cell clusters

In this section of the report, we apply the deconvolution algorithm outlined above to the bulk proteomics data with 11 Seurat-defined cell clusters from the scRNA-Seq data. We furthermore highlight a set of 80 hallmark genes associated with EMT from the [MSigDB database](https://www.gsea-msigdb.org/gsea/msigdb/cards/HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION.html). 

#### Seurat clustering results

```{r seurat11clusters, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#create seurat object
seurat <- createSeurat(scrna)

#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.2,0.3,0.4,0.5,0.7,0.9,1.0,1.32,1.35,1.4,1.8), 5:15)

#determine number of seurat clusters
clust <- "11"

#cluster seurat object
seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)

#UMAP dimensionality reduction
seurat <- RunUMAP(seurat, dims = 1:10)

#plot UMAP
DimPlot(seurat, reduction = "umap", label = T) + ggtitle("Seurat-identified cell clusters")

#create matrix A with counts of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#convert cell type counts to proportions
timeProportions <- data.frame(apply(A, 1, function(x) return(x/sum(x))))

#convert to long format for ggplot
timeProportions <- melt(timeProportions)
colnames(timeProportions) <- c('Timepoint', 'Proportion')
timeProportions$Proportion <- round(timeProportions$Proportion, 2)

#add column for cluster name
timeProportions$Cell_State <- as.factor(rep(0:(length(unique(Idents(seurat)))-1), ncol(proteome)))

#plot
ggplot(timeProportions, aes(x = Timepoint, y = Proportion, fill = Cell_State,
                            label = ifelse(Proportion > 0.015, paste0(Proportion*100,'%'), "") )) +
  geom_bar(stat = 'identity') + 
  geom_text(size = 2, position = position_stack(vjust = 0.5)) +
  ggtitle("Cell state composition in each timepoint")
```
#### Predicted single-cell profiles

```{r deconvoluteProteomicsIndividualGeneLambdas, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold', fig.height = 12}
#read in all scores for all values of lambda and all genes
geneLambdas <- readRDS("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/geneLambdas.rds")

#subset table to optimal values for current clustering
optimalLambdas <- geneLambdas %>% 
  group_by(Gene) %>% 
  filter(Number_of_clusters == clust) %>% 
  filter(Relative_error == min(Relative_error)) %>% 
  filter(!is.infinite(Relative_error))

#cluster seurat object
seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)

#create matrix A with proportions of cell clusters in each timepoint
A <- computeCellProportions(seurat)

#construct matrix with cell-type expression of each gene
X <- scrna %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cluster = Idents(seurat)[variable]) %>% 
  group_by(gene, cluster) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cluster) %>% 
  magrittr::set_rownames(.$gene) %>% 
  dplyr::select(-1) %>% 
  as.matrix() %>% 
  t()

#bulk proteomics matrix
bulk_proteomics <- t(proteome)

#reconstruct pseudo-bulk matrix
Y <- A %*% X

#list of genes detected in each dataset
allGenes <- list("scRNA-Seq" = rownames(scrna), "Proteomics" = rownames(proteome))

#list of overlapping genes
overlapGenes <- Reduce(intersect, allGenes)

#retain overlapping genes only in the datasets
X <- X[,overlapGenes]
Y <- Y[,overlapGenes]
bulk_proteomics <- bulk_proteomics[,overlapGenes]

#re-scale proteomics data to be comparable to RNA
bulk_proteomics <- bulk_proteomics / (sum(bulk_proteomics) / sum(Y))

#predict single-cell profiles using constrained ridge regression
prediction <- perGeneConstrainedRidgeRegression(bulk = bulk_proteomics, timeProportions = A, optimalLambdas = optimalLambdas)

#remove zero variance genes
prediction <- prediction[,unlist(apply(prediction, 2, var)) > 0]

#add cluster labels
rownames(prediction) <- paste0("cluster_", 0:(length(unique(Idents(seurat)))-1))

#rename clusters based on classification
rownames(prediction) <- c(paste0(rownames(prediction)[1:3],"_M"), paste0(rownames(prediction)[4:7],"_E"),
                          "cluster_7_M", "cluster_8_E", "cluster_9_M", "cluster_10_E")

#reorder prediction to go E -> M
prediction <- prediction[c(grep("E", rownames(prediction), value = TRUE), grep("M", rownames(prediction), value = TRUE)) , ]

#hallmark genes to keep
#read in EMT hallmark genes
hallmark <- read.delim("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/hallmark_emt_geneset.txt", header = F)[,1]
hallmarkOverlap <- intersect(overlapGenes, hallmark)
prediction_hallmark <- prediction[,intersect(colnames(prediction), hallmarkOverlap)]

#save locally
#write.csv(t(prediction), "/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/sc_predictions_11_clusters.csv")
#write.csv(t(prediction_hallmark), "/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/sc_hallmark_predictions_11_clusters.csv")


#subset of known epithelial/mesenchymal markers
E <- c("SDC1", "RHOB", "GPC1", "SDC4")
M <- c("VIM", "FN1", "PLOD1", "FLNA")

#visualize
pheatmap(t(prediction), scale = "row", show_rownames = F, cluster_cols = F, main = "Single-cell proteomics prediction - 11 cell clusters - all genes")
pheatmap(t(prediction_hallmark), scale = "row", show_rownames = T, cluster_cols = F, main = "Single-cell proteomics prediction - 11 cell clusters - EMT hallmark genes", cluster_rows = T)
```

# Deconvolution of bulk proteomics data using single-cell proteomics-defined cell clusters

As an external benchmark of our method, the Nikolai Slavov group at Northeastern University shared with us a MS-derived single-cell proteomics dataset from cells undergoing EMT. Their experimental setup consists of three timepoints, and the data has 1,827 genes x 420 cells, out of which 1,064 genes, including 27 of the [EMT hallmark genes]((https://www.gsea-msigdb.org/gsea/msigdb/cards/HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION.html)), were also detected in our own data. 

## Protein overlap

```{r vennProteinOverlap, fig.height = 4, fig.width = 7}
#non-normalized protein values
scProt <- read.delim("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/Slavov sc proteomics/slavov_sc_proteomics_emt_raw_protein.txt", row.names = 1)

#read in UniProt ID mappings
uniprot <- fread("/Users/Ahmed/Documents/Emili_Lab/PPI Databases/UniProt ID mapping/uniprot_human_mapping.csv")
uniprot <- setNames(uniprot$gene_symbol, uniprot$uniprot)

#map UniProt IDs to gene symbols in sc proteomics dataset
rownames(scProt) <- make.unique(gsub(pattern = "-.*", "", rownames(scProt)))
mappings <- uniprot[rownames(scProt)]
scProt <- scProt[!is.na(mappings),]
rownames(scProt) <- make.unique(mappings[!is.na(mappings)])

#list of genes detected in each dataset
allProts <- list("scRNA-Seq" = rownames(scrna), "Bulk Proteomics" = rownames(proteome), "SC Proteomics" = rownames(scProt))

#venn diagram showing overlap of detected proteins
ggvenn::ggvenn(data = allProts, columns = c("scRNA-Seq", "Bulk Proteomics", "SC Proteomics"))
```


```{r scOnlyProteinsEnrichment, eval=F}
#find proteins exclusive to sc proteomics
scOnlyProts <- allProts$`SC Proteomics`[!(allProts$`SC Proteomics` %in% allProts$`Bulk Proteomics`) & !(allProts$`SC Proteomics` %in% allProts$`scRNA-Seq`)]

#pathway enrichment
enrich <- enrichR::enrichr(genes = scOnlyProts, databases = c("GO_Biological_Process_2021", "GO_Cellular_Component_2021", "GO_Molecular_Function_2021")) %>% 
  do.call("rbind", .) %>% 
  filter(Adjusted.P.value < 0.05) %>% 
  select(Term, Overlap, Genes)

kable(enrich, caption = "Significantly-enriched pathways among proteins detected exclusively by sc proteomics") %>%
  kable_styling(latex_options = c("striped", "hold_position")) %>% 
  row_spec(row = 0, bold = T, color = "white", background = "gray")
```

## Data Pre-processing

For all downstream analysis, only the set of ~1,000 genes that overlap between the single-cell proteomics, bulk proteomics, and scRNA-Seq datasets are retained. 65% of the original single-cell proteomics matrix consists of missing values. The [Specht et al](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-021-02267-5#Sec16) publication proposed a strategy to impute the missing values by k-nearest neighbor imputation (k = 3) using Euclidean distance as a similarity measure between the cells. Briefly, for a given missing value, the expression of that gene in that cell is taken as the mean of it’s expression in the 3 most similar cells for which it’s expression is present. Similar to scRNA-Seq pre-processing strategies, the data was also normalized such that each cell sums to 1 after imputation. The final matrix consists of 1,064 proteins and 420 cells.

```{r imputationFunction}
#imputation function (originally called hknn) modified from https://github.com/SlavovLab/SCoPE2/blob/master/code/functions_parameters.R
sc_imputation<-function(dat, k, distanceMetric = c("euclidean", "pearson")){
  
  # Create a copy of the data, NA values to be filled in later
  dat <- as.matrix(dat)
  dat.imp <- dat
  
  # Calculate similarity metrics for all column pairs
  if(distanceMetric == "euclidean"){
    dist.mat <- as.matrix(dist(t(dat)))
  }
  if(distanceMetric == "pearson"){
    dist.mat <- 1 - cor(dat, use = "pairwise.complete.obs")
  }
  
  # Column names of the similarity matrix, same as data matrix
  cnames <- colnames(dist.mat)
  
  # For each column (aka cell) in the data... 
  for(X in cnames){
    
    # Find the distances of all other columns to that column 
    distances <- dist.mat[, X]
    
    # Reorder the distances, smallest to largest (this will reorder the column names as well)
    distances.ordered <- distances[order(distances, decreasing = F)]
    
    # Reorder the data matrix columns, smallest distance to largest from the column of interest
    dat.reordered <- dat[ , names(distances.ordered) ]
    
    # Take the values in the column of interest
    vec <- dat[, X]
    
    # Which entries are missing and need to be imputed...
    na.index <- which( is.na(vec) )
    
    # For each of the missing entries (rows) in column X...
    for(i in na.index){
      # Find the most similar columns that have a non-NA value in this row
      closest.columns <- names( which( !is.na(dat.reordered[i, ])  ) )
      
      # If there are more than k such columns, take the first k most similar
      if( length(closest.columns)>k ){
        # Replace NA in column X with the mean the same row in k of the most similar columns
        vec[i]<-mean( dat[ i, closest.columns[1:k] ] )
      }
      
      
      # If there are less that or equal to k columns, take all the columns
      if( length(closest.columns)<=k ){
        # Replace NA in column X with the mean the same row in all of the most similar columns
        vec[i]<-mean( dat[ i, closest.columns ] )
      }
    }
    
    # Populate a the matrix with the new, imputed values
    dat.imp[,X] <- vec
  }
  return(dat.imp)
}
```

## Missing value imputation

```{r processSCproteomicsData}
#read in single-cell proteomics data and summarize to protein level by taking median of each protein's peptides after filtering out control cells
#scProt <- fread("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/Slavov sc proteomics/slavov_sc_proteomics_emt_filtered_cells.txt", drop = 1) %>% 
# filter(control == "sc", celltype != "neg") %>% 
# mutate(quantitation = ifelse(is.na(quantitation), 0, quantitation)) %>% 
# group_by(protein, id) %>% 
# summarise(quantitation = median(quantitation), id = paste(unique(id), unique(celltype), sep="_")) %>% 
# dcast(protein ~ id, value.var = "quantitation")

#data pre-processing function
preprocessSCProteomics <- function(scProt, k = 3, distanceMetric = c("euclidean", "pearson"), impute = c("TRUE, FALSE"), mapUniprotID = c("FALSE", "TRUE")){
  if(impute == TRUE){
    #impute missing values in matrix by KNN imputation
    scProt <- sc_imputation(dat = scProt, k, distanceMetric)
  }
  #omit missing values
  else{
    scProt <- scProt[complete.cases(scProt),]
  }
  
  if(mapUniprotID == TRUE){
    #read in UniProt ID mappings
    uniprot <- fread("/Users/Ahmed/Documents/Emili_Lab/PPI Databases/UniProt ID mapping/uniprot_human_mapping.csv")
    uniprot <- setNames(uniprot$gene_symbol, uniprot$uniprot)
    
    #map UniProt IDs to gene symbols in sc proteomics dataset
    rownames(scProt) <- make.unique(gsub(pattern = "-.*", "", rownames(scProt)))
    mappings <- uniprot[rownames(scProt)]
    scProt <- scProt[!is.na(mappings),]
    rownames(scProt) <- make.unique(mappings[!is.na(mappings)])
  }
  
  #group sc data by cell and normalize to sum to 1
  scProt <- scProt %>% 
    as.data.frame() %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    group_by(variable) %>% 
    mutate(value = value / sum(value)) %>%
    dcast(gene ~ variable) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.data.frame()
  
  #read in cell timepoint labels
  cellLabels <- unique(fread("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/Slavov sc proteomics/slavov_sc_proteomics_emt_filtered_cells.txt", drop = 1)[, c("id", "celltype")]) %>% 
    filter(id %in% colnames(scProt))
  
  #create new cell labels combining cell ID and timepoint
  cellLabels$key <- paste(cellLabels$id, cellLabels$celltype, sep = "_") 
  
  #order cells based on timepoint
  cellLabels <- cellLabels[order(cellLabels$celltype),]
  
  #create vector with cell ID mapping
  cellLabels <- setNames(cellLabels$key, cellLabels$id)
  
  #change column names of matrix to include cell labels
  colnames(scProt) <- cellLabels[colnames(scProt)]
  
  #sort cells by timepoint
  scProt <- scProt[, cellLabels]
  
  #list of genes detected in each dataset
  allProts <- list("scRNA-Seq" = rownames(scrna), "Bulk Proteomics" = rownames(proteome), "SC Proteomics" = rownames(scProt))
  
  #list of overlapping genes
  overlapProts <- Reduce(intersect, allProts)
  
  #keep overlapping genes only
  scProt <- scProt[overlapProts,]
  
  return(scProt)
}

#read in sc protein values
scProt <- read.delim("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/Slavov sc proteomics/slavov_sc_proteomics_emt_raw_protein.txt", row.names = 1)

#pre-process data
scProt <- preprocessSCProteomics(scProt, k = 3, distanceMetric = "euclidean", impute = TRUE, mapUniprotID = TRUE)
```


## Identify cell clusters in single-cell proteomics data

The cell states in the single-cell proteomics dataset are identified in an unsupervised manner based on similarity of protein abundance profiles. All cells from all timepoints are pooled together for this analysis. [Seurat](https://www.nature.com/articles/nbt.4096) is used to cluster the cells following their standard pipeline for scRNA-Seq data. Our model defines 11 cell clusters, to be comparable to the clusters identified in the scRNA-Seq data, by using a Seurat clustering resolution of 2.6 in the proteomics data and 1.2 in the RNA data. The below UMAP plots visualize the identified cell clusters.

Note: we re-clustered the scRNA-Seq data in this section using the genes that overlapped with the single-cell proteomics data.

```{r identifySCproteomicsClusters, fig.width = 10}
#list of genes detected in each dataset
allProts <- list("scRNA-Seq" = rownames(scrna), "Bulk Proteomics" = rownames(proteome), "SC Proteomics" = rownames(scProt))

#list of overlapping genes
overlapProts <- Reduce(intersect, allProts)

#create seurat objects
seurat <- createSeurat(as.matrix(scProt))
#seuratRNA <- createSeurat(as.matrix(scrna[overlapProts,]))

#list of resolutions for different numbers of seurat clusters
clusters <- setNames(c(0.7,0.9,1.15,1.4,2.0,2.2, 2.6,2.8,3.3, 3.4,3.5), 5:15)

#cluster both to 11 clusters
seurat <- FindClusters(seurat, resolution = clusters["11"], random.seed = 123)
#seuratRNA <- FindClusters(seuratRNA, resolution = 1.2, random.seed = 123)

#UMAP dimensionality reduction
seurat <- RunUMAP(seurat, dims = 1:10)
#seuratRNA <- RunUMAP(seuratRNA, dims = 1:10)

#plot UMAP
p1 <- DimPlot(seurat, reduction = "umap", label = T, pt.size = 3) + ggtitle("Single-cell proteomics cell clusters")
#p2 <- DimPlot(seuratRNA, reduction = "umap", label = T, pt.size = 3) + ggtitle("scRNA cell clusters")
#p1 | p2

#UMAP
set.seed(123)
umap <- as.data.frame(uwot::umap(t(scProt)))
umap$timepoint <- colnames(seurat)
umap$timepoint <- gsub(".*_","", umap$timepoint)

#create matrix A with counts of cell clusters in each timepoint
A_prot <- computeCellProportions(seurat)
#A_rna <- computeCellProportions(seuratRNA)

#convert cell type counts to proportions
timeProportions_prot <- data.frame(apply(A_prot, 1, function(x) return(x/sum(x))))

#convert to long format for ggplot
timeProportions_prot <- melt(timeProportions_prot)
colnames(timeProportions_prot) <- c('Timepoint', 'Proportion')
timeProportions_prot$Proportion <- round(timeProportions_prot$Proportion, 2)

#add column for cluster name
timeProportions_prot$Cell_State <- as.factor(rep(0:(length(unique(Idents(seurat)))-1), length(unique(timeProportions_prot$Timepoint))))

#plot
p2 <- ggplot(timeProportions_prot, aes(x = Timepoint, y = Proportion, fill = Cell_State,
                                       label = ifelse(Proportion > 0.015, paste0(Proportion*100,'%'), "") )) +
  geom_bar(stat = 'identity') + 
  geom_text(size = 2, position = position_stack(vjust = 0.5)) +
  ggtitle("Cell type composition in each timepoint - SC Proteomics") +
  theme_minimal()

p1 | p2
```

## Cell cluster profiles

For each cluster, a cell cluster profile is constructed as the average gene expression profile of the member cells. Consequently, the cell cluster profile matrix $X$ consists of the ~1,000 genes * 11 cell clusters. Cell clusters are labeled as epithelial ($E$), mesenchymal ($M$), or intermediate ($I$) based on manual inspection of the above timepoint proportion plots. The heatmap below shows the constructed cell cluster profiles scaled by row.

```{r constructCellClusterProfiles}
#construct matrix with cell-type expression of each gene - proteomics
X_prot <- as.data.frame(scProt[overlapProts,]) %>% 
  mutate(gene = rownames(.)) %>% 
  melt() %>% 
  mutate(cluster = Idents(seurat)[variable]) %>% 
  group_by(gene, cluster) %>% 
  summarise(value = mean(value)) %>% 
  dcast(gene ~ cluster) %>% 
  magrittr::set_rownames(.$gene) %>% 
  dplyr::select(-1) %>% 
  as.matrix() #%>% 
#t()

#rename clusters based on classification
colnames(X_prot) <- c("cluster_0_E", "cluster_1_M", "cluster_2_I", "cluster_3_E", "cluster_4_E", "cluster_5_M",
                      "cluster_6_I", "cluster_7_M", "cluster_8_I", "cluster_9_E", "cluster_10_M")

#reorder clusters to go E -> M
X_prot <- X_prot[, c(grep("E", colnames(X_prot), value = TRUE), grep("I", colnames(X_prot), value = TRUE), grep("M", colnames(X_prot), value = TRUE))]

#rename cluster centroids to indicate which dataset they came from
colnames(X_prot) <- paste0("sc_", colnames(X_prot))

pheatmap(X_prot, scale = "row",
         show_rownames = F, show_colnames = T,
         cluster_cols = T, cluster_rows = T, 
         main = "SC proteomics cell cluster profiles (scaled by row)")
```

## Re-constructing bulk proteomics data from single-cell proteomics data

In this section, we examine the relationship between the bulk proteomics data generated by the Emili Lab and the single-cell proteomics data generated by the Slavov Lab, both of which are dependent on mass spectrometry. The bulk proteomics data was subset to the three timepoints corresponding to days 0, 3, and 9 to correspond with the single-cell proteomics data. The three replicates of each timepoint in the bulk data were averaged to produce one profile per timepoint.

To compare the single-cell proteomics to the bulk, we create two datasets from the single-cell proteomics data:

1) ***Pseudo-bulk***: A pseudo-bulk proteomics dataset is created for each timepoint by summing the protein levels of all cells within the timepoint.
2) ***Reconstructed Pseudo-bulk***: The reconstructed pseudo-bulk is created by matrix multiplication of the average cell cluster abundance of each protein by the number of cells in each cluster in each timepoint, i.e. $Y = AX$.

This gives three bulk proteomics datasets in total, including the actual bulk and the two datasets above. The three bulk datasets are shown below, with the genes maintained in the same order.

```{r reconstructBulkProteomicsFromScProteomics}
#read in '2D' proteomics data and average replicates in each timepoint
bulkProt <- fread("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/proteinGroups_Prot.txt") %>% 
  as.data.frame() %>% 
  .[, c("Gene names", grep("Reporter intensity corrected .* [A-C]", colnames(.), value = TRUE))] %>% 
  magrittr::set_names(c("Gene", gsub("Reporter intensity corrected ", "T", colnames(.)[-1]))) %>% 
  melt() %>% 
  #average replicates
  mutate(variable = gsub(" .*","", variable)) %>% 
  group_by(Gene, variable) %>% 
  summarize(intensity = mean(value)) %>% 
  #convert to wide format
  dcast(Gene ~ variable) %>% 
  magrittr::set_rownames(.$Gene) %>% 
  #keep timepoints that are present in sc proteomics data
  select(c("T0", "T3", "T9")) %>%
  as.matrix()

#create pseudobulk proteomics
pseudobulkProt <- createPseudoBulk(scProt)

#create reconstructed pseudobulk proteomics
reconstructedProt <- t(A_prot %*% t(X_prot))

#keep overlapping genes only
overlapProt <- Reduce(intersect, list(rownames(bulkProt), rownames(pseudobulkProt), rownames(reconstructedProt)))
bulkProt <- bulkProt[overlapProt,]
pseudobulkProt <- pseudobulkProt[overlapProt,]
reconstructedProt <- reconstructedProt[overlapProt,]

#put into one table
allBulk <- as.matrix(do.call("cbind", list(bulkProt, pseudobulkProt, reconstructedProt)))

#normalize timepoints to sum to 1 in each timepoint
allBulk <- apply(allBulk, 2, function(x) return(x / sum(x)))

#names of matrices
matrixNames <- c("Bulk proteomics", "Pseudobulk", "Reconstructed pseudobulk")

#create heatmaps
ComplexHeatmap::Heatmap(allBulk,
                        name = "Counts", cluster_columns = FALSE, cluster_rows = T,
                        column_split = rep(matrixNames, each = ncol(bulkProt)), use_raster = T, 
                        show_row_names = F, show_column_names = T, 
                        row_title = "Proteins")
```
```{r computeLambdaForDifferentProteins, eval = FALSE}
#set of lambdas to test for ridge regression (should be in decreasing order)
lambdaSet <- sort(10^(-10:10), decreasing = TRUE)

#create seurat object
seurat <- createSeurat(scProt)

#read in pre-computed log-fold change values for each gene
#allLogFC <- readRDS("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/allFoldChanges.rds")

#compute distance between real matrix and predicted matrix for different number of Seurat clusters
proteinLambdas <- pblapply(names(clusters), function(clust){
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scProt %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #reconstruct bulk matrix
  Y <- A %*% X
  
  #compute coefficient of variation of genes across clusters
  geneCV_clusters <- apply(X, 2, function(x) return(sd(x) / mean(x)))
  
  #group genes into groups according to variance across clusters
  geneCV_clusters_groups <- split(sort(geneCV_clusters), sort(1:length(geneCV_clusters) %% 10))
  
  #names(geneCV_groups) <- c("Low variation", "Medium variation", "High variation")
  
  #create table with each gene's CV and variation classification
  clusterCVClass <- do.call("rbind", lapply(names(geneCV_clusters_groups),
                                            function(x) return(data.frame(Gene = names(geneCV_clusters_groups[[x]]),
                                                                          Cross_cluster_CV_class = x,
                                                                          Cross_cluster_CV = geneCV_clusters[names(geneCV_clusters_groups[[x]])]))))
  
  #compute coefficient of variation of genes across timepoints
  geneCV_timepoints <- apply(Y, 2, function(x) return(sd(x) / mean(x)))
  
  #group genes into groups according to variance across clusters
  geneCV_timepoints_groups <- split(sort(geneCV_timepoints), sort(1:length(geneCV_timepoints) %% 10))
  
  #create table with each gene's CV and variation classification
  timepointCVClass <- do.call("rbind", lapply(names(geneCV_timepoints_groups),
                                              function(x) return(data.frame(Gene = names(geneCV_timepoints_groups[[x]]),
                                                                            Cross_timepoint_CV_class = x,
                                                                            Cross_timepoint_CV = geneCV_timepoints[names(geneCV_timepoints_groups[[x]])]))))
  
  #compute average expression across timepoints
  av_expression <- apply(Y, 2, function(x) return(mean(x)))
  
  #group genes into groups based on order of average expression
  av_expression_groups <- split(sort(av_expression), sort(1:length(av_expression) %% 10))
  
  #create table with each gene's average expression and classification
  avExpressionClass <- do.call("rbind", lapply(names(av_expression_groups),
                                               function(x) return(data.frame(Gene = names(av_expression_groups[[x]]),
                                                                             Average_expression_class = x,
                                                                             Average_expression = av_expression[names(av_expression_groups[[x]])]))))
  
  #extract pre-computed log fold-change scores for genes
  #curLogFC <- allLogFC[[clust]] %>% 
  #mutate(avg_log2FC = abs(avg_log2FC)) %>% 
  #group_by(gene) %>% 
  #filter(avg_log2FC == max(avg_log2FC)[1])
  
  #geneLogFC <- setNames(curLogFC$avg_log2FC, curLogFC$gene)
  
  #group genes into groups according to logFC
  # geneLogFC_groups <- split(sort(geneLogFC), sort(1:length(geneLogFC) %% 15))
  
  #create table with each gene's CV and variation classification
  #geneLogFcClass <- do.call("rbind", lapply(names(geneLogFC_groups),
  #                                          function(x) return(data.frame(Gene = names(geneLogFC_groups[[x]]),
  #                                                                       Log_FC_class = x,
  #                                                                      Max_Log_FC = geneLogFC[names(geneLogFC_groups[[x]])]))))
  
  #merge dataframes with gene properties into one
  geneVarClass <- list(clusterCVClass, timepointCVClass, avExpressionClass) %>% purrr::reduce(left_join, by = "Gene")
  
  #construct matrix with all combinations of lambda and gene name and gene variation
  parameters <- merge(geneVarClass, data.frame(Lambda = lambdaSet, Number_of_clusters = clust), by = NULL)
  
  #define required matrices/vectors for the quadratic solver
  Dmat <- t(A) %*% A
  Amat <- diag(ncol(A))
  
  #predict single-cell profiles using constrained ridge regression for each value of lambda
  X_hat <- apply(parameters, 1, function(curParameters){
    #extract current parameters
    lambda <- as.numeric(curParameters[["Lambda"]])
    curGene <- Y[, curParameters[["Gene"]]]
    
    ##predict single-cell profiles
    
    #add small scaling of the identity matrix to Dmat to regularize prediction
    Dmat <- Dmat + lambda*diag(nrow(Dmat))
    
    #to avoid overflow cause by large values, scale Dmat and dvec
    scalingFactor <- norm(Dmat, "2")
    
    #define required matrices/vectors for the quadratic solver
    dvec <- t(A) %*% curGene
    
    #solve quadratic equation
    prediction <- quadprog::solve.QP(Dmat / scalingFactor, dvec / scalingFactor, Amat)$solution
    
    #set names of prediction to clusters
    names(prediction) <- paste0("cluster_", 0:(length(prediction) - 1))
    
    #compute relative error between prediction and real values
    curError <- abs(X[, curParameters[["Gene"]] ] - prediction) / X[, curParameters[["Gene"]] ]
    curParameters$Relative_error <- mean(curError[!is.infinite(curError)])
    
    #add the predicted value to the table
    curParameters <- cbind(curParameters, data.frame(t(prediction)))
    
    return(as.data.frame(curParameters))
  }) %>% 
    do.call("rbind", .)
  
  return(X_hat)
}, cl = 6)

#merge all results into one table
# get all variable names
allNms <- unique(unlist(lapply(proteinLambdas, names)))
proteinLambdas <- do.call(rbind, c(lapply(proteinLambdas, function(x) data.frame(c(x, sapply(setdiff(allNms, names(x)), function(y) NA)))), make.row.names=FALSE))

proteinLambdas$Lambda <- as.numeric(proteinLambdas$Lambda)
#proteinLambdas$Max_Log_FC <- as.numeric(proteinLambdas$Max_Log_FC)
proteinLambdas$Cross_cluster_CV <- as.numeric(proteinLambdas$Cross_cluster_CV)
proteinLambdas$Cross_timepoint_CV <- as.numeric(proteinLambdas$Cross_timepoint_CV)
proteinLambdas$Number_of_clusters <- as.integer(proteinLambdas$Number_of_clusters)
proteinLambdas$Cross_cluster_CV_class <- as.integer(proteinLambdas$Cross_cluster_CV_class)
proteinLambdas$Cross_timepoint_CV_class <- as.integer(proteinLambdas$Cross_timepoint_CV_class)
proteinLambdas$Average_expression_class <- as.integer(proteinLambdas$Average_expression_class)
#proteinLambdas$Log_FC_class <- as.integer(proteinLambdas$Log_FC_class)
saveRDS(proteinLambdas, "/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/proteinLambdas.rds")
```

The deconvolution algorithm was applied to the reconstructed pseudobulk to examine the method's ability to re-construct the single-cell profiles. The key input parameter for the deconvolution algorithm is the regularization parameter $\lambda$ for solving the ridge regression problem. After selecting the optimal $\lambda$ for each gene we report the errors as relative RMAD (relative mean absolute deviation) using the formula $|X - X'| / X$, where $|X|$ is the absolute value of the difference. This error is computed for each gene and the final reported score is the average RMAD value, in other words: *on average, how different is a gene's predicted values compared to the true ones?* The resultant relative RMAD values are shown below for each number of clusters.


```{r individualGeneLambdasErrors, out.width = '.49\\linewidth', fig.align = 'center', fig.show = 'hold'}
#read in all scores for all values of lambda and all genes
proteinLambdas <- readRDS("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/proteinLambdas.rds")

#subset to optimal lambdas
optimalLambdas <- proteinLambdas %>% 
  group_by(Gene, Number_of_clusters) %>% 
  filter(Relative_error == min(Relative_error)) %>% 
  filter(!is.infinite(Relative_error))

#average errors for each number of clusters
errors <- optimalLambdas %>%
  #filter(Dataset == "Reconstructed pseudobulk") %>% 
  group_by(Number_of_clusters) %>% 
  summarise(Relative_error = mean(Relative_error))

#visualize errors with line plots
ggplot(errors, aes(x = Number_of_clusters, y = Relative_error)) +
  geom_line() + geom_point() +
  scale_x_continuous(breaks = 5:15) +
  labs(title = "Relative error of estimating single-cell proteomics profiles using different numbers of clusters",
       subtitle = "Deconvolution of reconstructed pseudobulk")
```
## Evaluation of single-cell predictions


The below sections examine the accuracy of the single-cell predictions made using ridge regression in the previous section. Note: the bulk matrix that is deconvoluted in this section is the reconstructed pseudo-bulk matrix ($Y=AX$).

#### Are our predicted cluster centroids close to the real ones?

The cluster centroid is each cluster’s average gene expression profile. Visualizing the two sets of centroids (real & predicted) side-by-side on a *UMAP* will help us answer this question. For each number of clusters between 5 and 15, we cluster the data using *Seurat* and construct the matrix $X$ which contains the average gene expression by cluster. We then use the ridge regression approach defined in the previous section to construct the matrix $X'$. Finally, we perform a *UMAP* projection using the R package [uwot](https://github.com/jlmelville/uwot) on the original single-cell proteomics matrix but with the addition of the real and predicted cluster centroids, i.e. the rows of $X$ and $X'$. The *UMAP*s below show the projections for each number of clusters.

```{r UMAPpredictedVsRealCentroidsIndividualLambdas, eval = FALSE}
#create seurat object
seurat <- createSeurat(scProt)

#for each no. of clusters, construct UMAP
umapList <- pblapply(names(clusters), function(clust){
  #get error values for current no. of clusters
  curErrors <- optimalLambdas[optimalLambdas$Number_of_clusters == as.numeric(clust),]
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scProt %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #get predicted values for current gene
  X_hat <- curErrors %>% 
    as.data.frame() %>% 
    set_rownames(.$Gene) %>% 
    select(grep("^cluster_", colnames(.))) %>% 
    t() %>% 
    .[complete.cases(.),]
  
  #sort matrices to all follow the same order of genes
  overlapGenes <- Reduce(intersect, list(rownames(scProt), colnames(X), colnames(X_hat)))
  scProt <- scProt[overlapGenes, ]
  X <- X[, overlapGenes]
  X_hat <- X_hat[, overlapGenes]
  
  #concatenate centroids to single-cell expression matrix
  mergedSC <- rbind(t(scProt), X, X_hat)
  
  #UMAP
  set.seed(123)
  umap <- as.data.frame(uwot::umap(mergedSC))
  
  #add label indicating whether point is a centroid
  umap$centroid <- c(rep("cell", ncol(scProt)), rep("real centroid", nrow(X)), rep("predicted centroid", nrow(X_hat)))
  
  #add label indicating the no. of cluster for this UMAP
  umap$number_of_clusters <- paste(clust, "clusters")
  
  #add label indicating cell cluster
  umap$cluster <- c(rep(NA, ncol(scProt)), rep(1:nrow(X), 2))
  
  return(umap)
}, cl = 6)

#merge all results into one table
mergedUmap <- do.call("rbind", umapList)

#save locally
saveRDS(mergedUmap, "/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/proteomics_UMAP_list_sc_predictions.rds")
```

```{r UMAPcomparisonOfPredcitionsIndividualLambdas, fig.width = 16, fig.height = 16}
#read in pre-computed UMAP projections
mergedUmap <- readRDS("/Users/Ahmed/Documents/Emili_Lab/Aim 3/EMT Multi-omics/Data/proteomics_UMAP_list_sc_predictions.rds") %>% 
  mutate(number_of_clusters = factor(number_of_clusters, levels = paste(5:15, "clusters")))

#plot
ggplot(mergedUmap, aes(x = V1, y = V2, col = centroid)) +
  geom_point() +
  geom_label(label = mergedUmap$cluster) + 
  facet_wrap( ~ number_of_clusters) + 
  scale_color_manual(values = c("grey", "red", "blue"), name = "Key") +
  theme_classic2() +
  ggtitle("UMAP visualization of the predicted cell cluster centroids relative to the predicted ones")
```

#### How similar is the average cell to it's real centroid compared to the predicted one?  

To determine if our predictions are reasonable approximations of the real data, we also compare the predictions to the real data by computing the Euclidean distance between individual cells’ measurements and their real cluster average as opposed to the distance between our predictions and the same cluster average.

More specifically, for a given number of clusters, we cluster the data using *Seurat*, followed by iterating over each of the cells in the original single-cell matrix and computing the Euclidean distance between it's profile and that of its cluster's centroid. Next, for each cluster we compute the average distance of it's cells to the centroid, as well as the distance between our predicted centroid and the corresponding cluster centroid. By comparing these two distances side-by-side, we can determine whether our predicted centroids fall within the correct intra-cluster range.

```{r distancesBetweenCellsAndCentroidsIndividualLambdas, fig.width = 16, fig.height = 16}
#create seurat object
seurat <- createSeurat(scProt)

#for each no. of clusters, predict X' and find average distance between cells and their centroids (~1m)
centroidDistances <- pblapply(names(clusters), function(clust){
  #get error values for current no. of clusters
  curErrors <- optimalLambdas[optimalLambdas$Number_of_clusters == as.numeric(clust),]
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scProt %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #get predicted values for current gene
  X_hat <- curErrors %>% 
    as.data.frame() %>% 
    set_rownames(.$Gene) %>% 
    select(grep("^cluster_", colnames(.))) %>% 
    t() %>% 
    .[complete.cases(.),]
  
  #create matrix A with proportions of cell clusters in each timepoint
  A <- computeCellProportions(seurat)
  
  #sort matrices to all follow the same order of genes
  overlapGenes <- Reduce(intersect, list(rownames(scProt), colnames(X), colnames(X_hat)))
  scProt <- scProt[overlapGenes, ]
  X <- X[, overlapGenes]
  X_hat <- X_hat[, overlapGenes]
  
  #break up single-cell expression matrix by cluster and compare to centroids
  clusterDistances <- lapply(sort(unique(Idents(seurat))), function(curCluster){
    #get counts for cells belonging to this cluster
    curCounts <- t(scProt[, Idents(seurat) == curCluster])
    
    #get centroid belonging to this cluster
    curCentroid <- X[curCluster,]
    
    #compute distances between each cell and the corresponding centroid
    curDistances <- apply(curCounts, 1, function(cell){
      return(sqrt(sum((cell - curCentroid)^2)))
    })
    
    #get average distance
    averageDistance <- mean(curDistances, na.rm = TRUE)
    
    #find distance between predicted centroid and real centroid
    centroidDistance <- sqrt(sum((curCentroid - X_hat[curCluster,])^2))
    
    #return table with distances
    toReturn <- data.frame(Type = c("Average cell", "Predicted centroid"),
                           Distance = c(averageDistance, centroidDistance),
                           Number_of_cells = nrow(curCounts),
                           Cluster = curCluster)
  })
  
  #find coefficient of variation for each cluster's proportion across timepoints
  proportions <- A / rowSums(A)
  cvProportions <- apply(proportions, 2, function(curCluster) return(sd(curCluster) / mean(curCluster)))
  clusterDistances <- lapply(seq_along(cvProportions), function(curTable){
    clusterDistances[[curTable]]$Cell_type_proportion_variation <- cvProportions[curTable]
    return(clusterDistances[[curTable]])
  })
  
  #merge results from all clusters into one table
  clusterDistances <- do.call("rbind", clusterDistances)
  
  #add column indicating the number of clusters
  clusterDistances$Number_of_clusters <- paste(clust, "clusters")
  
  return(clusterDistances)
}, cl = 6)

#merge results into one table
centroidDistances <- do.call("rbind", centroidDistances)

#reorder data based on number of clusters
centroidDistances <- centroidDistances %>% mutate(Number_of_clusters = factor(Number_of_clusters, levels = paste(5:15, "clusters")))

#plot bar plot
ggplot(centroidDistances, aes(x = Cluster, y = Distance, fill = Type)) + 
  geom_bar(stat = "identity", position = "dodge", width = .5) +
  facet_wrap( ~ Number_of_clusters, scales = "free") +
  labs(title = "Average Euclidean distance between each cluster's cells and it's centroid compared to the predicted centroid",
       subtitle = "Is the average cell closer to its assigned centroid than the predicted centroid?")+
  theme_bw() +
  coord_flip()
```

#### Correlation of cluster centroids

The below plot visualizes the correlation of the cell cluster centroids predicted by our algorithm and those computed from the single-cell proteomics data.

```{r comparingClustersProteomics, fig.width = 24, fig.height = 16}
#for each no. of clusters, construct centroid correlation matrix
centroidCor <- pblapply(names(clusters), function(clust){
  #get error values for current no. of clusters
  curErrors <- optimalLambdas[optimalLambdas$Number_of_clusters == as.numeric(clust),]
  
  #cluster seurat object
  seurat <- FindClusters(seurat, resolution = clusters[clust], random.seed = 123)
  
  #construct matrix with cell-type expression of each gene
  X <- scProt %>% 
    mutate(gene = rownames(.)) %>% 
    melt() %>% 
    mutate(cell = Idents(seurat)[variable]) %>% 
    group_by(gene, cell) %>% 
    summarise(value = mean(value)) %>% 
    dcast(gene ~ cell) %>% 
    magrittr::set_rownames(.$gene) %>% 
    select(-1) %>% 
    as.matrix() %>% 
    t()
  
  #get predicted values for current gene
  X_hat <- curErrors %>% 
    as.data.frame() %>% 
    set_rownames(.$Gene) %>% 
    select(grep("^cluster_", colnames(.))) %>% 
    t() %>% 
    .[complete.cases(.),]
  
  #sort matrices to all follow the same order of genes
  overlapGenes <- Reduce(intersect, list(rownames(scProt), colnames(X), colnames(X_hat)))
  scProt <- scProt[overlapGenes, ]
  X <- X[, overlapGenes]
  X_hat <- X_hat[, overlapGenes]
  
  #correlate clusters
  centroidCor <- lapply(seq(nrow(X)), function(i){
    curPrediction <- X_hat[i,]
    clusterCors <- list()
    for(j in seq(nrow(X))){
      curProt <- X[j,]
      curCor <- cor(curPrediction, curProt)
      clusterCors <- append(clusterCors, curCor)
    }
    return(unlist(clusterCors))
  }) %>% 
    do.call("rbind", .)
  rownames(centroidCor) <- paste0("real_cluster_",rownames(X))
  colnames(centroidCor) <- paste0("predicted_", rownames(X_hat))
  
  return(pheatmap(centroidCor, silent = T, main = paste("Correlation of centroids -", clust, "clusters"))[[4]])
}, cl = 6)

#plot
gridExtra::grid.arrange(arrangeGrob(grobs = centroidCor, ncol = 4))

```

#### Which clusters are easier to predict?  

The accuracy of recapturing the cell cluster profiles varied by cluster. In this section, we are interested in examining the mathematical properties of the cell clusters derived from the scRNA-Seq data that influence the quality of our predictions. We first compute the correlation between how ’tightly-knit’ a cluster is, i.e. average within-cluster distance to the centroid, and the error in predicting the profiles. We also correlate the prediction error with the number of cells in each cluster and the variation of each cell type's proportion across timepoints. The error in this section is taken as the Euclidean distance between the cluster's predicted centroid and the actual centroid.

```{r correlationOfClusterTightnessToErrorIndividualLambdas, fig.width = 20, fig.height = 8}
#compute correlations from results of the section comparing centroids
centroidErrors <- centroidDistances[centroidDistances$Type == "Predicted centroid", "Distance"]
clusterTightness <- centroidDistances[centroidDistances$Type == "Average cell", "Distance"]
clusterSizes <- centroidDistances[centroidDistances$Type == "Average cell", "Number_of_cells"]
clusterVariations <- centroidDistances[centroidDistances$Type == "Average cell", "Cell_type_proportion_variation"]

forPlot <- data.frame("Distance_between_real_and_predicted_centroid" = centroidErrors,
                      "Average_within_cluster_distance" = clusterTightness,
                      "Number_of_cells" = clusterSizes,
                      "Cell_type_proportion_variation" = clusterVariations)

#plots
p1 <- ggplot(forPlot, aes(x = Average_within_cluster_distance, y = Distance_between_real_and_predicted_centroid)) +
  geom_point() +
  geom_smooth(method = lm) +
  ggpubr::stat_cor(method = "pearson") +
  labs(title = "Relationship between a cluster's tightness and prediction errors", subtitle = "Each point represents a cluster")

p2 <- ggplot(forPlot, aes(x = Number_of_cells, y = Distance_between_real_and_predicted_centroid)) +
  geom_point() +
  geom_smooth(method = lm) +
  ggpubr::stat_cor(method = "pearson") +
  labs(title = "Relationship between a cluster's size and prediction errors", subtitle = "Each point represents a cluster")

p3 <- ggplot(forPlot, aes(x = Cell_type_proportion_variation, y = Distance_between_real_and_predicted_centroid)) +
  geom_point() +
  geom_smooth(method = lm) +
  ggpubr::stat_cor(method = "pearson") +
  labs(title = "Relationship between a cluster's proportion variation across timepoints and prediction errors", subtitle = "Each point represents a cluster")

p1|p2|p3
```

# Comparing scRNA-derived predictions to single-cell proteomics data

In this section, we compare the experimentally-derived single-cell profiles to our computationally-predicted ones as an external benchmark.

## Comparing predicted and real cell clusters

The below UMAP plot includes the centroid of each cluster in each dataset. The centroid is computed as the average abundance of each protein in each cluster's cells. Prior to performing the UMAP dimensionality reduction, the values were normalized to sum to 1 in each cluster. We use the scenario with 11 cell clusters for this section.

```{r UMAPcombinedCentroids, fig.width = 10}
#adjust names of predictions
rownames(prediction) <- paste0("predicted_", rownames(prediction))

#merge centroids to one table
predictionOverlap <- intersect(colnames(prediction), rownames(X_prot))
mergedCentroids <- cbind(X_prot[predictionOverlap,], t(prediction[,predictionOverlap]))

#normalize cluster centroids to sum to 1 in each cluster
mergedCentroids <- apply(mergedCentroids, 2, function(x) return(x / sum(x)))

#UMAP
set.seed(123)
mergedCentroidsUmap <- as.data.frame(uwot::umap(t(mergedCentroids))) %>% mutate(cluster = colnames(mergedCentroids),
                                                                                data = gsub("_.*", "", colnames(mergedCentroids)))

ggplot(mergedCentroidsUmap, aes(x = V1, y = V2, color = cluster, shape = data)) +
  geom_point(size = 2) +
  labs(title = "Combined UMAP of SC Proteomics and scRNA cluster centroids") +
  theme_bw()
```

## Comparing correlation patterns in scRNA and single-cell proteomics  

We examine and compare the correlation patterns in the scRNA and single-cell proteomics datasets. A correlation matrix was computed for each dataset that computed the Pearson correlation between cells based on all of the proteins (~8,500 for scRNA and ~200 for sc proteomics). The below plot visualizes the distributions of these correlation values.

```{r compareCorrelation, fig.width = 10}
#correlation matrix of scRNA and sc proteomics
rnaCors <- WGCNA::cor(scrna) #WGCNA for much faster correlation computation
protCors <- WGCNA::cor(scProt)

#remove self-correlations and keep unique correlations
rnaCors <- rnaCors[lower.tri(rnaCors)]
protCors <- protCors[lower.tri(protCors)]

#convert to long format
rnaCors <- data.frame(Pearson_correlation = rnaCors, Data = "SC RNA")
protCors <- data.frame(Pearson_correlation = protCors, Data = "SC Proteomics")
forPlot <- rbind(rnaCors, protCors)

#plot
ggplot(forPlot, aes(x = Pearson_correlation, fill = Data)) +
  geom_density(alpha = 0.8) +
  labs(title = "Distribution of cell-to-cell correlations in single-cell datasets")
```

